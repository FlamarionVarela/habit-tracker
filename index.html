<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸš€ Rastreador de HÃ¡bitos Circular - VersÃ£o 2707</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: rgb(17, 24, 39);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        /* Scrollbars customizadas */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(34, 211, 238, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(34, 211, 238, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ðŸš€ NOVA VERSÃƒO 2007.3 - SALVAMENTO AUTOMÃTICO IMPLEMENTADO:
        // âœ… Sistema de persistÃªncia automÃ¡tica com localStorage
        // âœ… Auto-save ao fechar/sair da pÃ¡gina (beforeunload, visibilitychange)
        // âœ… Salvamento em tempo real a cada mudanÃ§a importante
        // âœ… Indicador visual de status de salvamento
        // âœ… Carregamento automÃ¡tico ao inicializar o app
        // âœ… Backup de seguranÃ§a e recuperaÃ§Ã£o de dados
        // âœ… OtimizaÃ§Ãµes de performance para salvamento
        // âœ… ÃCONES COMPATÃVEIS: Font Awesome substituindo Lucide React

        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        // ðŸŽ¯ SISTEMA DE ÃCONES COMPATÃVEL - Font Awesome
        const Plus = ({ className }) => <i className={`fas fa-plus ${className}`}></i>;
        const Settings = ({ className }) => <i className={`fas fa-cog ${className}`}></i>;
        const Calendar = ({ className }) => <i className={`fas fa-calendar-alt ${className}`}></i>;
        const Edit2 = ({ className }) => <i className={`fas fa-edit ${className}`}></i>;
        const Trash2 = ({ className }) => <i className={`fas fa-trash ${className}`}></i>;
        const BarChart3 = ({ className }) => <i className={`fas fa-chart-bar ${className}`}></i>;
        const Target = ({ className }) => <i className={`fas fa-bullseye ${className}`}></i>;
        const TrendingUp = ({ className }) => <i className={`fas fa-chart-line ${className}`}></i>;
        const Filter = ({ className }) => <i className={`fas fa-filter ${className}`}></i>;
        const Search = ({ className }) => <i className={`fas fa-search ${className}`}></i>;
        const RefreshCw = ({ className }) => <i className={`fas fa-sync-alt ${className}`}></i>;
        const Eye = ({ className }) => <i className={`fas fa-eye ${className}`}></i>;
        const Flame = ({ className }) => <i className={`fas fa-fire ${className}`}></i>;
        const Trophy = ({ className }) => <i className={`fas fa-trophy ${className}`}></i>;
        const Clock = ({ className }) => <i className={`fas fa-clock ${className}`}></i>;
        const Save = ({ className }) => <i className={`fas fa-save ${className}`}></i>;
        const CheckCircle = ({ className }) => <i className={`fas fa-check-circle ${className}`}></i>;
        const AlertCircle = ({ className }) => <i className={`fas fa-exclamation-circle ${className}`}></i>;

        const CircularHabitCalendar = () => {
          const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
          const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
          const [monthlyHabits, setMonthlyHabits] = useState({});
          const [habitData, setHabitData] = useState({});
          const [newHabit, setNewHabit] = useState('');
          const [selectedPriority, setSelectedPriority] = useState('medium');
          const [selectedDaysType, setSelectedDaysType] = useState('all');
          const [showAddForm, setShowAddForm] = useState(false);
          const [hoveredDay, setHoveredDay] = useState(null);
          const [hoveredHabit, setHoveredHabit] = useState(null);
          const [priorityFilter, setPriorityFilter] = useState('all');
          const [searchTerm, setSearchTerm] = useState('');
          const [showStats, setShowStats] = useState(false);
          const [focusedDay, setFocusedDay] = useState(null);
          const [rotationAngle, setRotationAngle] = useState(0);
          const [showStreaks] = useState(true);
          const [animations] = useState(true);
          const [compactMode] = useState(true);
          const [selectedHabitId, setSelectedHabitId] = useState(null);
          const [resetStatus, setResetStatus] = useState('');
          const [expandedHabitDetails, setExpandedHabitDetails] = useState(null);
          const [selectedScheduleTime, setSelectedScheduleTime] = useState('');
          const [selectedNotificationPref, setSelectedNotificationPref] = useState('onTime');
          const [editingHabitId, setEditingHabitId] = useState(null);
          const [editForm, setEditForm] = useState({
            name: '',
            priority: '',
            daysType: ''
          });

          const [currentTime, setCurrentTime] = useState(new Date());
          const [overdueCount, setOverdueCount] = useState(0);
          const [snoozedHabits, setSnoozedHabits] = useState({});
          const [overdueNotificationClosed, setOverdueNotificationClosed] = useState(false);

          // ðŸŽ¯ NOVO: Estados para salvamento automÃ¡tico
          const [saveStatus, setSaveStatus] = useState('saved'); // 'saving', 'saved', 'error'
          const [lastSaveTime, setLastSaveTime] = useState(null);
          const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);

          // Estados globais da Timeline para evitar perda durante re-renders
          const timelineScrollRef = useRef(null);
          const timelineInitialScrollDoneRef = useRef(false);
          const timelineUserInteractedRef = useRef(false);
          const [isTimelineExpanded, setIsTimelineExpanded] = useState(() => {
            const saved = loadFromPersistentStorage('habitTracker_timelineExpanded');
            return saved !== null ? saved : false;
          });

          // NOVA REF PARA PRESERVAR POSIÃ‡ÃƒO DO SCROLL
          const savedScrollPositionRef = useRef(0);
          const timelineVersionRef = useRef(0);

          // ðŸŽ¯ SISTEMA DE DADOS ISOLADOS PARA TIMELINE
          const timelineDataRef = useRef({
            todayHabits: [],
            completionSnapshot: {},
            isCurrentMonth: false,
            currentHour: 0,
            lastUpdate: 0
          });

          const [timelineForceUpdate, setTimelineForceUpdate] = useState(0);

          // ðŸŽ¯ NOVO: Refs para controle de salvamento
          const saveTimeoutRef = useRef(null);
          const lastSaveDataRef = useRef(null);
          const saveInProgressRef = useRef(false);

          const STORAGE_KEYS = {
            monthlyHabits: 'habitTracker_monthlyHabits',
            habitData: 'habitTracker_habitData',
            settings: 'habitTracker_settings',
            snoozedHabits: 'habitTracker_snoozedHabits',
            overdueNotificationClosed: 'habitTracker_overdueNotificationClosed',
            timelineExpanded: 'habitTracker_timelineExpanded',
            lastSaveTime: 'habitTracker_lastSaveTime',
            appVersion: 'habitTracker_appVersion'
          };

          // ðŸŽ¯ NOVO: Sistema de armazenamento persistente melhorado
          function saveToMemoryStorage(key, data) {
            try {
              window[key] = JSON.stringify(data);
            } catch (error) {
              console.error('Error saving to memory storage:', error);
            }
          }

          function loadFromMemoryStorage(key) {
            try {
              const item = window[key];
              return item ? JSON.parse(item) : null;
            } catch (error) {
              console.error('Error loading from memory storage:', error);
              return null;
            }
          }

          // ðŸŽ¯ NOVO: FunÃ§Ãµes de salvamento persistente
          function saveToPersistentStorage(key, data) {
            try {
              const dataToSave = JSON.stringify(data);
              // Usar localStorage quando disponÃ­vel
              if (typeof localStorage !== 'undefined') {
                localStorage.setItem(key, dataToSave);
              } else {
                // Fallback para memÃ³ria
                window[key] = dataToSave;
              }
              return true;
            } catch (error) {
              console.error('Error saving to persistent storage:', error);
              setSaveStatus('error');
              return false;
            }
          }

          function loadFromPersistentStorage(key) {
            try {
              let item;
              if (typeof localStorage !== 'undefined') {
                item = localStorage.getItem(key);
              } else {
                item = window[key];
              }
              return item ? JSON.parse(item) : null;
            } catch (error) {
              console.error('Error loading from persistent storage:', error);
              return null;
            }
          }

          // ðŸŽ¯ NOVO: Salvamento automÃ¡tico com debounce
          const autoSave = useCallback((immediate = false) => {
            if (!autoSaveEnabled || saveInProgressRef.current) return;

            // Preparar dados para salvamento
            const dataToSave = {
              monthlyHabits,
              habitData,
              snoozedHabits,
              overdueNotificationClosed,
              isTimelineExpanded,
              currentMonth,
              currentYear,
              priorityFilter,
              searchTerm,
              selectedHabitId,
              expandedHabitDetails,
              focusedDay,
              rotationAngle,
              showStats,
              lastSaveTime: Date.now(),
              appVersion: '2007.3'
            };

            // Verificar se houve mudanÃ§as
            const dataString = JSON.stringify(dataToSave);
            if (lastSaveDataRef.current === dataString && !immediate) {
              return; // NÃ£o hÃ¡ mudanÃ§as para salvar
            }

            // Cancelar salvamento anterior se pendente
            if (saveTimeoutRef.current) {
              clearTimeout(saveTimeoutRef.current);
            }

            const performSave = () => {
              setSaveStatus('saving');
              saveInProgressRef.current = true;

              try {
                // Salvar dados principais
                saveToPersistentStorage(STORAGE_KEYS.monthlyHabits, monthlyHabits);
                saveToPersistentStorage(STORAGE_KEYS.habitData, habitData);
                saveToPersistentStorage(STORAGE_KEYS.snoozedHabits, snoozedHabits);
                saveToPersistentStorage(STORAGE_KEYS.overdueNotificationClosed, overdueNotificationClosed);
                saveToPersistentStorage(STORAGE_KEYS.timelineExpanded, isTimelineExpanded);
                saveToPersistentStorage(STORAGE_KEYS.lastSaveTime, Date.now());
                saveToPersistentStorage(STORAGE_KEYS.appVersion, '2007.3');

                // Salvar configuraÃ§Ãµes do app
                const appSettings = {
                  currentMonth,
                  currentYear,
                  priorityFilter,
                  searchTerm,
                  selectedHabitId,
                  expandedHabitDetails,
                  focusedDay,
                  rotationAngle,
                  showStats
                };
                saveToPersistentStorage(STORAGE_KEYS.settings, appSettings);

                // TambÃ©m salvar em memÃ³ria para compatibilidade
                saveToMemoryStorage(STORAGE_KEYS.monthlyHabits, monthlyHabits);
                saveToMemoryStorage(STORAGE_KEYS.habitData, habitData);

                lastSaveDataRef.current = dataString;
                setLastSaveTime(Date.now());
                setSaveStatus('saved');

                // Auto-hide status apÃ³s 2 segundos
                setTimeout(() => {
                  setSaveStatus('saved');
                }, 2000);

              } catch (error) {
                console.error('Erro no auto-save:', error);
                setSaveStatus('error');
              } finally {
                saveInProgressRef.current = false;
              }
            };

            if (immediate) {
              performSave();
            } else {
              // Usar debounce para evitar salvamentos excessivos
              saveTimeoutRef.current = setTimeout(performSave, 1000);
            }
          }, [
            monthlyHabits, habitData, snoozedHabits, overdueNotificationClosed,
            isTimelineExpanded, currentMonth, currentYear, priorityFilter,
            searchTerm, selectedHabitId, expandedHabitDetails, focusedDay,
            rotationAngle, showStats, autoSaveEnabled
          ]);

          // ðŸŽ¯ NOVO: Carregamento automÃ¡tico na inicializaÃ§Ã£o
          const loadSavedData = useCallback(() => {
            try {
              setSaveStatus('saving');

              // Carregar dados principais
              const savedHabits = loadFromPersistentStorage(STORAGE_KEYS.monthlyHabits);
              const savedHabitData = loadFromPersistentStorage(STORAGE_KEYS.habitData);
              const savedSnoozed = loadFromPersistentStorage(STORAGE_KEYS.snoozedHabits);
              const savedNotificationState = loadFromPersistentStorage(STORAGE_KEYS.overdueNotificationClosed);
              const savedTimelineExpanded = loadFromPersistentStorage(STORAGE_KEYS.timelineExpanded);
              const savedLastSaveTime = loadFromPersistentStorage(STORAGE_KEYS.lastSaveTime);

              // Carregar configuraÃ§Ãµes do app
              const savedSettings = loadFromPersistentStorage(STORAGE_KEYS.settings);

              let dataLoaded = false;

              if (savedHabits) {
                setMonthlyHabits(savedHabits);
                dataLoaded = true;
              } else {
                // Criar hÃ¡bitos padrÃ£o se nÃ£o houver dados salvos
                const currentKey = new Date().getFullYear() + '-' + new Date().getMonth();
                const defaultHabits = {
                  [currentKey]: [
                    { id: 1, name: 'Ãgua 2L ðŸ’§', priority: 'high', observations: ['', '', ''], daysType: 'all', color: null, streak: 0, bestStreak: 0, scheduleTime: '08:30', notificationPreference: 'onTime' },
                    { id: 2, name: 'ExercÃ­cio ðŸƒâ€â™‚ï¸', priority: 'medium', observations: ['', '', ''], daysType: 'weekdays', color: null, streak: 0, bestStreak: 0, scheduleTime: '07:00', notificationPreference: 'onTime' },
                    { id: 3, name: 'Leitura ðŸ“š', priority: 'low', observations: ['', '', ''], daysType: 'all', color: null, streak: 0, bestStreak: 0, scheduleTime: null, notificationPreference: 'disabled' }
                  ]
                };
                setMonthlyHabits(defaultHabits);
              }

              if (savedHabitData) {
                setHabitData(savedHabitData);
                dataLoaded = true;
              }

              if (savedSnoozed) {
                setSnoozedHabits(savedSnoozed);
                dataLoaded = true;
              }

              if (savedNotificationState !== null) {
                setOverdueNotificationClosed(savedNotificationState);
                dataLoaded = true;
              }

              if (savedTimelineExpanded !== null) {
                setIsTimelineExpanded(savedTimelineExpanded);
                dataLoaded = true;
              }

              if (savedSettings) {
                // Restaurar configuraÃ§Ãµes do app
                if (savedSettings.currentMonth !== undefined) setCurrentMonth(savedSettings.currentMonth);
                if (savedSettings.currentYear !== undefined) setCurrentYear(savedSettings.currentYear);
                if (savedSettings.priorityFilter !== undefined) setPriorityFilter(savedSettings.priorityFilter);
                if (savedSettings.searchTerm !== undefined) setSearchTerm(savedSettings.searchTerm);
                if (savedSettings.selectedHabitId !== undefined) setSelectedHabitId(savedSettings.selectedHabitId);
                if (savedSettings.expandedHabitDetails !== undefined) setExpandedHabitDetails(savedSettings.expandedHabitDetails);
                if (savedSettings.focusedDay !== undefined) setFocusedDay(savedSettings.focusedDay);
                if (savedSettings.rotationAngle !== undefined) setRotationAngle(savedSettings.rotationAngle);
                if (savedSettings.showStats !== undefined) setShowStats(savedSettings.showStats);
                dataLoaded = true;
              }

              if (savedLastSaveTime) {
                setLastSaveTime(savedLastSaveTime);
              }

              setSaveStatus(dataLoaded ? 'saved' : 'saved');

              return dataLoaded;
            } catch (error) {
              console.error('Erro ao carregar dados salvos:', error);
              setSaveStatus('error');
              return false;
            }
          }, []);

          // ðŸŽ¯ NOVO: Event listeners para salvamento ao fechar
          useEffect(() => {
            const handleBeforeUnload = (e) => {
              autoSave(true); // Salvamento imediato
              // Opcional: mostrar aviso se hÃ¡ dados nÃ£o salvos
              if (saveStatus === 'saving') {
                e.preventDefault();
                e.returnValue = 'Dados sendo salvos...';
                return 'Dados sendo salvos...';
              }
            };

            const handleVisibilityChange = () => {
              if (document.visibilityState === 'hidden') {
                autoSave(true); // Salvamento imediato ao sair da aba
              }
            };

            const handleUnload = () => {
              autoSave(true); // Salvamento final
            };

            // Adicionar event listeners
            window.addEventListener('beforeunload', handleBeforeUnload);
            window.addEventListener('unload', handleUnload);
            document.addEventListener('visibilitychange', handleVisibilityChange);

            // Cleanup
            return () => {
              window.removeEventListener('beforeunload', handleBeforeUnload);
              window.removeEventListener('unload', handleUnload);
              document.removeEventListener('visibilitychange', handleVisibilityChange);
              
              // Salvamento final ao desmontar componente
              if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
              }
              autoSave(true);
            };
          }, [autoSave, saveStatus]);

          // ðŸŽ¯ NOVO: Auto-save em intervalos regulares
          useEffect(() => {
            if (!autoSaveEnabled) return;

            const interval = setInterval(() => {
              autoSave();
            }, 30000); // Auto-save a cada 30 segundos

            return () => clearInterval(interval);
          }, [autoSave, autoSaveEnabled]);

          // ðŸŽ¯ NOVO: Trigger auto-save quando dados importantes mudam
          useEffect(() => {
            autoSave();
          }, [monthlyHabits, habitData, snoozedHabits]);

          // ðŸŽ¯ INICIALIZAÃ‡ÃƒO: Carregar dados salvos
          useEffect(() => {
            loadSavedData();
          }, [loadSavedData]);

          const clearAllData = () => {
            try {
              setResetStatus('ðŸ”„ Limpando dados...');
              
              // Limpar localStorage
              Object.values(STORAGE_KEYS).forEach(key => {
                if (typeof localStorage !== 'undefined') {
                  localStorage.removeItem(key);
                } else {
                  delete window[key];
                }
              });
              
              setResetStatus('ðŸ“ Criando hÃ¡bitos padrÃ£o...');
              
              const currentKey = new Date().getFullYear() + '-' + new Date().getMonth();
              const defaultHabits = {
                [currentKey]: [
                  { id: Date.now() + Math.random() * 1000, name: 'Ãgua 2L ðŸ’§', priority: 'high', observations: ['', '', ''], daysType: 'all', color: null, streak: 0, bestStreak: 0, scheduleTime: '08:30', notificationPreference: 'onTime', lastNotified: null },
                  { id: Date.now() + Math.random() * 1000 + 1000, name: 'ExercÃ­cio ðŸƒâ€â™‚ï¸', priority: 'medium', observations: ['', '', ''], daysType: 'weekdays', color: null, streak: 0, bestStreak: 0, scheduleTime: '07:00', notificationPreference: 'onTime', lastNotified: null },
                  { id: Date.now() + Math.random() * 1000 + 2000, name: 'Leitura ðŸ“š', priority: 'low', observations: ['', '', ''], daysType: 'all', color: null, streak: 0, bestStreak: 0, scheduleTime: null, notificationPreference: 'disabled', lastNotified: null }
                ]
              };
              
              setResetStatus('ðŸ”„ Resetando interface...');
              
              setHabitData({});
              setMonthlyHabits(defaultHabits);
              setPriorityFilter('all');
              setSearchTerm('');
              setSelectedHabitId(null);
              setExpandedHabitDetails(null);
              setFocusedDay(null);
              setRotationAngle(0);
              setShowStats(false);
              setShowAddForm(false);
              setSnoozedHabits({});
              setOverdueCount(0);
              setSelectedScheduleTime('');
              setSelectedNotificationPref('onTime');
              setOverdueNotificationClosed(false);
              setEditingHabitId(null);
              setEditForm({ name: '', priority: '', daysType: '' });
              
              // Reset timeline data
              timelineDataRef.current = {
                todayHabits: [],
                completionSnapshot: {},
                isCurrentMonth: false,
                currentHour: 0,
                lastUpdate: 0
              };
              setTimelineForceUpdate(0);
              
              // Reset timeline states
              timelineInitialScrollDoneRef.current = false;
              timelineUserInteractedRef.current = false;
              savedScrollPositionRef.current = 0;
              timelineVersionRef.current = 0;
              
              // ðŸŽ¯ NOVO: Salvar dados padrÃ£o
              saveToPersistentStorage(STORAGE_KEYS.monthlyHabits, defaultHabits);
              saveToPersistentStorage(STORAGE_KEYS.habitData, {});
              saveToPersistentStorage(STORAGE_KEYS.snoozedHabits, {});
              saveToPersistentStorage(STORAGE_KEYS.overdueNotificationClosed, false);
              
              setResetStatus('âœ… Reset completo realizado!');
              setSaveStatus('saved');
              setLastSaveTime(Date.now());
              
              setTimeout(() => {
                setResetStatus('');
              }, 3000);
              
            } catch (error) {
              setResetStatus('âŒ Erro no reset - recarregando...');
              setTimeout(() => {
                window.location.reload();
              }, 1000);
            }
          };

          const renderTextWithLinks = (text) => {
            if (!text) return '';
            
            const urlRegex = /(https?:\/\/[^\s]+|www\.[^\s]+)/g;
            const parts = text.split(urlRegex);
            
            return parts.map((part, index) => {
              if (urlRegex.test(part)) {
                const href = part.startsWith('www.') ? `https://${part}` : part;
                return (
                  <a 
                    key={index} 
                    href={href} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-blue-400 hover:text-blue-300 underline transition-colors"
                  >
                    {part}
                  </a>
                );
              }
              return part;
            });
          };

          const updateHabitObservation = (habitId, observationIndex, newValue) => {
            const monthKey = getCurrentMonthKey();
            const newHabits = {
              ...monthlyHabits,
              [monthKey]: (monthlyHabits[monthKey] || []).map(habit => 
                habit.id === habitId 
                  ? { 
                      ...habit, 
                      observations: habit.observations.map((obs, idx) => 
                        idx === observationIndex ? newValue : obs
                      )
                    }
                  : habit
              )
            };
            
            setMonthlyHabits(newHabits);
            // Auto-save serÃ¡ chamado pelo useEffect
          };

          const parseScheduleTime = (scheduleTime) => {
            if (!scheduleTime) return null;
            
            const periodTimes = {
              'morning': { start: 6, end: 12 },
              'afternoon': { start: 12, end: 18 }, 
              'evening': { start: 18, end: 23 }
            };
            
            if (periodTimes[scheduleTime]) {
              return periodTimes[scheduleTime];
            }
            
            const [hours, minutes] = scheduleTime.split(':').map(Number);
            if (!isNaN(hours) && !isNaN(minutes)) {
              return { hours, minutes };
            }
            
            return null;
          };

          const getCurrentMonthKey = () => currentYear + '-' + currentMonth;

          const getHabitTimeStatus = (habit, day) => {
            if (!habit || habit.priority === 'low' || !habit.scheduleTime) return 'no-schedule';
            
            const today = new Date();
            const isToday = day === today.getDate() && 
                           currentMonth === today.getMonth() && 
                           currentYear === today.getFullYear();
            
            if (!isToday) return 'future';
            
            const isCompleted = isHabitCompleted(habit.id, day);
            if (isCompleted) return 'completed';
            
            const habitKey = `${habit.id}-${today.toDateString()}`;
            const snoozedUntil = snoozedHabits[habitKey];
            if (snoozedUntil && new Date(snoozedUntil) > currentTime) {
              return 'snoozed';
            }
            
            const scheduleInfo = parseScheduleTime(habit.scheduleTime);
            if (!scheduleInfo) return 'no-schedule';
            
            const now = currentTime;
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            if (scheduleInfo.start !== undefined) {
              if (currentHour < scheduleInfo.start) return 'future';
              if (currentHour >= scheduleInfo.end) return 'overdue';
              if (currentHour >= scheduleInfo.end - 1) return 'due-soon';
              return 'due-now';
            } else if (scheduleInfo.hours !== undefined && scheduleInfo.minutes !== undefined) {
              const scheduledMinutes = scheduleInfo.hours * 60 + scheduleInfo.minutes;
              const currentMinutes = currentHour * 60 + currentMinute;
              const diffMinutes = currentMinutes - scheduledMinutes;
              
              if (diffMinutes < -60) return 'future';
              if (diffMinutes >= -15 && diffMinutes <= 15) return 'due-now';
              if (diffMinutes > 15) return 'overdue';
              if (diffMinutes >= -60) return 'due-soon';
              return 'future';
            }
            
            return 'no-schedule';
          };

          const getTimeStatusColor = (status) => {
            switch (status) {
              case 'completed': return '#10B981';
              case 'due-now': return '#3B82F6';
              case 'due-soon': return '#F59E0B';
              case 'overdue': return '#EF4444';
              case 'snoozed': return '#8B5CF6';
              case 'future': return '#6B7280';
              default: return null;
            }
          };

          const snoozeHabit = (habitId, minutes) => {
            const snoozeUntil = new Date(currentTime.getTime() + minutes * 60000);
            const habitKey = `${habitId}-${new Date().toDateString()}`;
            const newSnoozedHabits = {
              ...snoozedHabits,
              [habitKey]: snoozeUntil.getTime()
            };
            setSnoozedHabits(newSnoozedHabits);
            // Auto-save serÃ¡ chamado pelo useEffect
          };

          const shouldShowLosangeForDay = (habit, day) => {
            const dayOfWeek = new Date(currentYear, currentMonth, day).getDay();
            return habit.daysType === 'all' || (habit.daysType === 'weekdays' && dayOfWeek >= 1 && dayOfWeek <= 5) || (habit.daysType === 'weekends' && (dayOfWeek === 0 || dayOfWeek === 6));
          };

          // FunÃ§Ã£o para atualizar dados da timeline apenas quando necessÃ¡rio
          const updateTimelineData = useCallback(() => {
            const currentHabits = monthlyHabits[getCurrentMonthKey()] || [];
            const realToday = new Date();
            
            const todayHabits = currentHabits.filter(habit => 
              shouldShowLosangeForDay(habit, realToday.getDate())
            );
            
            const completionSnapshot = {};
            todayHabits.forEach(habit => {
              completionSnapshot[habit.id] = isHabitCompleted(habit.id, realToday.getDate());
            });
            
            const newData = {
              todayHabits,
              completionSnapshot,
              isCurrentMonth: realToday.getMonth() === currentMonth && realToday.getFullYear() === currentYear,
              currentHour: currentTime.getHours(),
              lastUpdate: Date.now()
            };
            
            // SÃ³ atualizar se realmente mudou algo importante
            const oldData = timelineDataRef.current;
            const shouldUpdate = (
              oldData.todayHabits.length !== newData.todayHabits.length ||
              oldData.isCurrentMonth !== newData.isCurrentMonth ||
              oldData.currentHour !== newData.currentHour ||
              JSON.stringify(oldData.completionSnapshot) !== JSON.stringify(newData.completionSnapshot)
            );
            
            if (shouldUpdate) {
              timelineDataRef.current = newData;
              setTimelineForceUpdate(prev => prev + 1);
            }
          }, [monthlyHabits, currentMonth, currentYear, currentTime.getHours(), habitData]);

          // Atualizar dados da timeline quando necessÃ¡rio
          useEffect(() => {
            updateTimelineData();
          }, [updateTimelineData]);

          // ForÃ§ar atualizaÃ§Ã£o quando versÃ£o da timeline muda (add/remove hÃ¡bitos) - mas com throttle
          useEffect(() => {
            const timeoutId = setTimeout(() => {
              updateTimelineData();
            }, 100); // Pequeno delay para evitar mÃºltiplas atualizaÃ§Ãµes seguidas
            
            return () => clearTimeout(timeoutId);
          }, [timelineVersionRef.current]);

          // FunÃ§Ã£o toggleHabitDay memoizada para nÃ£o causar re-renders na Timeline
          const toggleHabitDay = useCallback((habitId, day) => {
            const key = habitId + '-' + currentYear + '-' + currentMonth + '-' + day;
            setHabitData(prevData => {
              const newData = { ...prevData, [key]: !prevData[key] };
              
              // Atualizar timeline data se o dia sendo alterado Ã© hoje
              const today = new Date();
              const isToday = day === today.getDate() && 
                             currentMonth === today.getMonth() && 
                             currentYear === today.getFullYear();
              
              if (isToday) {
                // Atualizar snapshot local
                timelineDataRef.current = {
                  ...timelineDataRef.current,
                  completionSnapshot: {
                    ...timelineDataRef.current.completionSnapshot,
                    [habitId]: !prevData[key]
                  }
                };
                setTimelineForceUpdate(prev => prev + 1);
              }
              
              return newData;
            });
          }, [currentYear, currentMonth]);

          const isHabitCompleted = useCallback((habitId, day) => {
            return habitData[habitId + '-' + currentYear + '-' + currentMonth + '-' + day] || false;
          }, [habitData, currentYear, currentMonth]);

          useEffect(() => {
            if (selectedPriority === 'low') {
              setSelectedScheduleTime('');
              setSelectedNotificationPref('disabled');
            } else if (selectedNotificationPref === 'disabled' && selectedPriority !== 'low') {
              setSelectedNotificationPref('onTime');
            }
          }, [selectedPriority, selectedNotificationPref]);

          useEffect(() => {
            const updateTime = () => {
              const newTime = new Date();
              setCurrentTime(newTime);
              
              const today = newTime;
              let overdue = 0;
              
              const currentHabits = monthlyHabits[getCurrentMonthKey()] || [];
              currentHabits.forEach(habit => {
                if (habit.priority !== 'low' && habit.scheduleTime) {
                  const status = getHabitTimeStatus(habit, today.getDate());
                  if (status === 'overdue') overdue++;
                }
              });
              
              setOverdueCount(overdue);
              
              if (overdue === 0 && overdueNotificationClosed) {
                setOverdueNotificationClosed(false);
              }
            };
            
            updateTime();
            const interval = setInterval(updateTime, 60000);
            
            return () => clearInterval(interval);
          }, [monthlyHabits, currentMonth, currentYear, snoozedHabits, habitData, overdueNotificationClosed]);

          const autoColors = [
            { base: '#FF0000', light: '#FF6B6B', dark: '#CC0000' },
            { base: '#00AA00', light: '#66DD66', dark: '#008800' },
            { base: '#0066FF', light: '#66AAFF', dark: '#0044CC' },
            { base: '#FFAA00', light: '#FFCC66', dark: '#DD8800' },
            { base: '#AA00AA', light: '#DD66DD', dark: '#880088' },
            { base: '#00AAAA', light: '#66DDDD', dark: '#008888' },
            { base: '#FF6600', light: '#FF9966', dark: '#CC4400' },
            { base: '#6600FF', light: '#9966FF', dark: '#4400CC' }
          ];

          const priorities = [
            { value: 'low', label: 'Baixa', flag: 'ðŸ³ï¸', color: '#9CA3AF' },
            { value: 'medium', label: 'MÃ©dia', flag: 'ðŸŸ¡', color: '#F59E0B' },
            { value: 'high', label: 'Alta', flag: 'ðŸš©', color: '#EF4444' }
          ];

          const daysTypes = [
            { value: 'all', label: 'Todos os dias', icon: 'ðŸ“…', description: 'Segunda a domingo' },
            { value: 'weekdays', label: 'Apenas dias Ãºteis', icon: 'ðŸ’¼', description: 'Segunda a sexta-feira' },
            { value: 'weekends', label: 'Apenas fins de semana', icon: 'ðŸ–ï¸', description: 'SÃ¡bado e domingo' }
          ];
          
          const monthNames = ['Janeiro', 'Fevereiro', 'MarÃ§o', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];

          const allHabits = monthlyHabits[getCurrentMonthKey()] || [];
          const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
          
          let filteredHabits = allHabits.filter(habit => 
            habit.name.toLowerCase().includes(searchTerm.toLowerCase()) && 
            (priorityFilter === 'all' || habit.priority === priorityFilter)
          );
          
          if (selectedHabitId) {
            filteredHabits = filteredHabits.filter(habit => habit.id === selectedHabitId);
          }

          const getDailyProgress = (day) => {
            const applicableHabits = filteredHabits.filter(habit => shouldShowLosangeForDay(habit, day));
            if (applicableHabits.length === 0) return 0;
            const completed = applicableHabits.filter(habit => isHabitCompleted(habit.id, day)).length;
            return (completed / applicableHabits.length) * 100;
          };

          const getCompletionPercentage = (habitId) => {
            const habit = allHabits.find(h => h.id === habitId);
            if (!habit) return 0;
            let completed = 0, applicable = 0;
            for (let day = 1; day <= daysInMonth; day++) {
              if (shouldShowLosangeForDay(habit, day)) {
                applicable++;
                if (isHabitCompleted(habitId, day)) completed++;
              }
            }
            return applicable > 0 ? Math.round((completed / applicable) * 100) : 0;
          };

          const getMonthlyStats = () => {
            let totalPossible = 0, totalCompleted = 0;
            filteredHabits.forEach(habit => {
              for (let day = 1; day <= daysInMonth; day++) {
                if (shouldShowLosangeForDay(habit, day)) {
                  totalPossible++;
                  if (isHabitCompleted(habit.id, day)) totalCompleted++;
                }
              }
            });
            return {
              overall: totalPossible > 0 ? Math.round((totalCompleted / totalPossible) * 100) : 0,
              completed: totalCompleted,
              total: totalPossible
            };
          };

          const addNewHabit = () => {
            if (newHabit.trim()) {
              const monthKey = getCurrentMonthKey();
              const newHabits = {
                ...monthlyHabits,
                [monthKey]: [...(monthlyHabits[monthKey] || []), {
                  id: Date.now(),
                  name: newHabit.trim(),
                  priority: selectedPriority,
                  daysType: selectedDaysType,
                  observations: ['', '', ''],
                  streak: 0,
                  bestStreak: 0,
                  scheduleTime: selectedPriority === 'low' ? null : selectedScheduleTime || null,
                  notificationPreference: selectedPriority === 'low' ? 'disabled' : selectedNotificationPref,
                  lastNotified: null
                }]
              };
              
              setMonthlyHabits(newHabits);
              
              // Incrementar versÃ£o da Timeline para forÃ§ar recriaÃ§Ã£o com novos hÃ¡bitos
              timelineVersionRef.current += 1;
              updateTimelineData();
              
              setSelectedHabitId(null);
              setPriorityFilter('all');
              setSearchTerm('');
              setEditingHabitId(null);
              setEditForm({ name: '', priority: '', daysType: '' });
              
              setNewHabit('');
              setSelectedPriority('medium');
              setSelectedDaysType('all');
              setSelectedScheduleTime('');
              setSelectedNotificationPref('onTime');
              setShowAddForm(false);
            }
          };

          const deleteHabit = (habitId) => {
            const monthKey = getCurrentMonthKey();
            const newHabits = {
              ...monthlyHabits,
              [monthKey]: (monthlyHabits[monthKey] || []).filter(h => h.id !== habitId)
            };
            
            setMonthlyHabits(newHabits);
            
            // Incrementar versÃ£o da Timeline para forÃ§ar recriaÃ§Ã£o
            timelineVersionRef.current += 1;
            updateTimelineData();
          };

          const startEditingHabit = (habit) => {
            setEditingHabitId(habit.id);
            setEditForm({
              name: habit.name,
              priority: habit.priority,
              daysType: habit.daysType
            });
          };

          const saveHabitEdit = () => {
            if (!editForm.name.trim()) return;
            
            const monthKey = getCurrentMonthKey();
            const newHabits = {
              ...monthlyHabits,
              [monthKey]: (monthlyHabits[monthKey] || []).map(habit => 
                habit.id === editingHabitId 
                  ? { 
                      ...habit, 
                      name: editForm.name.trim(),
                      priority: editForm.priority,
                      daysType: editForm.daysType,
                      // Atualizar configuraÃ§Ãµes baseadas na prioridade
                      scheduleTime: editForm.priority === 'low' ? null : habit.scheduleTime,
                      notificationPreference: editForm.priority === 'low' ? 'disabled' : habit.notificationPreference
                    }
                  : habit
              )
            };
            
            setMonthlyHabits(newHabits);
            
            // Incrementar versÃ£o da Timeline para forÃ§ar recriaÃ§Ã£o
            timelineVersionRef.current += 1;
            updateTimelineData();
            
            setEditingHabitId(null);
            setEditForm({ name: '', priority: '', daysType: '' });
          };

          const cancelHabitEdit = () => {
            setEditingHabitId(null);
            setEditForm({ name: '', priority: '', daysType: '' });
          };

          const calculateStreak = useCallback((habitId) => {
            const today = new Date();
            const habit = allHabits.find(h => h.id === habitId);
            if (!habit) return { current: 0, best: 0 };

            let currentStreak = 0, bestStreak = 0, tempStreak = 0;
            for (let i = 0; i < 365; i++) {
              const checkDate = new Date(today);
              checkDate.setDate(today.getDate() - i);
              const [day, month, year] = [checkDate.getDate(), checkDate.getMonth(), checkDate.getFullYear()];
              
              if (shouldShowLosangeForDay(habit, day)) {
                const key = habitId + '-' + year + '-' + month + '-' + day;
                if (habitData[key]) {
                  tempStreak++;
                  if (i === 0) currentStreak = tempStreak;
                } else {
                  if (tempStreak > bestStreak) bestStreak = tempStreak;
                  tempStreak = 0;
                  if (i === 0) currentStreak = 0;
                }
              }
            }
            if (tempStreak > bestStreak) bestStreak = tempStreak;
            return { current: currentStreak, best: bestStreak };
          }, [habitData, allHabits]);

          const handleDayClick = (clickedDay) => {
            if (focusedDay === clickedDay) {
              setFocusedDay(null);
              setRotationAngle(0);
            } else {
              const anglePerDay = 270 / daysInMonth;
              const totalAngleUsed = (clickedDay - 1) * anglePerDay;
              let clickedDayAngle;
              if (totalAngleUsed < 90) clickedDayAngle = 270 + totalAngleUsed;
              else if (totalAngleUsed < 180) clickedDayAngle = (totalAngleUsed - 90);
              else clickedDayAngle = 90 + (totalAngleUsed - 180);
              setFocusedDay(clickedDay);
              setRotationAngle(270 - clickedDayAngle);
            }
          };

          const handleCalendarClick = (e) => {
            if (focusedDay !== null) {
              const svg = e.currentTarget;
              const rect = svg.getBoundingClientRect();
              const svgRect = svg.viewBox.baseVal;
              const x = (e.clientX - rect.left) * (svgRect.width / rect.width);
              const y = (e.clientY - rect.top) * (svgRect.height / rect.height);
              const { svgSize } = generateCircularCalendar();
              const distance = Math.sqrt(Math.pow(x - svgSize/2, 2) + Math.pow(y - svgSize/2, 2));
              if (distance > svgSize/2 - 50) {
                setFocusedDay(null);
                setRotationAngle(0);
              }
            }
          };

          // 2. âœ… TIMELINE COMPLETAMENTE ISOLADA
          const TimelineHorizontal = React.memo(() => {
            // Usar dados estÃ¡veis da ref
            const timelineData = timelineDataRef.current;
            const [localHoveredHabit, setLocalHoveredHabit] = useState(null);
            
            // ðŸŽ¯ SISTEMA DE SCROLL SIMPLIFICADO
            const [hasAutoScrolled, setHasAutoScrolled] = useState(false);
            const [userHasInteracted, setUserHasInteracted] = useState(false);
            const lastScrollPosition = useRef(0);
            
            const timeSlots = useMemo(() => {
              const slots = [];
              for (let hour = 0; hour <= 23; hour++) {
                slots.push({ hour, minute: 0, display: `${hour.toString().padStart(2, '0')}:00` });
                if (hour < 23) {
                  slots.push({ hour, minute: 30, display: `${hour.toString().padStart(2, '0')}:30` });
                }
              }
              return slots;
            }, []);

            // ðŸŽ¯ TOGGLE SIMPLIFICADO
            const toggleTimeline = useCallback(() => {
              const newState = !isTimelineExpanded;
              setIsTimelineExpanded(newState);
              
              // Reset quando fecha
              if (!newState) {
                setHasAutoScrolled(false);
                setUserHasInteracted(false);
                lastScrollPosition.current = 0;
              }
            }, []);

            // ðŸŽ¯ SCROLL PARA HORÃRIO ATUAL - SEMPRE FUNCIONA
            const scrollToCurrentTime = useCallback(() => {
              if (!timelineScrollRef.current || !timelineData.isCurrentMonth) return;
              
              const now = new Date();
              const currentHour = now.getHours();
              const currentMinute = now.getMinutes();
              
              // Encontrar slot mais prÃ³ximo do horÃ¡rio atual
              let targetSlotIndex = -1;
              for (let i = 0; i < timeSlots.length; i++) {
                const slot = timeSlots[i];
                if (slot.hour === currentHour) {
                  if (slot.minute === 0 && currentMinute < 30) {
                    targetSlotIndex = i;
                    break;
                  } else if (slot.minute === 30 && currentMinute >= 30) {
                    targetSlotIndex = i;
                    break;
                  }
                }
              }
              
              // Fallback para primeira ocorrÃªncia da hora
              if (targetSlotIndex === -1) {
                targetSlotIndex = timeSlots.findIndex(slot => slot.hour === currentHour);
              }
              
              if (targetSlotIndex >= 0) {
                const slotWidth = 68;
                const containerPadding = 16;
                const targetPosition = Math.max(0, containerPadding + (targetSlotIndex * slotWidth) - 200);
                
                timelineScrollRef.current.scrollTo({ 
                  left: targetPosition, 
                  behavior: hasAutoScrolled ? 'smooth' : 'auto' 
                });
                
                lastScrollPosition.current = targetPosition;
                setHasAutoScrolled(true);
              }
            }, [timeSlots, timelineData.isCurrentMonth, hasAutoScrolled]);

            // ðŸŽ¯ AUTO-SCROLL INICIAL - SEMPRE QUANDO ABRE
            useEffect(() => {
              if (isTimelineExpanded && !hasAutoScrolled && timelineData.isCurrentMonth) {
                // Pequeno delay para garantir que o DOM estÃ¡ pronto
                const timer = setTimeout(() => {
                  scrollToCurrentTime();
                }, 150);
                return () => clearTimeout(timer);
              }
            }, [isTimelineExpanded, hasAutoScrolled, scrollToCurrentTime, timelineData.isCurrentMonth]);

            // ðŸŽ¯ PRESERVAR POSIÃ‡ÃƒO DURANTE INTERAÃ‡Ã•ES
            const preserveScrollPosition = useCallback(() => {
              if (timelineScrollRef.current && userHasInteracted) {
                lastScrollPosition.current = timelineScrollRef.current.scrollLeft;
              }
            }, [userHasInteracted]);

            const restoreScrollPosition = useCallback(() => {
              if (timelineScrollRef.current && userHasInteracted && lastScrollPosition.current > 0) {
                timelineScrollRef.current.scrollLeft = lastScrollPosition.current;
              }
            }, [userHasInteracted]);

            // ðŸŽ¯ DETECTAR INTERAÃ‡ÃƒO DO USUÃRIO
            useEffect(() => {
              if (!timelineScrollRef.current) return;
              
              const markUserInteraction = () => {
                if (!userHasInteracted) {
                  setUserHasInteracted(true);
                }
                preserveScrollPosition();
              };
              
              const element = timelineScrollRef.current;
              const events = ['scroll', 'wheel', 'touchstart', 'mousedown'];
              
              events.forEach(event => {
                element.addEventListener(event, markUserInteraction, { passive: true });
              });
              
              return () => {
                if (element) {
                  events.forEach(event => {
                    element.removeEventListener(event, markUserInteraction);
                  });
                }
              };
            }, [preserveScrollPosition, userHasInteracted]);

            // ðŸŽ¯ RESTAURAR POSIÃ‡ÃƒO APÃ“S RE-RENDER
            useEffect(() => {
              if (isTimelineExpanded && userHasInteracted) {
                const timer = setTimeout(() => {
                  restoreScrollPosition();
                }, 50);
                return () => clearTimeout(timer);
              }
            }, [restoreScrollPosition, isTimelineExpanded, userHasInteracted]);

            // ðŸŽ¯ FUNÃ‡Ã•ES DE NAVEGAÃ‡ÃƒO
            const scrollTimeline = useCallback((direction) => {
              if (!timelineScrollRef.current) return;
              
              setUserHasInteracted(true);
              const scrollAmount = 200;
              const currentScroll = timelineScrollRef.current.scrollLeft;
              const newPosition = direction === 'left' 
                ? Math.max(0, currentScroll - scrollAmount)
                : currentScroll + scrollAmount;
              
              timelineScrollRef.current.scrollTo({ left: newPosition, behavior: 'smooth' });
              lastScrollPosition.current = newPosition;
            }, []);

            const scrollToTime = useCallback((targetHour) => {
              if (!timelineScrollRef.current) return;
              
              setUserHasInteracted(true);
              const targetSlotIndex = timeSlots.findIndex(slot => slot.hour === targetHour && slot.minute === 0);
              
              if (targetSlotIndex >= 0) {
                const slotWidth = 68;
                const containerPadding = 16;
                const targetPosition = Math.max(0, containerPadding + (targetSlotIndex * slotWidth) - 100);
                
                timelineScrollRef.current.scrollTo({ left: targetPosition, behavior: 'smooth' });
                lastScrollPosition.current = targetPosition;
              }
            }, [timeSlots]);

            const scrollToNow = useCallback(() => {
              setUserHasInteracted(true);
              scrollToCurrentTime();
            }, [scrollToCurrentTime]);

            // ðŸŽ¯ DADOS ORGANIZADOS POR HORÃRIO
            const habitsByTime = useMemo(() => {
              const byTime = {};
              timelineData.todayHabits.forEach(habit => {
                if (!habit.scheduleTime || habit.priority === 'low') return;
                
                const scheduleInfo = parseScheduleTime(habit.scheduleTime);
                if (!scheduleInfo) return;
                
                let targetHour, targetMinute;
                if (scheduleInfo.start !== undefined) {
                  targetHour = scheduleInfo.start;
                  targetMinute = 0;
                } else if (scheduleInfo.hours !== undefined) {
                  targetHour = scheduleInfo.hours;
                  targetMinute = scheduleInfo.minutes;
                  
                  if (targetMinute >= 45) {
                    targetHour = (targetHour + 1) % 24;
                    targetMinute = 0;
                  } else if (targetMinute >= 15) {
                    targetMinute = 30;
                  } else {
                    targetMinute = 0;
                  }
                }
                
                if (targetHour !== undefined && targetMinute !== undefined) {
                  const slotKey = `${targetHour}-${targetMinute}`;
                  if (!byTime[slotKey]) byTime[slotKey] = [];
                  byTime[slotKey].push(habit);
                }
              });
              return byTime;
            }, [timelineData.todayHabits]);

            // ðŸŽ¯ FUNÃ‡Ã•ES DE STATUS (usando snapshot estÃ¡vel)
            const getHabitStatus = useCallback((habit) => {
              const realToday = new Date();
              const status = getHabitTimeStatus(habit, realToday.getDate());
              const isCompleted = timelineData.completionSnapshot[habit.id];
              return isCompleted ? 'completed' : status;
            }, [timelineData.completionSnapshot]);

            const getStatusStyling = (status) => {
              switch (status) {
                case 'completed':
                  return { bg: 'bg-green-500/20 border-green-500/40', icon: 'âœ“', text: 'text-green-300' };
                case 'due-now':
                  return { bg: 'bg-blue-500/30 border-blue-500/60 animate-pulse', icon: 'â–¶ï¸', text: 'text-blue-200' };
                case 'overdue':
                  return { bg: 'bg-red-500/20 border-red-500/40', icon: 'âš ï¸', text: 'text-red-300' };
                case 'due-soon':
                  return { bg: 'bg-yellow-500/20 border-yellow-500/40 animate-pulse', icon: 'ðŸ””', text: 'text-yellow-300' };
                case 'snoozed':
                  return { bg: 'bg-purple-500/20 border-purple-500/40', icon: 'ðŸ˜´', text: 'text-purple-300' };
                default:
                  return { bg: 'bg-gray-600/20 border-gray-600/30 border-dashed', icon: 'â³', text: 'text-gray-400' };
              }
            };

            // ðŸŽ¯ TOGGLE ISOLADO - NÃƒO AFETA SCROLL
            const handleHabitToggle = useCallback((habitId, day) => {
              preserveScrollPosition(); // Salvar posiÃ§Ã£o ANTES
              
              // Atualizar habitData de forma isolada
              const key = habitId + '-' + currentYear + '-' + currentMonth + '-' + day;
              setHabitData(prevData => {
                const newData = { ...prevData, [key]: !prevData[key] };
                
                // Atualizar apenas o snapshot local da timeline
                const updatedSnapshot = { ...timelineDataRef.current.completionSnapshot };
                updatedSnapshot[habitId] = !prevData[key];
                timelineDataRef.current = {
                  ...timelineDataRef.current,
                  completionSnapshot: updatedSnapshot
                };
                
                return newData;
              });
              
              // ForÃ§ar apenas uma micro-atualizaÃ§Ã£o da timeline sem re-render completo
              setTimelineForceUpdate(prev => prev + 1);
              
            }, [preserveScrollPosition, currentYear, currentMonth]);

            const flexibleHabits = timelineData.todayHabits.filter(habit => 
              habit.priority === 'low' || !habit.scheduleTime
            );

            return (
              <div 
                className="bg-gradient-to-br from-gray-800/60 to-gray-900/80 backdrop-blur-xl rounded-3xl border border-gray-700/50 shadow-2xl overflow-hidden"
                onClick={(e) => e.stopPropagation()}
              >
                {/* HEADER */}
                <div 
                  className="relative bg-gradient-to-r from-blue-600/20 via-purple-600/20 to-cyan-600/20 p-4 border-b border-gray-700/50 cursor-pointer hover:from-blue-600/30 hover:via-purple-600/30 hover:to-cyan-600/30 transition-all duration-300"
                  onClick={toggleTimeline}
                >
                  <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 via-purple-500/10 to-cyan-500/10 animate-pulse"></div>
                  <div className="relative z-10">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <div className="bg-blue-500/20 p-2 rounded-lg border border-blue-500/30">
                          <Clock className="w-5 h-5 text-blue-400" />
                        </div>
                        <div>
                          <h3 className="text-lg font-bold text-white flex items-center gap-2">
                            Timeline do Dia
                            <div className={`transition-transform duration-200 ${isTimelineExpanded ? 'rotate-180' : 'rotate-0'}`}>
                              <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" className="text-blue-400">
                                <path d="M8 12L3 7h10l-5 5z"/>
                              </svg>
                            </div>
                          </h3>
                          <p className="text-blue-200 text-xs">
                            {new Date().toLocaleDateString('pt-BR', { 
                              weekday: 'long', 
                              day: 'numeric', 
                              month: 'long' 
                            })}
                          </p>
                        </div>
                      </div>
                      
                      <div className="flex items-center gap-2">
                        {timelineData.isCurrentMonth && (
                          <div className="bg-gray-900/50 backdrop-blur-sm px-3 py-1 rounded-lg border border-gray-600/50">
                            <div className="text-lg font-mono font-bold text-white">
                              {currentTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
                            </div>
                          </div>
                        )}
                        
                        <div className="flex items-center gap-4 text-xs bg-gray-800/30 backdrop-blur-sm rounded-full px-4 py-2 border border-gray-700/50">
                          {(() => {
                            const stats = {
                              overdue: timelineData.todayHabits.filter(h => getHabitStatus(h) === 'overdue').length,
                              upcoming: timelineData.todayHabits.filter(h => ['due-soon', 'due-now'].includes(getHabitStatus(h))).length,
                              completed: timelineData.todayHabits.filter(h => timelineData.completionSnapshot[h.id]).length
                            };
                            
                            return (
                              <>
                                {stats.overdue > 0 && (
                                  <span className="text-red-400 font-medium flex items-center gap-1">
                                    <span className="w-2 h-2 bg-red-400 rounded-full"></span>
                                    <span>{stats.overdue}</span>
                                  </span>
                                )}
                                {stats.upcoming > 0 && (
                                  <span className="text-yellow-400 font-medium flex items-center gap-1">
                                    <span className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></span>
                                    <span>{stats.upcoming}</span>
                                  </span>
                                )}
                                <span className="text-green-400 font-medium flex items-center gap-1">
                                  <span className="w-2 h-2 bg-green-400 rounded-full"></span>
                                  <span>{stats.completed}</span>
                                </span>
                                <span className="text-blue-400 font-medium flex items-center gap-1">
                                  <span className="w-2 h-2 bg-blue-400 rounded-full"></span>
                                  <span>{timelineData.todayHabits.length}</span>
                                </span>
                              </>
                            );
                          })()}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* CONTEÃšDO */}
                <div className={`transition-all duration-500 ease-in-out ${isTimelineExpanded ? 'max-h-[800px] opacity-100' : 'max-h-0 opacity-0'} overflow-hidden`}>
                  {timelineData.isCurrentMonth ? (
                    <div className="p-4 w-full">
                      {/* CONTROLES DE NAVEGAÃ‡ÃƒO */}
                      <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
                        <div className="flex items-center gap-4 flex-wrap">
                          <div className="flex items-center gap-1 bg-gray-800/50 rounded-lg p-1">
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                scrollToTime(6);
                              }}
                              className="px-2 py-1 text-xs bg-gray-700/50 hover:bg-gray-600/50 rounded text-gray-300 hover:text-white transition-colors"
                              title="Ir para ManhÃ£ (6h)"
                            >
                              ðŸŒ…
                            </button>
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                scrollToTime(12);
                              }}
                              className="px-2 py-1 text-xs bg-gray-700/50 hover:bg-gray-600/50 rounded text-gray-300 hover:text-white transition-colors"
                              title="Ir para Tarde (12h)"
                            >
                              â˜€ï¸
                            </button>
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                scrollToTime(18);
                              }}
                              className="px-2 py-1 text-xs bg-gray-700/50 hover:bg-gray-600/50 rounded text-gray-300 hover:text-white transition-colors"
                              title="Ir para Noite (18h)"
                            >
                              ðŸŒ™
                            </button>
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                scrollToNow();
                              }}
                              className="px-2 py-1 text-xs bg-blue-600/50 hover:bg-blue-500/50 rounded text-blue-200 hover:text-white transition-colors"
                              title="Ir para Agora"
                            >
                              â°
                            </button>
                          </div>
                          
                          {/* INDICADORES TEMPORAIS */}
                          <div className="bg-gray-800/30 backdrop-blur-sm rounded-lg px-3 py-2 border border-gray-700/50">
                            <h4 className="text-xs font-semibold text-blue-400 mb-1.5 flex items-center gap-1">
                              <Clock className="w-3 h-3" />
                              Status dos HÃ¡bitos
                            </h4>
                            <div className="grid grid-cols-2 lg:grid-cols-4 gap-2 text-xs text-gray-300">
                              <div className="flex items-center gap-1">
                                <span className="w-2 h-2 bg-blue-500 rounded-full animate-pulse flex-shrink-0"></span>
                                <span className="text-blue-300">Agora</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="w-2 h-2 bg-orange-500 rounded-full flex-shrink-0"></span>
                                <span className="text-orange-300">PrÃ³ximo</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="w-2 h-2 bg-red-500 rounded-full flex-shrink-0"></span>
                                <span className="text-red-300">Atrasado</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <span className="w-2 h-2 bg-green-500 rounded-full flex-shrink-0"></span>
                                <span className="text-green-300">Completo</span>
                              </div>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex items-center gap-2">
                          <button 
                            onClick={(e) => {
                              e.stopPropagation();
                              scrollTimeline('left');
                            }}
                            className="p-2 bg-gray-700/50 hover:bg-gray-600/50 rounded-lg transition-colors text-gray-300 hover:text-white"
                            title="Rolar para trÃ¡s"
                          >
                            â†
                          </button>
                          <button 
                            onClick={(e) => {
                              e.stopPropagation();
                              scrollTimeline('right');
                            }}
                            className="p-2 bg-gray-700/50 hover:bg-gray-600/50 rounded-lg transition-colors text-gray-300 hover:text-white"
                            title="Rolar para frente"
                          >
                            â†’
                          </button>
                        </div>
                      </div>

                      {/* TIMELINE PRINCIPAL */}
                      <div className="relative w-full overflow-hidden">
                        <div 
                          className="overflow-x-auto overflow-y-hidden rounded-2xl p-4"
                          ref={timelineScrollRef}
                          onScroll={preserveScrollPosition}
                          style={{ 
                            background: 'rgba(75, 85, 99, 0.1)',
                            maxWidth: '100%',
                            width: '100%',
                            WebkitOverflowScrolling: 'touch',
                            msOverflowStyle: 'none',
                            scrollbarWidth: 'thin'
                          }}
                        >
                          <div className="flex items-start relative px-2" style={{ width: `${timeSlots.length * 68}px`, minHeight: '200px', gap: '1px' }}>
                            {/* INDICADOR "AGORA" */}
                            {(() => {
                              const now = new Date();
                              const currentHour = now.getHours();
                              const currentMinute = now.getMinutes();
                              
                              let currentSlotIndex = -1;
                              for (let i = 0; i < timeSlots.length; i++) {
                                const slot = timeSlots[i];
                                if (slot.minute === 0 && slot.hour === currentHour && currentMinute < 30) {
                                  currentSlotIndex = i;
                                  break;
                                } else if (slot.minute === 30 && slot.hour === currentHour && currentMinute >= 30) {
                                  currentSlotIndex = i;
                                  break;
                                }
                              }
                              
                              if (currentSlotIndex >= 0) {
                                const leftPosition = currentSlotIndex * 68 + 34;
                                
                                return (
                                  <div 
                                    className="absolute top-2 bg-blue-500 text-white text-xs px-2 py-1 rounded-full font-bold z-20 whitespace-nowrap transform -translate-x-1/2 animate-pulse"
                                    style={{ left: `${leftPosition}px` }}
                                  >
                                    AGORA: {now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
                                  </div>
                                );
                              }
                              
                              return null;
                            })()}

                            {/* SLOTS DE HORÃRIO */}
                            {timeSlots.map((slot) => {
                              const isCurrentSlot = slot.hour === timelineData.currentHour && 
                                ((slot.minute === 0 && currentTime.getMinutes() < 30) || 
                                 (slot.minute === 30 && currentTime.getMinutes() >= 30));
                              const slotHabits = habitsByTime[`${slot.hour}-${slot.minute}`] || [];
                              const isMainHour = slot.minute === 0;
                              
                              return (
                                <div key={`${slot.hour}-${slot.minute}`} className="flex flex-col items-center flex-shrink-0" style={{ width: '68px' }}>
                                  <div className="flex flex-col items-center mb-4">
                                    <div className={`w-0.5 mb-2 transition-all duration-300 ${
                                      isCurrentSlot 
                                        ? 'bg-blue-400 shadow-blue-400/50 shadow-lg scale-110 h-10' 
                                        : isMainHour 
                                        ? 'bg-gray-500 h-8' 
                                        : 'bg-gray-600 h-6'
                                    }`} />
                                    <div className={`text-xs font-medium transition-all duration-300 whitespace-nowrap ${
                                      isCurrentSlot 
                                        ? 'text-blue-300 font-bold scale-110' 
                                        : isMainHour
                                        ? 'text-gray-300'
                                        : 'text-gray-500'
                                    }`}>
                                      {slot.display}
                                    </div>
                                    
                                    {slotHabits.length > 0 && (
                                      <div className="flex gap-1 mt-1">
                                        {Array.from({ length: Math.min(slotHabits.length, 3) }).map((_, i) => (
                                          <div 
                                            key={i} 
                                            className={`w-1 h-1 rounded-full ${
                                              isCurrentSlot ? 'bg-blue-400' : 'bg-gray-500'
                                            }`} 
                                          />
                                        ))}
                                        {slotHabits.length > 3 && (
                                          <span className="text-xs text-gray-500">+{slotHabits.length - 3}</span>
                                        )}
                                      </div>
                                    )}
                                  </div>
                                  
                                  {/* HÃBITOS DO SLOT */}
                                  <div className="space-y-2 w-full">
                                    {slotHabits.map((habit) => {
                                      const status = getHabitStatus(habit);
                                      const styling = getStatusStyling(status);
                                      const isCompleted = timelineData.completionSnapshot[habit.id];
                                      const isHovered = localHoveredHabit === habit.id;
                                      
                                      return (
                                        <div key={habit.id} className="relative">
                                          <div
                                            className={`backdrop-blur-sm rounded-lg border p-2 transition-all duration-300 cursor-pointer transform hover:scale-105 hover:z-20 ${styling.bg} ${
                                              isHovered ? 'scale-110 shadow-lg' : ''
                                            } text-xs w-full max-w-full overflow-hidden`}
                                            onMouseEnter={() => setLocalHoveredHabit(habit.id)}
                                            onMouseLeave={() => setLocalHoveredHabit(null)}
                                            onClick={(e) => {
                                              e.stopPropagation();
                                              handleHabitToggle(habit.id, new Date().getDate());
                                            }}
                                          >
                                            <div className="flex items-center gap-1 mb-1">
                                              <span className="text-xs flex-shrink-0">{styling.icon}</span>
                                              <span className={`font-medium text-xs truncate flex-1 ${styling.text}`}>
                                                {habit.name}
                                              </span>
                                              <span className="text-xs flex-shrink-0">
                                                {priorities.find(p => p.value === habit.priority)?.flag}
                                              </span>
                                            </div>
                                            
                                            <div className="flex items-center justify-between text-xs">
                                              <span className={`${styling.text} text-xs truncate max-w-full`}>
                                                â— {(() => {
                                                  const scheduleInfo = parseScheduleTime(habit.scheduleTime);
                                                  if (scheduleInfo?.hours !== undefined) {
                                                    return `${scheduleInfo.hours.toString().padStart(2, '0')}:${scheduleInfo.minutes.toString().padStart(2, '0')}`;
                                                  }
                                                  const periods = { 
                                                    morning: 'ManhÃ£', 
                                                    afternoon: 'Tarde', 
                                                    evening: 'Noite' 
                                                  };
                                                  return periods[habit.scheduleTime] || habit.scheduleTime;
                                                })()}
                                              </span>
                                              {isCompleted && (
                                                <span className="text-green-400 font-bold text-xs">âœ“</span>
                                              )}
                                            </div>
                                            
                                            {isHovered && (
                                              <div className="mt-2 pt-2 border-t border-current/20 space-y-1">
                                                <div className="flex gap-1 flex-wrap">
                                                  {!isCompleted && (
                                                    <button 
                                                      onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleHabitToggle(habit.id, new Date().getDate());
                                                      }}
                                                      className="bg-green-500/20 hover:bg-green-500/30 px-2 py-1 rounded text-xs text-green-300 transition-colors"
                                                    >
                                                      âœ“ Concluir
                                                    </button>
                                                  )}
                                                  {status === 'overdue' && !isCompleted && (
                                                    <>
                                                      <button 
                                                        onClick={(e) => {
                                                          e.stopPropagation();
                                                          snoozeHabit(habit.id, 15);
                                                        }}
                                                        className="bg-purple-500/20 hover:bg-purple-500/30 px-1 py-1 rounded text-xs text-purple-300 transition-colors"
                                                      >
                                                        ðŸ˜´ 15m
                                                      </button>
                                                      <button 
                                                        onClick={(e) => {
                                                          e.stopPropagation();
                                                          snoozeHabit(habit.id, 30);
                                                        }}
                                                        className="bg-purple-500/20 hover:bg-purple-500/30 px-1 py-1 rounded text-xs text-purple-300 transition-colors"
                                                      >
                                                        ðŸ˜´ 30m
                                                      </button>
                                                    </>
                                                  )}
                                                </div>
                                              </div>
                                            )}
                                          </div>
                                        </div>
                                      );
                                    })}
                                  </div>
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      </div>

                      {/* ATIVIDADES FLEXÃVEIS */}
                      {flexibleHabits.length > 0 && (
                        <div className="mt-6 space-y-3 w-full max-w-full overflow-hidden">
                          <div className="flex items-center gap-2 mb-3">
                            <Settings className="w-4 h-4 text-gray-400" />
                            <h4 className="text-sm font-bold text-white">Atividades FlexÃ­veis</h4>
                            <span className="text-xs text-gray-400">({flexibleHabits.length})</span>
                          </div>
                          
                          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 w-full max-w-full overflow-hidden">
                            {flexibleHabits.map(habit => {
                              const isCompleted = timelineData.completionSnapshot[habit.id];
                              
                              return (
                                <button
                                  key={habit.id}
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleHabitToggle(habit.id, new Date().getDate());
                                  }}
                                  className={`p-2 rounded-lg border transition-all duration-200 hover:scale-105 w-full max-w-full overflow-hidden ${
                                    isCompleted 
                                      ? 'bg-green-500/20 border-green-500/40 text-green-300' 
                                      : 'bg-gray-600/20 border-gray-600/40 text-gray-300 hover:border-green-500/40'
                                  }`}
                                >
                                  <div className="flex items-center gap-2 w-full max-w-full overflow-hidden">
                                    <span className="text-xs flex-shrink-0">{isCompleted ? 'âœ“' : 'â—‹'}</span>
                                    <span className="text-xs font-medium truncate flex-1">{habit.name}</span>
                                    <span className="text-xs flex-shrink-0">
                                      {priorities.find(p => p.value === habit.priority)?.flag}
                                    </span>
                                  </div>
                                </button>
                              );
                            })}
                          </div>
                        </div>
                      )}

                      <div className="mt-2 text-center w-full max-w-full overflow-hidden">
                        <div className="inline-flex items-center gap-2 text-xs text-gray-400 bg-gray-800/30 px-3 py-1 rounded-full max-w-full flex-wrap">
                          <span className="truncate flex-shrink-0">
                            ðŸ‘† Scroll horizontal para ver 24h completas
                          </span>
                          <span className="flex-shrink-0">â€¢</span>
                          <span className="font-mono truncate flex-shrink-0">{currentTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                      </div>

                      {timelineData.todayHabits.length === 0 && (
                        <div className="text-center py-8 w-full max-w-full overflow-hidden">
                          <Clock className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                          <h4 className="text-lg font-bold text-gray-300 mb-2">Nenhum hÃ¡bito para hoje</h4>
                          <p className="text-gray-500 text-sm">Adicione alguns hÃ¡bitos para comeÃ§ar sua jornada!</p>
                        </div>
                      )}
                    </div>
                  ) : (
                    <div className="p-4 text-center">
                      <div className="bg-gray-700/30 rounded-xl p-6 border border-gray-600">
                        <Calendar className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                        <h4 className="text-lg font-bold text-gray-300 mb-2">Timeline nÃ£o disponÃ­vel</h4>
                        <p className="text-gray-400 text-sm">
                          A timeline sÃ³ estÃ¡ disponÃ­vel para o mÃªs atual ({new Date().toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' })})
                        </p>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            );
          }, [timelineForceUpdate]); // ðŸ”’ SÃ“ RE-RENDERIZA quando forÃ§ado explicitamente

          TimelineHorizontal.displayName = 'TimelineHorizontal';

          const generateCircularCalendar = () => {
            const habitCount = filteredHabits.length;
            const innerRadius = compactMode ? 72 : 96;
            
            const baseRingWidth = (() => {
              if (habitCount === 0) return 0;
              if (compactMode) {
                if (habitCount === 1) return 30;
                if (habitCount <= 5) return Math.max(22, 36 - (habitCount * 2));
                if (habitCount <= 10) return Math.max(18, 30 - (habitCount * 1.5));
                return Math.max(14, 24 - (habitCount * 0.8));
              }
              if (habitCount === 1) return 42;
              if (habitCount <= 5) return Math.max(30, 48 - (habitCount * 2));
              if (habitCount <= 10) return Math.max(24, 42 - (habitCount * 1.5));
              if (habitCount <= 15) return Math.max(22, 36 - (habitCount * 1));
              if (habitCount <= 20) return Math.max(19, 30 - (habitCount * 0.8));
              return Math.max(17, 26 - (habitCount * 0.6));
            })();
            
            const getRingWidth = (habitIndex) => {
              if (habitCount === 1) return compactMode ? 42 : 56;
              
              if (compactMode) {
                if (habitCount > 15) return Math.max(14, baseRingWidth - (habitIndex * 0.4));
                if (habitCount > 10) return Math.max(17, baseRingWidth - (habitIndex * 1));
                return Math.max(18, baseRingWidth - (habitIndex * 1.4));
              }
              if (habitCount > 15) return Math.max(17, baseRingWidth - (habitIndex * 0.6));
              if (habitCount > 10) return Math.max(19, baseRingWidth - (habitIndex * 1.2));
              if (habitCount <= 4) return Math.max(26, baseRingWidth - (habitIndex * 2.4));
              return Math.max(22, baseRingWidth - (habitIndex * 1.8));
            };
            
            const dayCircleRadius = compactMode ? Math.max(14, (12 + Math.floor(habitCount / 4))) : Math.max(19, (17 + Math.floor(habitCount / 4)));
            
            const getScaledCellSize = (habitIndex) => {
              const base = compactMode ? (habitCount > 20 ? 14.4 : habitCount > 15 ? 16.8 : habitCount > 10 ? 20.4 : 16.8) : (habitCount > 20 ? 20.4 : habitCount > 15 ? 22.8 : habitCount > 10 ? 26.4 : 22.8);
              if (habitCount === 1) return compactMode ? 22.8 : 28.8;
              if (habitIndex === 0) return habitCount > 20 ? (compactMode ? 16.8 : 22.8) : habitCount > 15 ? (compactMode ? 20.4 : 26.4) : habitCount > 10 ? (compactMode ? 22.8 : 28.8) : base * 1.2;
              if (habitIndex >= 4) return compactMode ? 12 : 16.8;
              const maxSize = base * 1.2, minSize = compactMode ? 12 : 16.8;
              return Math.round(maxSize - ((maxSize - minSize) * Math.pow(habitIndex / 4, habitCount > 15 ? 2 : 1.5)));
            };
            
            let currentRadius = innerRadius;
            const ringPositions = [];
            if (habitCount > 0) {
              for (let i = filteredHabits.length - 1; i >= 0; i--) {
                const ringWidth = getRingWidth(i);
                currentRadius += ringWidth;
                const adjustedRadius = habitCount === 1 ? currentRadius * 1.25 : currentRadius;
                ringPositions[i] = adjustedRadius - (ringWidth / 2);
              }
            }
            
            const daySpacing = compactMode ? (habitCount > 6 ? 18 : 12) : (habitCount > 6 ? 30 : 18);
            let dayRadius = currentRadius + dayCircleRadius + (habitCount === 0 ? 48 : daySpacing);
            
            if (habitCount === 1) {
              dayRadius = dayRadius * 1.25;
            }
            
            const svgSize = compactMode ? Math.max(600, dayRadius * 2 + 96) : Math.max(720, dayRadius * 2 + 120);
            const centerX = svgSize / 2, centerY = svgSize / 2;
            const anglePerDay = 270 / daysInMonth;

            const getDayAngle = (day) => {
              const totalAngleUsed = (day - 1) * anglePerDay;
              return totalAngleUsed < 90 ? 270 + totalAngleUsed : totalAngleUsed < 180 ? totalAngleUsed - 90 : 90 + (totalAngleUsed - 180);
            };

            const fixedElements = [], rotatingElements = [];

            fixedElements.push(
              <g key="center" style={{ cursor: 'pointer' }} onClick={() => setShowAddForm(!showAddForm)}>
                <defs>
                  <radialGradient id="centerGradient" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" stopColor={showAddForm ? "rgba(34, 197, 94, 0.3)" : "rgba(0,0,0,0.9)"} />
                    <stop offset="100%" stopColor={showAddForm ? "rgba(34, 197, 94, 0.1)" : "rgba(0,0,0,0.7)"} />
                  </radialGradient>
                </defs>
                <circle cx={centerX} cy={centerY} r={innerRadius - 10} fill="url(#centerGradient)" stroke={showAddForm ? "#22C55E" : "rgba(255,255,255,0.3)"} strokeWidth="3" className={animations ? "transition-all duration-300" : ""} filter="drop-shadow(0 4px 8px rgba(0,0,0,0.3))" />
                <line x1={centerX - 15} y1={centerY} x2={centerX + 15} y2={centerY} stroke={showAddForm ? "#22C55E" : "#ffffff"} strokeWidth="3" strokeLinecap="round" className={animations ? "transition-colors duration-200" : ""} />
                <line x1={centerX} y1={centerY - 15} x2={centerX} y2={centerY + 15} stroke={showAddForm ? "#22C55E" : "#ffffff"} strokeWidth="3" strokeLinecap="round" className={animations ? "transition-colors duration-200" : ""} />
                <text x={centerX} y={centerY + 34} textAnchor="middle" className="font-bold" fill={showAddForm ? "#22C55E" : "#ffffff"} style={{ fontSize: '12px', fontFamily: 'Inter, sans-serif' }}>
                  {showAddForm ? 'Fechar' : 'Adicionar'}
                </text>
              </g>
            );

            const labelAngle = 270 - (anglePerDay * 1.2);
            const labelRadian = (labelAngle * Math.PI) / 180;
            const labelX = centerX + dayRadius * Math.cos(labelRadian);
            const labelY = centerY + dayRadius * Math.sin(labelRadian);
            
            fixedElements.push(
              <g key="day-label">
                <defs>
                  <radialGradient id="dayLabelGradient" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" stopColor="rgba(59, 130, 246, 0.2)" />
                    <stop offset="100%" stopColor="rgba(59, 130, 246, 0.05)" />
                  </radialGradient>
                </defs>
                <circle cx={labelX} cy={labelY} r={dayCircleRadius} fill="url(#dayLabelGradient)" stroke="#3B82F6" strokeWidth="2" strokeDasharray="3,3" filter="drop-shadow(0 2px 4px rgba(59, 130, 246, 0.3))" />
                <text x={labelX} y={labelY + 3} textAnchor="middle" className="font-bold fill-blue-400" style={{ fontSize: `${Math.max(12, dayCircleRadius * 0.6)}px` }}>DIA</text>
              </g>
            );

            const nonHoveredHabits = filteredHabits.filter((_, index) => hoveredHabit !== filteredHabits[index].id);
            const hoveredHabitData = filteredHabits.find(habit => habit.id === hoveredHabit);
            
            nonHoveredHabits.forEach((habit) => {
              const habitIndex = filteredHabits.findIndex(h => h.id === habit.id);
              const radius = ringPositions[habitIndex];
              const segmentY = centerY + radius * Math.sin((270 * Math.PI) / 180);
              
              const isSelected = selectedHabitId === habit.id;
              const baseFontSize = isSelected ? 16 : 12;
              const flagSize = isSelected ? 20 : 16;
              const textLength = habit.name.length;
              const streaks = calculateStreak(habit.id);
              const hasStreakInfo = showStreaks && (streaks.current > 0 || streaks.best > 3);
              
              const baseWidth = Math.max(200, textLength * (baseFontSize * 0.6));
              const streakWidth = hasStreakInfo ? 40 : 0;
              const labelWidth = Math.min(350, baseWidth + streakWidth + 80);
              const labelHeight = Math.max(19, baseFontSize + 10);
              
              const safeDistance = compactMode ? (habitCount > 6 ? 36 : 30) : (habitCount > 6 ? 48 : 36);
              const labelX = centerX - labelWidth - safeDistance;
              const circleX = labelX + labelWidth - 24;
              const textEndX = circleX - 36;

              fixedElements.push(
                <g key={`habit-label-${habit.id}`} 
                   onMouseEnter={() => setHoveredHabit(habit.id)} 
                   onMouseLeave={() => setHoveredHabit(null)}
                   onClick={() => setSelectedHabitId(selectedHabitId === habit.id ? null : habit.id)}
                   style={{ 
                     transform: isSelected ? 'scale(1.1)' : 'scale(1)', 
                     transition: animations ? 'all 0.3s ease' : 'none', 
                     transformOrigin: `${labelX + labelWidth/2}px ${segmentY}px`,
                     cursor: 'pointer'
                   }}>
                  <defs>
                    <linearGradient id={`gradient-${habit.id}`} x1="0%" y1="0%" x2="100%" y2="0%">
                      <stop offset="0%" stopColor={isSelected ? "rgba(59, 130, 246, 0.95)" : "rgba(0,0,0,0.95)"} />
                      <stop offset="100%" stopColor={isSelected ? "rgba(59, 130, 246, 0.85)" : "rgba(0,0,0,0.85)"} />
                    </linearGradient>
                  </defs>
                  <rect x={labelX} y={segmentY - (labelHeight/2)} width={labelWidth} height={labelHeight} rx={14} 
                        fill={`url(#gradient-${habit.id})`} 
                        stroke={isSelected ? "#3B82F6" : autoColors[habitIndex % autoColors.length].base} 
                        strokeWidth={isSelected ? "3" : "2"} 
                        filter={isSelected ? "drop-shadow(0 0 12px rgba(59, 130, 246, 0.4))" : "drop-shadow(2px 2px 4px rgba(0,0,0,0.3))"} />
                  <text x={labelX + 18} y={segmentY + 2} textAnchor="middle" className="text-sm" style={{ fontSize: `${flagSize}px` }}>
                    {priorities.find(p => p.value === habit.priority).flag}
                  </text>
                  <text x={textEndX} y={segmentY + 2} textAnchor="end" className="font-semibold" style={{ fontFamily: 'Arial, sans-serif', fontSize: `${baseFontSize}px`, fill: '#ffffff' }}>
                    {habit.name}
                  </text>
                  {showStreaks && streaks.current > 0 && (
                    <text x={textEndX + 40} y={segmentY + 2} textAnchor="end" style={{ fontSize: isSelected ? '12px' : '10px', fill: '#10B981', fontWeight: isSelected ? 'bold' : 'normal' }}>
                      ðŸ”¥{streaks.current}
                    </text>
                  )}
                  <circle cx={circleX} cy={segmentY} r={10} fill={autoColors[habitIndex % autoColors.length].base} stroke={isSelected ? "#3B82F6" : "#fff"} strokeWidth={isSelected ? "3" : "2"} />
                  <text x={circleX} y={segmentY + 4} textAnchor="middle" className="text-xs font-bold" style={{ fontFamily: 'Arial, sans-serif', fill: '#ffffff', fontSize: isSelected ? '12px' : '10px' }}>
                    {habitIndex + 1}
                  </text>
                </g>
              );
              fixedElements.push(<circle key={`ring-bg-${habit.id}`} cx={centerX} cy={centerY} r={radius} fill="none" stroke={isSelected ? "rgba(59, 130, 246, 0.3)" : "rgba(255,255,255,0.1)"} strokeWidth={isSelected ? "2" : "1"} />);
            });

            if (hoveredHabitData) {
              const habitIndex = filteredHabits.findIndex(h => h.id === hoveredHabitData.id);
              const radius = ringPositions[habitIndex];
              const segmentY = centerY + radius * Math.sin((270 * Math.PI) / 180);
              
              const isSelected = selectedHabitId === hoveredHabitData.id;
              const baseFontSize = isSelected ? 20 : 18;
              const flagSize = isSelected ? 28 : 24;
              const textLength = hoveredHabitData.name.length;
              const streaks = calculateStreak(hoveredHabitData.id);
              const hasStreakInfo = showStreaks && (streaks.current > 0 || streaks.best > 3);
              
              const baseWidth = Math.max(200, textLength * (baseFontSize * 0.6));
              const streakWidth = hasStreakInfo ? 40 : 0;
              const labelWidth = Math.min(350, baseWidth + streakWidth + 80);
              const labelHeight = Math.max(19, baseFontSize + 10);
              
              const safeDistance = compactMode ? (habitCount > 6 ? 36 : 30) : (habitCount > 6 ? 48 : 36);
              const labelX = centerX - labelWidth - safeDistance;
              const circleX = labelX + labelWidth - 24;
              const textEndX = circleX - 36;

              fixedElements.push(
                <g key={`habit-label-hovered-${hoveredHabitData.id}`} 
                   onMouseEnter={() => setHoveredHabit(hoveredHabitData.id)} 
                   onMouseLeave={() => setHoveredHabit(null)}
                   onClick={() => setSelectedHabitId(selectedHabitId === hoveredHabitData.id ? null : hoveredHabitData.id)}
                   style={{ 
                     transform: 'scale(1.15)', 
                     transition: animations ? 'all 0.3s ease' : 'none', 
                     transformOrigin: `${labelX + labelWidth/2}px ${segmentY}px`, 
                     zIndex: 1000,
                     cursor: 'pointer'
                   }}>
                  <defs>
                    <linearGradient id={`gradient-hovered-${hoveredHabitData.id}`} x1="0%" y1="0%" x2="100%" y2="0%">
                      <stop offset="0%" stopColor={isSelected ? "rgba(59, 130, 246, 0.98)" : "rgba(0,0,0,0.98)"} />
                      <stop offset="100%" stopColor={isSelected ? "rgba(59, 130, 246, 0.92)" : "rgba(0,0,0,0.92)"} />
                    </linearGradient>
                  </defs>
                  <rect x={labelX} y={segmentY - (labelHeight/2)} width={labelWidth} height={labelHeight} rx={14} 
                        fill={`url(#gradient-hovered-${hoveredHabitData.id})`} 
                        stroke={isSelected ? "#3B82F6" : autoColors[habitIndex % autoColors.length].base} 
                        strokeWidth="3" 
                        filter={isSelected ? "drop-shadow(0 0 15px rgba(59, 130, 246, 0.6))" : "drop-shadow(4px 4px 12px rgba(0,0,0,0.5))"} />
                  <text x={labelX + 18} y={segmentY + 2} textAnchor="middle" className="text-sm" style={{ fontSize: `${flagSize}px` }}>
                    {priorities.find(p => p.value === hoveredHabitData.priority).flag}
                  </text>
                  <text x={textEndX} y={segmentY + 2} textAnchor="end" className="font-semibold" style={{ fontFamily: 'Arial, sans-serif', fontSize: `${baseFontSize}px`, fill: '#ffffff' }}>
                    {hoveredHabitData.name}
                  </text>
                  {showStreaks && streaks.current > 0 && (
                    <text x={textEndX + 40} y={segmentY + 2} textAnchor="end" style={{ fontSize: '12px', fill: '#10B981', fontWeight: 'bold' }}>
                      ðŸ”¥{streaks.current}
                    </text>
                  )}
                  <circle cx={circleX} cy={segmentY} r={10} fill={autoColors[habitIndex % autoColors.length].base} stroke={isSelected ? "#3B82F6" : "#3B82F6"} strokeWidth="4" />
                  <text x={circleX} y={segmentY + 4} textAnchor="middle" className="text-xs font-bold" style={{ fontFamily: 'Arial, sans-serif', fill: '#ffffff', fontSize: '15px' }}>
                    {habitIndex + 1}
                  </text>
                </g>
              );
            }

            for (let day = 1; day <= daysInMonth; day++) {
              const angle = getDayAngle(day), radian = (angle * Math.PI) / 180;
              const x = centerX + dayRadius * Math.cos(radian), y = centerY + dayRadius * Math.sin(radian);
              const today = new Date(), isToday = day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
              const dayProgress = getDailyProgress(day), date = new Date(currentYear, currentMonth, day), dayOfWeek = date.getDay();
              const dayNames = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'SÃ¡b'], dayName = dayNames[dayOfWeek];
              const weekendColor = (dayOfWeek === 0 || dayOfWeek === 6) ? "#EF4444" : "#6B7280";
              const weekendTextColor = (dayOfWeek === 0 || dayOfWeek === 6) ? "#FEE2E2" : "#D1D5DB";
              const isBlurred = focusedDay !== null && focusedDay !== day;

              rotatingElements.push(
                <g key={`day-${day}`} style={{ cursor: isBlurred ? 'not-allowed' : 'pointer', opacity: isBlurred ? 0.3 : 1, transition: animations ? 'all 0.6s ease' : 'none', filter: isBlurred ? 'blur(1px)' : 'none' }} onClick={(e) => { e.stopPropagation(); if (focusedDay === null || focusedDay === day) handleDayClick(day); }}>
                  <defs>
                    <radialGradient id={`dayGradient-${day}`} cx="50%" cy="50%" r="50%">
                      <stop offset="0%" stopColor={isToday ? "#374151" : "rgba(31, 41, 55, 0.9)"} />
                      <stop offset="100%" stopColor={isToday ? "#1F2937" : "rgba(31, 41, 55, 0.7)"} />
                    </radialGradient>
                  </defs>
                  <circle cx={x} cy={y} r={dayCircleRadius} fill={`url(#dayGradient-${day})`} stroke={isToday ? "#F59E0B" : weekendColor} strokeWidth={isToday ? "3" : "2"} filter="drop-shadow(0 2px 4px rgba(0,0,0,0.2))" />
                  {dayProgress > 0 && <circle cx={x} cy={y} r={dayCircleRadius - 3} fill="none" stroke="#10B981" strokeWidth="3" strokeDasharray={`${2 * Math.PI * (dayCircleRadius - 3)}`} strokeDashoffset={`${2 * Math.PI * (dayCircleRadius - 3) * (1 - dayProgress / 100)}`} strokeLinecap="round" transform={`rotate(-90 ${x} ${y})`} />}
                  <g transform={`rotate(${-rotationAngle} ${x} ${y})`}>
                    <text x={x} y={y - 2} textAnchor="middle" className={`font-bold ${isToday ? 'fill-white' : 'fill-gray-200'}`} style={{ fontSize: `${Math.max(14, dayCircleRadius * 0.7)}px`, fill: hoveredDay === day ? '#F59E0B' : (isToday ? '#ffffff' : '#D1D5DB') }}>
                      {day}
                    </text>
                    <text x={x} y={y + 12} textAnchor="middle" className="font-medium" fill={hoveredDay === day ? "#F59E0B" : (isToday ? "#F59E0B" : weekendTextColor)} style={{ fontSize: `${Math.max(10, dayCircleRadius * 0.4)}px` }}>
                      {dayName}
                    </text>
                  </g>
                </g>
              );
            }

            filteredHabits.forEach((habit, habitIndex) => {
              const radius = ringPositions[habitIndex];
              for (let day = 1; day <= daysInMonth; day++) {
                if (!shouldShowLosangeForDay(habit, day)) continue;
                const angle = getDayAngle(day), radian = (angle * Math.PI) / 180;
                const x = centerX + radius * Math.cos(radian), y = centerY + radius * Math.sin(radian);
                const isCompleted = isHabitCompleted(habit.id, day), cellSize = getScaledCellSize(habitIndex), halfSize = cellSize / 2;
                const isBlurred = focusedDay !== null && focusedDay !== day, isClickDisabled = focusedDay !== null && focusedDay !== day;
                const points = [{ x: x + halfSize, y: y }, { x: x, y: y - halfSize }, { x: x - halfSize, y: y }, { x: x, y: y + halfSize }];
                const pathData = `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y} L ${points[2].x} ${points[2].y} L ${points[3].x} ${points[3].y} Z`;
                
                const timeStatus = getHabitTimeStatus(habit, day);
                const timeColor = getTimeStatusColor(timeStatus);
                
                const baseFill = isCompleted ? autoColors[habitIndex % autoColors.length].base : 'rgba(255,255,255,0.15)';
                
                const baseStroke = autoColors[habitIndex % autoColors.length].base;
                const finalStroke = timeColor && habit.priority !== 'low' ? timeColor : baseStroke;
                
                const hasTimeIndicator = timeColor && habit.priority !== 'low';
                const strokeWidth = hasTimeIndicator ? (timeStatus === 'due-now' ? "4" : timeStatus === 'overdue' ? "3" : "2") : (isCompleted ? "2" : "1");
                const extraClasses = timeStatus === 'due-now' ? "animate-pulse" : "";

                rotatingElements.push(
                  <path 
                    key={`${habit.id}-${day}`}
                    d={pathData} 
                    fill={baseFill} 
                    stroke={finalStroke} 
                    strokeWidth={strokeWidth}
                    className={`${!isClickDisabled ? "cursor-pointer" : ""} ${extraClasses}`}
                    style={{ 
                      opacity: isBlurred ? 0.2 : (isCompleted ? 1 : 0.7), 
                      transition: 'opacity 0.2s ease', 
                      cursor: isClickDisabled ? 'not-allowed' : 'pointer', 
                      filter: isCompleted ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.2))' : 'none' 
                    }} 
                    onClick={(e) => { e.stopPropagation(); if (!isClickDisabled) toggleHabitDay(habit.id, day); }} 
                    onMouseEnter={() => { if (!isClickDisabled) { setHoveredDay(day); setHoveredHabit(habit.id); } }} 
                    onMouseLeave={() => { if (!isClickDisabled) { setHoveredDay(null); setHoveredHabit(null); } }} 
                  />
                );
                
                if (hasTimeIndicator && timeStatus !== 'no-schedule' && timeStatus !== 'future') {
                  rotatingElements.push(
                    <circle
                      key={`${habit.id}-${day}-indicator`}
                      cx={x}
                      cy={y}
                      r="3"
                      fill={timeColor}
                      className={timeStatus === 'due-now' ? "animate-pulse" : ""}
                      style={{ 
                        filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.3))',
                        pointerEvents: 'none'
                      }}
                    />
                  );
                }
              }
            });

            return { fixedElements, rotatingElements, svgSize };
          };

          const stats = getMonthlyStats();
          const { fixedElements, rotatingElements, svgSize } = generateCircularCalendar();

          // ðŸŽ¯ NOVO: Componente de status de salvamento
          const SaveStatusIndicator = () => {
            const getStatusIcon = () => {
              switch (saveStatus) {
                case 'saving':
                  return <Save className="w-4 h-4 text-blue-400 animate-spin" />;
                case 'saved':
                  return <CheckCircle className="w-4 h-4 text-green-400" />;
                case 'error':
                  return <AlertCircle className="w-4 h-4 text-red-400" />;
                default:
                  return <Save className="w-4 h-4 text-gray-400" />;
              }
            };

            const getStatusText = () => {
              switch (saveStatus) {
                case 'saving':
                  return 'Salvando...';
                case 'saved':
                  return lastSaveTime ? `Salvo ${new Date(lastSaveTime).toLocaleTimeString('pt-BR')}` : 'Salvo';
                case 'error':
                  return 'Erro ao salvar';
                default:
                  return 'Salvamento desconhecido';
              }
            };

            const getStatusColor = () => {
              switch (saveStatus) {
                case 'saving':
                  return 'border-blue-500/40 bg-blue-500/10';
                case 'saved':
                  return 'border-green-500/40 bg-green-500/10';
                case 'error':
                  return 'border-red-500/40 bg-red-500/10';
                default:
                  return 'border-gray-500/40 bg-gray-500/10';
              }
            };

            return (
              <div className={`flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm ${getStatusColor()}`}>
                {getStatusIcon()}
                <span className="text-xs font-medium text-white">
                  {getStatusText()}
                </span>
                {autoSaveEnabled && (
                  <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse" title="Auto-save ativo" />
                )}
              </div>
            );
          };

          return (
            <div className="min-h-screen bg-gray-900 p-4 overflow-x-hidden">
              <div className="max-w-7xl mx-auto overflow-hidden">
                <div className="text-center mb-8">
                  <h1 className="text-7xl font-black mb-6 tracking-tight" style={{ fontFamily: 'Georgia, Times, "Times New Roman", serif', color: '#8B1538', textShadow: '0 0 15px rgba(139, 21, 56, 0.4), 3px 3px 6px rgba(0, 0, 0, 0.8)', textTransform: 'uppercase', letterSpacing: '3px', fontWeight: 'bold' }}>
                    Rastreador de HÃ¡bitos
                  </h1>
                  
                  {/* ðŸŽ¯ NOVO: Indicador de salvamento automÃ¡tico */}
                  <div className="flex items-center justify-center gap-4 mb-4">
                    <SaveStatusIndicator />
                    <button
                      onClick={() => {
                        setAutoSaveEnabled(!autoSaveEnabled);
                        if (!autoSaveEnabled) {
                          autoSave(true); // Salvar imediatamente ao reativar
                        }
                      }}
                      className={`flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm transition-all ${
                        autoSaveEnabled 
                          ? 'border-green-500/40 bg-green-500/10 text-green-300' 
                          : 'border-gray-500/40 bg-gray-500/10 text-gray-400'
                      }`}
                      title={autoSaveEnabled ? "Desativar salvamento automÃ¡tico" : "Ativar salvamento automÃ¡tico"}
                    >
                      <Settings className="w-3 h-3" />
                      <span className="text-xs font-medium">
                        Auto-save {autoSaveEnabled ? 'ON' : 'OFF'}
                      </span>
                    </button>
                  </div>
                  
                  <div className="flex items-center justify-center gap-6 mb-6">
                    <button onClick={() => {
                      let [newMonth, newYear] = [currentMonth - 1, currentYear];
                      if (newMonth < 0) { newMonth = 11; newYear--; }
                      setCurrentMonth(newMonth); setCurrentYear(newYear); setFocusedDay(null); setRotationAngle(0);
                      // Reset timeline quando mudar mÃªs
                      timelineVersionRef.current += 1;
                      savedScrollPositionRef.current = 0;
                      timelineInitialScrollDoneRef.current = false;
                      timelineUserInteractedRef.current = false;
                      updateTimelineData();
                      // Limpar estados de ediÃ§Ã£o
                      setEditingHabitId(null);
                      setEditForm({ name: '', priority: '', daysType: '' });
                      setExpandedHabitDetails(null);
                    }} className="px-4 py-3 bg-gray-800 hover:bg-gray-700 backdrop-blur-sm rounded-xl transition-all duration-200 text-white font-medium border border-gray-600 hover:border-gray-500 hover:scale-105">â†</button>
                    <div className="px-8 py-3 bg-gray-800 backdrop-blur-sm rounded-xl border border-gray-600">
                      <span className="text-xl font-bold text-white" style={{ textTransform: 'uppercase' }}>{monthNames[currentMonth]} {currentYear}</span>
                    </div>
                    <button onClick={() => {
                      let [newMonth, newYear] = [currentMonth + 1, currentYear];
                      if (newMonth > 11) { newMonth = 0; newYear++; }
                      setCurrentMonth(newMonth); setCurrentYear(newYear); setFocusedDay(null); setRotationAngle(0);
                      // Reset timeline quando mudar mÃªs
                      timelineVersionRef.current += 1;
                      savedScrollPositionRef.current = 0;
                      timelineInitialScrollDoneRef.current = false;
                      timelineUserInteractedRef.current = false;
                      updateTimelineData();
                      // Limpar estados de ediÃ§Ã£o
                      setEditingHabitId(null);
                      setEditForm({ name: '', priority: '', daysType: '' });
                      setExpandedHabitDetails(null);
                    }} className="px-4 py-3 bg-gray-800 hover:bg-gray-700 backdrop-blur-sm rounded-xl transition-all duration-200 text-white font-medium border border-gray-600 hover:border-gray-500 hover:scale-105">â†’</button>
                  </div>
                </div>

                <div className="grid xl:grid-cols-5 lg:grid-cols-3 gap-6 w-full max-w-full overflow-hidden">
                  <div className="xl:col-span-5 lg:col-span-3 mb-4">
                    <div className="flex items-center justify-center gap-4 flex-wrap">
                      {overdueCount > 0 && !overdueNotificationClosed && (
                        <div className="bg-gradient-to-r from-red-500/15 to-orange-500/15 border border-red-500/40 rounded-xl px-4 py-2 backdrop-blur-sm">
                          <div className="flex items-center gap-3">
                            <div className="relative bg-red-500 rounded-lg p-1.5">
                              <Clock className="w-3 h-3 text-white" />
                              <div className="absolute -top-1 -right-1 bg-orange-400 text-white text-xs font-bold rounded-full w-3 h-3 flex items-center justify-center text-[10px]">
                                {overdueCount}
                              </div>
                            </div>
                            <div className="flex-1">
                              <div className="font-semibold text-red-200 text-sm">
                                {overdueCount} hÃ¡bito{overdueCount > 1 ? 's' : ''} em atraso
                              </div>
                              <div className="text-xs text-red-300/80">
                                Confira sua timeline para colocar em dia
                              </div>
                            </div>
                            <button
                              onClick={() => {
                                setOverdueNotificationClosed(true);
                              }}
                              className="text-red-300 hover:text-red-100 hover:bg-red-500/20 p-1 rounded transition-colors"
                              title="Fechar aviso"
                            >
                              âœ•
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  <div className="xl:col-span-5 lg:col-span-3 mb-6 w-full overflow-hidden">
                    <TimelineHorizontal />
                  </div>
                </div>

                <div className="grid xl:grid-cols-5 lg:grid-cols-3 gap-6 w-full max-w-full overflow-hidden">
                  <div className="xl:col-span-3 lg:col-span-2">
                    <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-8 border border-gray-700 shadow-2xl relative">
                      {showAddForm && (
                        <div className="absolute inset-0 bg-black/60 backdrop-blur-md rounded-3xl flex items-center justify-center z-50">
                          <div className="bg-gray-800 backdrop-blur-md rounded-2xl p-6 border border-gray-600 shadow-xl max-w-md w-full mx-4">
                            <h3 className="text-lg font-bold mb-4 text-center flex items-center justify-center gap-2 text-white"><Plus className="w-5 h-5 text-green-400" />Novo HÃ¡bito</h3>
                            <div className="space-y-4">
                              <input type="text" value={newHabit} onChange={(e) => setNewHabit(e.target.value)} onKeyPress={(e) => { if (e.key === 'Enter') addNewHabit(); }} placeholder="Nome do hÃ¡bito (ex: Ãgua ðŸ’§, ExercÃ­cio ðŸƒâ€â™‚ï¸)..." maxLength={50} className="w-full px-4 py-3 rounded-xl border focus:outline-none focus:ring-2 transition-all bg-gray-700 border-gray-600 text-white placeholder-gray-400 focus:ring-green-500 focus:border-green-500" autoFocus />
                              
                              <div>
                                <label className="block text-sm font-medium text-gray-300 mb-2">Prioridade</label>
                                <div className="flex gap-2">
                                  {priorities.map(priority => (
                                    <button key={priority.value} onClick={() => setSelectedPriority(priority.value)} className={`flex-1 py-2 px-3 rounded-lg border transition-all ${selectedPriority === priority.value ? 'bg-gray-600 border-gray-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600'}`}>
                                      <span className="text-sm">{priority.flag}</span><div className="text-xs">{priority.label}</div>
                                    </button>
                                  ))}
                                </div>
                              </div>

                              <div>
                                <label className="block text-sm font-medium text-gray-300 mb-2">FrequÃªncia</label>
                                <div className="space-y-2">
                                  {daysTypes.map(daysType => (
                                    <button key={daysType.value} onClick={() => setSelectedDaysType(daysType.value)} className={`w-full py-2 px-3 rounded-lg border transition-all text-left ${selectedDaysType === daysType.value ? 'bg-gray-600 border-gray-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600'}`}>
                                      <div className="flex items-center gap-2"><span>{daysType.icon}</span><div><div className="font-medium text-sm">{daysType.label}</div><div className="text-xs opacity-75">{daysType.description}</div></div></div>
                                    </button>
                                  ))}
                                </div>
                              </div>

                              {selectedPriority !== 'low' && (
                                <div>
                                  <label className="block text-sm font-medium text-gray-300 mb-2">
                                    HorÃ¡rio (Opcional)
                                    <span className="text-xs text-gray-400 ml-2">âš¡ DisponÃ­vel para prioridades mÃ©dia e alta</span>
                                  </label>
                                  <div className="space-y-2">
                                    <select 
                                      value={selectedScheduleTime} 
                                      onChange={(e) => setSelectedScheduleTime(e.target.value)}
                                      className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    >
                                      <option value="">Sem horÃ¡rio fixo</option>
                                      <option value="morning">ðŸŒ… ManhÃ£ (6h - 12h)</option>
                                      <option value="afternoon">â˜€ï¸ Tarde (12h - 18h)</option>
                                      <option value="evening">ðŸŒ™ Noite (18h - 23h)</option>
                                      <option value="06:00">06:00</option>
                                      <option value="06:30">06:30</option>
                                      <option value="07:00">07:00</option>
                                      <option value="07:30">07:30</option>
                                      <option value="08:00">08:00</option>
                                      <option value="08:30">08:30</option>
                                      <option value="09:00">09:00</option>
                                      <option value="09:30">09:30</option>
                                      <option value="10:00">10:00</option>
                                      <option value="10:30">10:30</option>
                                      <option value="11:00">11:00</option>
                                      <option value="11:30">11:30</option>
                                      <option value="12:00">12:00</option>
                                      <option value="12:30">12:30</option>
                                      <option value="13:00">13:00</option>
                                      <option value="13:30">13:30</option>
                                      <option value="14:00">14:00</option>
                                      <option value="14:30">14:30</option>
                                      <option value="15:00">15:00</option>
                                      <option value="15:30">15:30</option>
                                      <option value="16:00">16:00</option>
                                      <option value="16:30">16:30</option>
                                      <option value="17:00">17:00</option>
                                      <option value="17:30">17:30</option>
                                      <option value="18:00">18:00</option>
                                      <option value="18:30">18:30</option>
                                      <option value="19:00">19:00</option>
                                      <option value="19:30">19:30</option>
                                      <option value="20:00">20:00</option>
                                      <option value="20:30">20:30</option>
                                      <option value="21:00">21:00</option>
                                      <option value="21:30">21:30</option>
                                      <option value="22:00">22:00</option>
                                      <option value="22:30">22:30</option>
                                      <option value="23:00">23:00</option>
                                      <option value="23:30">23:30</option>
                                    </select>
                                    
                                    {selectedScheduleTime && (
                                      <div>
                                        <label className="block text-sm font-medium text-gray-300 mb-2">
                                          Lembrete
                                        </label>
                                        <select 
                                          value={selectedNotificationPref} 
                                          onChange={(e) => setSelectedNotificationPref(e.target.value)}
                                          className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                        >
                                          <option value="disabled">Sem lembrete</option>
                                          <option value="onTime">Na hora exata</option>
                                          <option value="15minBefore">15 min antes</option>
                                        </select>
                                      </div>
                                    )}
                                  </div>
                                </div>
                              )}

                              {selectedPriority === 'low' && (
                                <div className="bg-gray-700/50 border border-gray-600 rounded-lg p-3">
                                  <div className="flex items-center gap-2 text-gray-300 text-sm">
                                    <span>ðŸ’¡</span>
                                    <span>HÃ¡bitos de baixa prioridade sÃ£o flexÃ­veis - sem horÃ¡rios ou lembretes</span>
                                  </div>
                                </div>
                              )}
                              
                              <div className="flex gap-3">
                                <button onClick={addNewHabit} className="flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-green-600 hover:bg-green-700 text-white hover:scale-105">Adicionar</button>
                                <button onClick={() => { setShowAddForm(false); setNewHabit(''); setSelectedPriority('medium'); setSelectedDaysType('all'); setSelectedScheduleTime(''); setSelectedNotificationPref('onTime'); }} className="flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-gray-600 hover:bg-gray-700 text-white">Cancelar</button>
                              </div>
                            </div>
                          </div>
                        </div>
                      )}
                      
                      <div className="flex justify-center">
                        <svg width={svgSize} height={svgSize} viewBox={`0 0 ${svgSize} ${svgSize}`} className="max-w-full h-auto" onClick={handleCalendarClick}>
                          {fixedElements}
                          <g style={{ transform: `rotate(${rotationAngle}deg)`, transition: animations ? 'transform 0.6s ease' : 'none', transformOrigin: 'center' }}>
                            {rotatingElements}
                          </g>
                        </svg>
                      </div>
                    </div>
                  </div>

                  <div className="xl:col-span-2 lg:col-span-1 space-y-6">
                    <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
                      <h3 className="text-lg font-bold text-white mb-4 flex items-center gap-2"><Filter className="w-5 h-5 text-yellow-400" />Filtros e ConfiguraÃ§Ãµes</h3>
                      <div className="space-y-4">
                        <div className="relative">
                          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
                          <input type="text" placeholder="Buscar hÃ¡bitos..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full pl-10 pr-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-300 mb-2">Filtrar por prioridade</label>
                          <select value={priorityFilter} onChange={(e) => setPriorityFilter(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="all">Todas as prioridades</option>
                            {priorities.map(priority => <option key={priority.value} value={priority.value}>{priority.flag} {priority.label}</option>)}
                          </select>
                        </div>
                        
                        {(searchTerm || priorityFilter !== 'all' || selectedHabitId) && (
                          <button 
                            onClick={() => {
                              setSearchTerm('');
                              setPriorityFilter('all');
                              setSelectedHabitId(null);
                              setEditingHabitId(null);
                              setEditForm({ name: '', priority: '', daysType: '' });
                            }}
                            className="w-full flex items-center justify-center gap-2 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded-lg transition-all duration-200 font-medium text-sm"
                          >
                            <RefreshCw className="w-4 h-4" />
                            Limpar Todos os Filtros
                          </button>
                        )}
                        
                        {selectedHabitId && (
                          <div className="bg-blue-600/20 border border-blue-500/50 rounded-lg p-3">
                            <div className="flex items-center justify-between">
                              <div className="flex items-center gap-2">
                                <Target className="w-4 h-4 text-blue-400" />
                                <span className="text-blue-300 text-sm font-medium">HÃ¡bito em foco</span>
                              </div>
                              <button 
                                onClick={() => setSelectedHabitId(null)}
                                className="text-blue-400 hover:text-blue-300 transition-colors"
                              >
                                âœ•
                              </button>
                            </div>
                            <div className="text-blue-200 text-xs mt-1">
                              {allHabits.find(h => h.id === selectedHabitId)?.name}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
                      <div className="flex items-center gap-2 mb-4">
                        <TrendingUp className="w-6 h-6 text-blue-400" />
                        <h3 className="text-xl font-bold text-white">Meus HÃ¡bitos - {monthNames[currentMonth]} {currentYear}</h3>
                        <div className="ml-auto flex items-center gap-2 bg-purple-600/20 px-3 py-1 rounded-full border border-purple-500/30">
                          <Target className="w-4 h-4 text-purple-400" />
                          <span className="text-purple-300 font-medium text-sm">{filteredHabits.length} hÃ¡bitos</span>
                        </div>
                      </div>
                      {filteredHabits.length === 0 ? (
                        <div className="text-center py-8">
                          <div className="text-4xl mb-4">ðŸ“…</div>
                          <p className="text-gray-300 mb-4">{allHabits.length === 0 ? 'Nenhum hÃ¡bito configurado para este mÃªs' : 'Nenhum hÃ¡bito encontrado com os filtros atuais'}</p>
                          <p className="text-gray-400 text-sm mb-4">{allHabits.length === 0 ? 'Clique no centro do calendÃ¡rio para adicionar seu primeiro hÃ¡bito' : 'Tente ajustar os filtros ou limpar a busca'}</p>
                        </div>
                      ) : (
                        <div className="space-y-3">
                          {filteredHabits.map((habit, index) => {
                            const percentage = getCompletionPercentage(habit.id);
                            const streaks = calculateStreak(habit.id);
                            const isDetailsExpanded = expandedHabitDetails === habit.id;
                            const isEditing = editingHabitId === habit.id;
                            
                            return (
                              <div key={habit.id}>
                                <div className="p-4 bg-gray-700/50 backdrop-blur-sm rounded-xl border border-gray-600 hover:bg-gray-700/70 transition-all duration-200">
                                  {isEditing ? (
                                    /* MODO EDIÃ‡ÃƒO */
                                    <div className="space-y-3">
                                      <div>
                                        <label className="block text-xs font-medium text-gray-300 mb-1">Nome do HÃ¡bito</label>
                                        <input
                                          type="text"
                                          value={editForm.name}
                                          onChange={(e) => setEditForm({...editForm, name: e.target.value})}
                                          onKeyDown={(e) => {
                                            if (e.key === 'Enter' && editForm.name.trim()) saveHabitEdit();
                                            if (e.key === 'Escape') cancelHabitEdit();
                                          }}
                                          className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                                          maxLength={50}
                                          autoFocus
                                        />
                                      </div>
                                      
                                      <div className="grid grid-cols-2 gap-3">
                                        <div>
                                          <label className="block text-xs font-medium text-gray-300 mb-1">Prioridade</label>
                                          <select
                                            value={editForm.priority}
                                            onChange={(e) => setEditForm({...editForm, priority: e.target.value})}
                                            className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                                          >
                                            {priorities.map(priority => (
                                              <option key={priority.value} value={priority.value}>
                                                {priority.flag} {priority.label}
                                              </option>
                                            ))}
                                          </select>
                                        </div>
                                        
                                        <div>
                                          <label className="block text-xs font-medium text-gray-300 mb-1">FrequÃªncia</label>
                                          <select
                                            value={editForm.daysType}
                                            onChange={(e) => setEditForm({...editForm, daysType: e.target.value})}
                                            className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                                          >
                                            {daysTypes.map(daysType => (
                                              <option key={daysType.value} value={daysType.value}>
                                                {daysType.icon} {daysType.label}
                                              </option>
                                            ))}
                                          </select>
                                        </div>
                                      </div>
                                      
                                      {editForm.priority === 'low' && (
                                        <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-2">
                                          <div className="flex items-center gap-2 text-yellow-300 text-xs">
                                            <span>âš ï¸</span>
                                            <span>HÃ¡bitos de baixa prioridade perdem horÃ¡rios e lembretes configurados</span>
                                          </div>
                                        </div>
                                      )}
                                      
                                      <div className="flex gap-2 pt-2">
                                        <button
                                          onClick={saveHabitEdit}
                                          disabled={!editForm.name.trim()}
                                          className="flex-1 py-2 px-3 bg-green-600 hover:bg-green-700 disabled:bg-gray-500 disabled:cursor-not-allowed text-white rounded-lg transition-colors text-sm font-medium"
                                        >
                                          âœ“ Salvar
                                        </button>
                                        <button
                                          onClick={cancelHabitEdit}
                                          className="flex-1 py-2 px-3 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition-colors text-sm font-medium"
                                        >
                                          âœ• Cancelar
                                        </button>
                                      </div>
                                    </div>
                                  ) : (
                                    /* MODO VISUALIZAÃ‡ÃƒO */
                                    <>
                                      <div className="flex items-center justify-between mb-2">
                                        <div className="flex items-center gap-3 flex-1">
                                          <div className="flex-1">
                                            <div className="flex items-center gap-2 mb-1">
                                              <span 
                                                className="text-white font-medium cursor-pointer hover:text-blue-300 hover:underline transition-all duration-200"
                                                onClick={() => setExpandedHabitDetails(isDetailsExpanded ? null : habit.id)}
                                                title="Clique para ver detalhes"
                                              >
                                                {habit.name}
                                              </span>
                                              {showStreaks && streaks.current > 0 && (
                                                <div className="flex items-center gap-1 bg-orange-500/20 px-2 py-1 rounded-full">
                                                  <Flame className="w-3 h-3 text-orange-400" /><span className="text-xs text-orange-400 font-bold">{streaks.current}</span>
                                                </div>
                                              )}
                                              {showStreaks && streaks.best > 3 && (
                                                <div className="flex items-center gap-1 bg-yellow-500/20 px-2 py-1 rounded-full">
                                                  <Trophy className="w-3 h-3 text-yellow-400" /><span className="text-xs text-yellow-400 font-bold">{streaks.best}</span>
                                                </div>
                                              )}
                                            </div>
                                            <div className="text-xs text-gray-400 flex items-center gap-2">
                                              <span>Anel {index + 1}</span><span>â€¢</span><span>{daysTypes.find(dt => dt.value === habit.daysType)?.label || 'Todos os dias'}</span><span>â€¢</span><span>{priorities.find(p => p.value === habit.priority)?.flag} {priorities.find(p => p.value === habit.priority)?.label}</span>
                                            </div>
                                          </div>
                                        </div>
                                        <div className="flex items-center gap-2">
                                          <span className="text-sm font-bold text-white">{percentage}%</span>
                                          <button 
                                            onClick={() => startEditingHabit(habit)} 
                                            className="p-1 text-gray-400 hover:text-blue-400 transition-colors rounded hover:bg-blue-500/20"
                                            title="Editar hÃ¡bito"
                                          >
                                            <Edit2 className="w-4 h-4" />
                                          </button>
                                          <button 
                                            onClick={() => setExpandedHabitDetails(isDetailsExpanded ? null : habit.id)} 
                                            className={`p-1 transition-colors rounded ${isDetailsExpanded ? 'text-blue-400 bg-blue-500/20' : 'text-gray-400 hover:text-blue-400 hover:bg-blue-500/20'}`}
                                            title={isDetailsExpanded ? "Fechar detalhes" : "Ver detalhes"}
                                          >
                                            <Eye className="w-4 h-4" />
                                          </button>
                                          <button 
                                            onClick={() => deleteHabit(habit.id)} 
                                            className="p-1 text-gray-400 hover:text-red-400 transition-colors rounded hover:bg-red-500/20"
                                            title="Excluir hÃ¡bito"
                                          >
                                            <Trash2 className="w-4 h-4" />
                                          </button>
                                        </div>
                                      </div>
                                      <div className="w-full bg-gray-700 rounded-full h-2">
                                        <div className="h-2 rounded-full transition-all duration-500" style={{ width: `${percentage}%`, backgroundColor: autoColors[index % autoColors.length].base }} />
                                      </div>
                                    </>
                                  )}
                                </div>
                                
                                {isDetailsExpanded && (
                                  <div className="mt-2 bg-gray-800/70 backdrop-blur-sm rounded-xl border border-gray-600 p-3">
                                    <h5 className="text-xs font-medium text-blue-400 mb-2 flex items-center gap-2">
                                      <Eye className="w-3 h-3" />
                                      Detalhes - {habit.name}
                                    </h5>
                                    
                                    <div className="space-y-4">
                                      <div className="grid grid-cols-4 gap-2">
                                        <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                          <div className="text-xs text-gray-400 mb-1">Prioridade</div>
                                          <div className="text-white text-xs font-medium">
                                            {priorities.find(p => p.value === habit.priority)?.flag}
                                          </div>
                                        </div>
                                        <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                          <div className="text-xs text-gray-400 mb-1">FrequÃªncia</div>
                                          <div className="text-white text-xs font-medium">
                                            {daysTypes.find(dt => dt.value === habit.daysType)?.icon}
                                          </div>
                                        </div>
                                        {(() => {
                                          let completed = 0, applicable = 0;
                                          for (let day = 1; day <= daysInMonth; day++) {
                                            if (shouldShowLosangeForDay(habit, day)) {
                                              applicable++;
                                              if (isHabitCompleted(habit.id, day)) completed++;
                                            }
                                          }
                                          
                                          return (
                                            <>
                                              <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                                <div className="text-xs text-gray-400 mb-1">ConcluÃ­dos</div>
                                                <div className="text-green-400 text-xs font-bold">{completed}</div>
                                              </div>
                                              <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                                <div className="text-xs text-gray-400 mb-1">AplicÃ¡veis</div>
                                                <div className="text-blue-400 text-xs font-bold">{applicable}</div>
                                              </div>
                                            </>
                                          );
                                        })()}
                                      </div>
                                      
                                      {/* PROGRAMAÃ‡ÃƒO COMPACTA */}
                                      {habit.scheduleTime && habit.priority !== 'low' && (
                                        <div className="bg-blue-500/20 rounded-lg p-2 border border-blue-500/30">
                                          <div className="flex items-center justify-between text-xs">
                                            <div className="flex items-center gap-2">
                                              <Clock className="w-3 h-3 text-blue-400" />
                                              <span className="text-blue-400 font-medium">ProgramaÃ§Ã£o</span>
                                            </div>
                                            <div className="text-blue-300 font-medium">
                                              {(() => {
                                                const scheduleInfo = parseScheduleTime(habit.scheduleTime);
                                                if (scheduleInfo) {
                                                  if (scheduleInfo.start !== undefined) {
                                                    const periods = { morning: 'ðŸŒ… ManhÃ£', afternoon: 'â˜€ï¸ Tarde', evening: 'ðŸŒ™ Noite' };
                                                    return periods[habit.scheduleTime] || habit.scheduleTime;
                                                  } else {
                                                    return `ðŸ• ${scheduleInfo.hours.toString().padStart(2, '0')}:${scheduleInfo.minutes.toString().padStart(2, '0')}`;
                                                  }
                                                }
                                                return habit.scheduleTime;
                                              })()}
                                            </div>
                                          </div>
                                          
                                          {(() => {
                                            const today = new Date();
                                            const isToday = today.getDate() === new Date().getDate() && 
                                                           today.getMonth() === currentMonth && 
                                                           today.getFullYear() === currentYear;
                                            
                                            if (isToday && shouldShowLosangeForDay(habit, today.getDate())) {
                                              const status = getHabitTimeStatus(habit, today.getDate());
                                              const statusLabels = {
                                                'completed': 'âœ… ConcluÃ­do',
                                                'due-now': 'ðŸ”µ Ã‰ agora!',
                                                'due-soon': 'ðŸŸ¡ Em breve',
                                                'overdue': 'ðŸ”´ Atrasado',
                                                'snoozed': 'ðŸ˜´ Adiado'
                                              };
                                              
                                              if (status !== 'no-schedule' && status !== 'future') {
                                                return (
                                                  <div className="mt-1 text-center text-xs font-medium text-blue-200">
                                                    {statusLabels[status] || status}
                                                  </div>
                                                );
                                              }
                                            }
                                            return null;
                                          })()}
                                        </div>
                                      )}
                                      
                                      {/* HÃBITOS SEM HORÃRIO - COMPACTO */}
                                      {(!habit.scheduleTime && habit.priority !== 'low') && (
                                        <div className="bg-gray-600/20 rounded-lg p-2 border border-gray-600/30 text-center">
                                          <div className="text-gray-400 text-xs">
                                            <Clock className="w-4 h-4 mx-auto mb-1 opacity-50" />
                                            Atividade flexÃ­vel - sem horÃ¡rio fixo
                                          </div>
                                        </div>
                                      )}
                                      
                                      {/* BAIXA PRIORIDADE - COMPACTO */}
                                      {habit.priority === 'low' && (
                                        <div className="bg-gray-600/20 rounded-lg p-2 border border-gray-600/30 text-center">
                                          <div className="text-gray-400 text-xs">
                                            ðŸ³ï¸ HÃ¡bito flexÃ­vel - baixa prioridade
                                          </div>
                                        </div>
                                      )}

                                      <div className="border-t border-gray-600 pt-2">
                                        <h6 className="text-xs font-medium text-cyan-400 mb-2 flex items-center gap-1">
                                          <Edit2 className="w-3 h-3" />
                                          ObservaÃ§Ãµes e Links
                                        </h6>
                                        <div className="space-y-2">
                                          {habit.observations.map((observation, obsIndex) => (
                                            <div key={obsIndex} className="bg-gray-900/40 rounded p-2 border border-gray-700">
                                              <div className="flex items-center justify-between mb-1">
                                                <label className="text-[10px] font-medium text-gray-400">
                                                  Obs. {obsIndex + 1}
                                                </label>
                                                <span className="text-[10px] text-gray-500">
                                                  {observation.length}/200
                                                </span>
                                              </div>
                                              <input
                                                type="text"
                                                value={observation}
                                                onChange={(e) => updateHabitObservation(habit.id, obsIndex, e.target.value)}
                                                placeholder={obsIndex === 0 ? "Ex: https://link.com" : obsIndex === 1 ? "Nota pessoal" : "Link adicional"}
                                                className="w-full px-2 py-1 text-xs rounded border bg-gray-800 border-gray-600 text-white placeholder-gray-500 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                                                maxLength={200}
                                              />
                                              {observation && observation.trim() && (
                                                <div className="mt-1 p-1.5 bg-gray-700/50 rounded border-l-2 border-cyan-500">
                                                  <div className="text-[10px] text-gray-300">
                                                    {renderTextWithLinks(observation)}
                                                  </div>
                                                </div>
                                              )}
                                            </div>
                                          ))}
                                        </div>
                                        <div className="mt-2 text-[10px] text-gray-500">
                                          ðŸ’¡ Links com https:// ou www. ficam clicÃ¡veis automaticamente
                                        </div>
                                      </div>
                                    </div>
                                    
                                    <div className="mt-2 text-xs text-gray-500 flex items-center justify-end border-t border-gray-600 pt-2">
                                      <button 
                                        onClick={() => setExpandedHabitDetails(null)}
                                        className="text-gray-400 hover:text-white transition-colors px-2 py-1 rounded hover:bg-gray-700 text-xs"
                                      >
                                        Fechar
                                      </button>
                                    </div>
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>

                    <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
                      <h3 className="text-lg font-bold text-white mb-3 flex items-center gap-2"><Settings className="w-5 h-5 text-purple-400" />Como usar</h3>
                      <div className="text-sm text-gray-300 space-y-2">
                        {[
                          { color: 'text-green-400', text: 'Clique no centro para adicionar novos hÃ¡bitos' },
                          { color: 'text-purple-400', text: 'Clique nos losangos para marcar dias concluÃ­dos' },
                          { color: 'text-cyan-400', text: 'Clique em um dia para girar o calendÃ¡rio e focÃ¡-lo' },
                          { color: 'text-blue-400', text: 'Use filtros para focar em hÃ¡bitos especÃ­ficos' },
                          { color: 'text-orange-400', text: 'ðŸ”¥ = sequÃªncia atual, ðŸ† = melhor sequÃªncia' },
                          { color: 'text-pink-400', text: 'Configure prioridades e frequÃªncias dos hÃ¡bitos' },
                          { color: 'text-yellow-400', text: 'â° HÃ¡bitos mÃ©dia/alta prioridade podem ter horÃ¡rios' },
                          { color: 'text-indigo-400', text: 'ðŸ“… Use a Timeline para ver agenda do dia atual' },
                          { color: 'text-emerald-400', text: 'âœï¸ Clique no Ã­cone de ediÃ§Ã£o para modificar hÃ¡bitos' },
                          { color: 'text-teal-400', text: 'ðŸ‘† Clique no nome do hÃ¡bito para ver detalhes completos' },
                          { color: 'text-rose-400', text: 'ðŸ’¾ Dados salvos automaticamente a cada mudanÃ§a' }
                        ].map(({ color, text }, i) => (
                          <div key={i} className="flex items-start gap-2">
                            <span className={`${color} mt-1`}>â€¢</span><span>{text}</span>
                          </div>
                        ))}
                      </div>
                    </div>

                    <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
                      <h3 className="text-lg font-bold text-white mb-3 flex items-center gap-2"><Target className="w-5 h-5 text-green-400" />AÃ§Ãµes RÃ¡pidas</h3>
                      <div className="space-y-3">
                        {/* ðŸŽ¯ NOVO: Salvamento manual */}
                        <button 
                          onClick={() => autoSave(true)}
                          disabled={saveStatus === 'saving'}
                          className={`w-full flex items-center justify-center gap-2 py-3 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105 ${
                            saveStatus === 'saving' 
                              ? 'bg-blue-600/50 cursor-not-allowed' 
                              : 'bg-blue-600 hover:bg-blue-700'
                          }`}
                        >
                          {saveStatus === 'saving' ? (
                            <Save className="w-4 h-4 animate-spin" />
                          ) : (
                            <Save className="w-4 h-4" />
                          )}
                          {saveStatus === 'saving' ? 'Salvando...' : 'Salvar Agora'}
                        </button>

                        {filteredHabits.length > 0 && (
                          <>
                            <button onClick={() => setShowStats(!showStats)} className={`w-full flex items-center justify-center gap-2 py-3 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105 ${showStats ? 'bg-orange-700 hover:bg-orange-800' : 'bg-orange-600 hover:bg-orange-700'}`}>
                              <BarChart3 className="w-4 h-4" />{showStats ? 'Ocultar' : 'Mostrar'} EstatÃ­sticas
                              <div className={`ml-1 transition-transform duration-200 ${showStats ? 'rotate-180' : 'rotate-0'}`}>
                                â–¼
                              </div>
                            </button>
                            
                            <div className={`overflow-hidden transition-all duration-300 ${showStats ? 'max-h-[2000px] opacity-100' : 'max-h-0 opacity-0'}`}>
                              <div className="bg-gray-700/30 backdrop-blur-sm rounded-xl border border-gray-600 p-4 mt-2">
                                <h4 className="text-lg font-bold text-orange-400 mb-4 flex items-center gap-2">
                                  <BarChart3 className="w-5 h-5" />
                                  EstatÃ­sticas Detalhadas
                                </h4>
                                
                                <div className="space-y-4">
                                  <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-600">
                                    <h5 className="font-semibold text-white mb-3 flex items-center gap-2">
                                      <Clock className="w-4 h-4 text-cyan-400" />
                                      AnÃ¡lise Semanal
                                    </h5>
                                    <div className="grid grid-cols-7 gap-2 text-xs">
                                      {['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'SÃ¡b'].map((day, dayIndex) => {
                                        let totalForDay = 0, countForDay = 0;
                                        for (let date = 1; date <= daysInMonth; date++) {
                                          if (new Date(currentYear, currentMonth, date).getDay() === dayIndex) {
                                            totalForDay += getDailyProgress(date);
                                            countForDay++;
                                          }
                                        }
                                        const averageForDay = countForDay > 0 ? Math.round(totalForDay / countForDay) : 0;
                                        const isWeekend = dayIndex === 0 || dayIndex === 6;
                                        return (
                                          <div key={day} className={`rounded-lg p-2 text-center transition-colors hover:bg-gray-700/70 ${isWeekend ? 'bg-red-500/10 border border-red-500/30' : 'bg-gray-700/50'}`}>
                                            <div className={`mb-1 font-medium ${isWeekend ? 'text-red-300' : 'text-gray-300'}`}>{day}</div>
                                            <div className="text-white font-bold text-sm">{averageForDay}%</div>
                                            <div className="w-full bg-gray-600 rounded-full h-1 mt-1">
                                              <div 
                                                className="h-1 rounded-full transition-all duration-500" 
                                                style={{ 
                                                  width: `${averageForDay}%`,
                                                  backgroundColor: averageForDay >= 80 ? '#10B981' : averageForDay >= 60 ? '#F59E0B' : '#EF4444'
                                                }} 
                                              />
                                            </div>
                                          </div>
                                        );
                                      })}
                                    </div>
                                    <div className="mt-3 text-xs text-gray-400 text-center">
                                      ðŸ’¡ Fins de semana destacados em vermelho
                                    </div>
                                  </div>

                                  <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-600">
                                    <h5 className="font-semibold text-white mb-3 flex items-center gap-2">
                                      <TrendingUp className="w-4 h-4 text-green-400" />
                                      Performance por HÃ¡bito
                                    </h5>
                                    <div className="space-y-2">
                                      {filteredHabits.map((habit, index) => {
                                        const percentage = getCompletionPercentage(habit.id);
                                        const streaks = calculateStreak(habit.id);
                                        return (
                                          <div key={habit.id} className="bg-gray-700/50 rounded-lg p-3 hover:bg-gray-700/70 transition-colors">
                                            <div className="flex items-center justify-between mb-2">
                                              <span className="text-white text-sm font-medium">{habit.name}</span>
                                              <span className="text-white text-sm font-bold">{percentage}%</span>
                                            </div>
                                            <div className="w-full bg-gray-600 rounded-full h-2 mb-2">
                                              <div 
                                                className="h-2 rounded-full transition-all duration-500" 
                                                style={{ 
                                                  width: `${percentage}%`, 
                                                  backgroundColor: autoColors[index % autoColors.length].base 
                                                }} 
                                              />
                                            </div>
                                            <div className="flex items-center justify-between text-xs text-gray-400">
                                              <span>{priorities.find(p => p.value === habit.priority)?.flag} {priorities.find(p => p.value === habit.priority)?.label}</span>
                                              <div className="flex items-center gap-2">
                                                {streaks.current > 0 && (
                                                  <span className="flex items-center gap-1 bg-orange-500/20 px-2 py-1 rounded-full">
                                                    <Flame className="w-3 h-3 text-orange-400" />
                                                    <span className="text-orange-400 font-bold">{streaks.current}</span>
                                                  </span>
                                                )}
                                                {streaks.best > 3 && (
                                                  <span className="flex items-center gap-1 bg-yellow-500/20 px-2 py-1 rounded-full">
                                                    <Trophy className="w-3 h-3 text-yellow-400" />
                                                    <span className="text-yellow-400 font-bold">{streaks.best}</span>
                                                  </span>
                                                )}
                                              </div>
                                            </div>
                                          </div>
                                        );
                                      })}
                                    </div>
                                  </div>

                                  <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-600">
                                    <h5 className="font-semibold text-white mb-3 flex items-center gap-2">
                                      <Calendar className="w-4 h-4 text-blue-400" />
                                      Resumo do MÃªs
                                    </h5>
                                    <div className="grid grid-cols-2 gap-3 text-sm">
                                      {[
                                        { label: 'Progresso', value: `${stats.overall}%`, color: 'text-blue-400', icon: 'ðŸ“Š' },
                                        { label: 'ConcluÃ­das/Total', value: `${stats.completed}/${stats.total}`, color: 'text-green-400', icon: 'âœ…' },
                                        { label: 'Taxa de Sucesso', value: `${stats.overall}%`, color: 'text-purple-400', icon: 'ðŸŽ¯' },
                                        { label: 'HÃ¡bitos Ativos', value: filteredHabits.length, color: 'text-orange-400', icon: 'âš¡' }
                                      ].map(({ label, value, color, icon }, i) => (
                                        <div key={i} className="bg-gray-700/50 rounded-lg p-3 hover:bg-gray-700/70 transition-colors">
                                          <div className="flex items-center gap-2 mb-1">
                                            <span>{icon}</span>
                                            <span className="text-gray-300 text-xs">{label}</span>
                                          </div>
                                          <div className={`text-lg font-bold ${color}`}>{value}</div>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                </div>
                              </div>
                            </div>

                            <button 
                              onClick={() => {
                                if (window.confirm('âš ï¸ ATENÃ‡ÃƒO: Esta aÃ§Ã£o irÃ¡ apagar TODOS os hÃ¡bitos, progresso e observaÃ§Ãµes permanentemente. Esta aÃ§Ã£o nÃ£o pode ser desfeita. Tem certeza que deseja continuar?')) {
                                  clearAllData();
                                }
                              }} 
                              className="w-full flex items-center justify-center gap-2 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105 border-2 border-red-500"
                              disabled={resetStatus !== ''}
                            >
                              <Trash2 className="w-4 h-4" />
                              {resetStatus || 'Limpar Tudo (Reset Completo)'}
                            </button>
                            
                            {resetStatus && (
                              <div className={`text-center text-sm font-medium ${
                                resetStatus.includes('âœ…') ? 'text-green-400' : 
                                resetStatus.includes('âŒ') ? 'text-red-400' : 
                                'text-yellow-400'
                              }`}>
                                {resetStatus}
                              </div>
                            )}
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
                
              </div>
            </div>
          );
        };

        // Renderizar aplicaÃ§Ã£o
        ReactDOM.render(<CircularHabitCalendar />, document.getElementById('root'));
    </script>
</body>
</html>
