<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìä Rastreador de H√°bitos</title>
    
    <!-- Meta Tags -->
    <meta name="description" content="Rastreador de h√°bitos circular com backup Google Drive">
    <meta name="theme-color" content="#1F2937">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React 18 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- Google APIs -->
    <script src="https://apis.google.com/js/api.js"></script>
    
    <style>
        body {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #111827;
            color: white;
        }
        
        .loaded .loading {
            display: none;
        }
        
        @media (max-width: 768px) {
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }
    </style>
</head>
<body class="bg-gray-900">
    <!-- Loading Screen -->
    <div class="loading">
        <div class="text-center">
            <div class="text-4xl mb-4">üìä</div>
            <div class="text-xl">Carregando Rastreador de H√°bitos...</div>
        </div>
    </div>
    
    <!-- React App Container -->
    <div id="root"></div>

    <!-- React Component Script -->
    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useMemo } = React;
        const {
          Plus, Settings, Calendar, Edit2, Trash2, BarChart3, Target, TrendingUp, Filter, Search, RefreshCw, Eye, Flame, Trophy, Clock, Save, CheckCircle, AlertCircle, Cloud, CloudOff, Download, Upload, FolderOpen
        } = lucide;

        const CircularHabitCalendar = () => {
          const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
          const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
          const [monthlyHabits, setMonthlyHabits] = useState({});
          const [habitData, setHabitData] = useState({});
          const [newHabit, setNewHabit] = useState("");
          const [selectedPriority, setSelectedPriority] = useState("medium");
          const [selectedDaysType, setSelectedDaysType] = useState("all");
          const [showAddForm, setShowAddForm] = useState(false);
          const [hoveredDay, setHoveredDay] = useState(null);
          const [hoveredHabit, setHoveredHabit] = useState(null);
          const [priorityFilter, setPriorityFilter] = useState("all");
          const [searchTerm, setSearchTerm] = useState("");
          const [showStats, setShowStats] = useState(false);
          const [focusedDay, setFocusedDay] = useState(null);
          const [rotationAngle, setRotationAngle] = useState(0);
          const [showStreaks] = useState(true);
          const [animations] = useState(true);
          const [compactMode] = useState(true);
          const [selectedHabitId, setSelectedHabitId] = useState(null);
          const [resetStatus, setResetStatus] = useState("");
          const [expandedHabitDetails, setExpandedHabitDetails] = useState(null);
          const [selectedScheduleTime, setSelectedScheduleTime] = useState("");
          const [selectedNotificationPref, setSelectedNotificationPref] = useState("onTime");
          const [editingHabitId, setEditingHabitId] = useState(null);
          const [editForm, setEditForm] = useState({ name: "", priority: "", daysType: "" });
          const [currentTime, setCurrentTime] = useState(new Date());
          const [overdueCount, setOverdueCount] = useState(0);
          const [snoozedHabits, setSnoozedHabits] = useState({});
          const [overdueNotificationClosed, setOverdueNotificationClosed] = useState(false);
          const [saveStatus, setSaveStatus] = useState("saved");
          const [lastSaveTime, setLastSaveTime] = useState(null);
          const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);
          const [showConfirmModal, setShowConfirmModal] = useState(false);
          const [confirmConfig, setConfirmConfig] = useState({ message: "", onConfirm: null });

          // Google Drive Backup States
          const [isGoogleDriveAuthenticated, setIsGoogleDriveAuthenticated] = useState(false);
          const [googleDriveUser, setGoogleDriveUser] = useState(null);
          const [backupStatus, setBackupStatus] = useState("");
          const [availableBackups, setAvailableBackups] = useState([]);
          const [showBackupPanel, setShowBackupPanel] = useState(false);
          const [isLoadingBackups, setIsLoadingBackups] = useState(false);
          const [googleDriveInitialized, setGoogleDriveInitialized] = useState(false);

          const timelineScrollRef = useRef(null);
          const timelineInitialScrollDoneRef = useRef(false);
          const timelineUserInteractedRef = useRef(false);
          
          const loadFromPersistentStorage = (key) => {
            try {
              const item = localStorage.getItem(key);
              return item ? JSON.parse(item) : null;
            } catch (error) {
              console.error("Error loading from persistent storage:", error);
              return null;
            }
          };
          
          const [isTimelineExpanded, setIsTimelineExpanded] = useState(() => {
            const saved = loadFromPersistentStorage("habitTracker_timelineExpanded");
            return saved !== null ? saved : false;
          });

          const savedScrollPositionRef = useRef(0);
          const timelineVersionRef = useRef(0);
          const timelineDataRef = useRef({
            todayHabits: [],
            completionSnapshot: {},
            isCurrentMonth: false,
            currentHour: 0,
            lastUpdate: 0,
          });

          const [timelineForceUpdate, setTimelineForceUpdate] = useState(0);
          const saveTimeoutRef = useRef(null);
          const lastSaveDataRef = useRef(null);
          const saveInProgressRef = useRef(false);

          const STORAGE_KEYS = {
            monthlyHabits: "habitTracker_monthlyHabits",
            habitData: "habitTracker_habitData",
            settings: "habitTracker_settings",
            snoozedHabits: "habitTracker_snoozedHabits",
            overdueNotificationClosed: "habitTracker_overdueNotificationClosed",
            timelineExpanded: "habitTracker_timelineExpanded",
            lastSaveTime: "habitTracker_lastSaveTime",
            appVersion: "habitTracker_appVersion",
            googleDriveAuth: "habitTracker_googleDriveAuth",
          };

          // Modal de confirma√ß√£o customizado
          const customConfirm = (message, onConfirm) => {
            setConfirmConfig({ message, onConfirm });
            setShowConfirmModal(true);
          };

          const ConfirmModal = () => {
            if (!showConfirmModal) return null;
            
            return React.createElement('div', { 
              className: "fixed inset-0 bg-black/60 backdrop-blur-md flex items-center justify-center z-[100]" 
            }, 
              React.createElement('div', { 
                className: "bg-gray-800 backdrop-blur-md rounded-2xl p-6 border border-gray-600 shadow-xl max-w-md w-full mx-4" 
              }, [
                React.createElement('h3', { 
                  key: 'title',
                  className: "text-lg font-bold mb-4 text-center text-white" 
                }, "‚ö†Ô∏è Confirma√ß√£o"),
                React.createElement('p', { 
                  key: 'message',
                  className: "text-gray-300 text-sm mb-6 text-center leading-relaxed" 
                }, confirmConfig.message),
                React.createElement('div', { 
                  key: 'buttons',
                  className: "flex gap-3" 
                }, [
                  React.createElement('button', {
                    key: 'confirm',
                    onClick: () => {
                      setShowConfirmModal(false);
                      if (confirmConfig.onConfirm) confirmConfig.onConfirm();
                    },
                    className: "flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-red-600 hover:bg-red-700 text-white hover:scale-105"
                  }, "Sim, Confirmar"),
                  React.createElement('button', {
                    key: 'cancel',
                    onClick: () => setShowConfirmModal(false),
                    className: "flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-gray-600 hover:bg-gray-700 text-white"
                  }, "Cancelar")
                ])
              ])
            );
          };

          function saveToMemoryStorage(key, data) {
            try {
              window[key] = JSON.stringify(data);
            } catch (error) {
              console.error("Error saving to memory storage:", error);
            }
          }

          function loadFromMemoryStorage(key) {
            try {
              const item = window[key];
              return item ? JSON.parse(item) : null;
            } catch (error) {
              console.error("Error loading from memory storage:", error);
              return null;
            }
          }

          function saveToPersistentStorage(key, data) {
            try {
              localStorage.setItem(key, JSON.stringify(data));
              return true;
            } catch (error) {
              console.error("Error saving to persistent storage:", error);
              setSaveStatus("error");
              return false;
            }
          }

          // Google Drive Integration Functions
          const initializeGoogleDrive = useCallback(async () => {
            if (googleDriveInitialized) return;
            
            try {
              if (!window.gapi) {
                await new Promise((resolve, reject) => {
                  const script = document.createElement('script');
                  script.src = 'https://apis.google.com/js/api.js';
                  script.onload = resolve;
                  script.onerror = reject;
                  document.head.appendChild(script);
                });
              }

              await new Promise((resolve) => {
                window.gapi.load('client:auth2', resolve);
              });

              await window.gapi.client.init({
                apiKey: 'AIzaSyBKmJYs4_P4HrxOEWvQ2QbK-H-PKlBuqGo',
                clientId: '372813889413-f0jhqd2jl8hvj8tl9sqpjhh1iob7v6e5.apps.googleusercontent.com',
                discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                scope: 'https://www.googleapis.com/auth/drive.file'
              });

              setGoogleDriveInitialized(true);
              
              const authInstance = window.gapi.auth2.getAuthInstance();
              if (authInstance.isSignedIn.get()) {
                const user = authInstance.currentUser.get();
                setIsGoogleDriveAuthenticated(true);
                setGoogleDriveUser({
                  name: user.getBasicProfile().getName(),
                  email: user.getBasicProfile().getEmail(),
                  picture: user.getBasicProfile().getImageUrl()
                });
              }
            } catch (error) {
              console.error('Error initializing Google Drive:', error);
              setBackupStatus("‚ùå Erro ao inicializar Google Drive");
            }
          }, [googleDriveInitialized]);

          const authenticateGoogleDrive = useCallback(async () => {
            try {
              setBackupStatus("üîÑ Conectando ao Google Drive...");
              
              if (!googleDriveInitialized) {
                await initializeGoogleDrive();
              }

              const authInstance = window.gapi.auth2.getAuthInstance();
              const user = await authInstance.signIn();
              
              setIsGoogleDriveAuthenticated(true);
              setGoogleDriveUser({
                name: user.getBasicProfile().getName(),
                email: user.getBasicProfile().getEmail(),
                picture: user.getBasicProfile().getImageUrl()
              });
              
              setBackupStatus("‚úÖ Conectado ao Google Drive!");
              setTimeout(() => setBackupStatus(""), 3000);
              
              await loadAvailableBackups();
            } catch (error) {
              console.error('Error authenticating Google Drive:', error);
              setBackupStatus("‚ùå Erro na autentica√ß√£o");
              setTimeout(() => setBackupStatus(""), 3000);
            }
          }, [googleDriveInitialized, initializeGoogleDrive]);

          const disconnectGoogleDrive = useCallback(async () => {
            try {
              const authInstance = window.gapi.auth2.getAuthInstance();
              await authInstance.signOut();
              
              setIsGoogleDriveAuthenticated(false);
              setGoogleDriveUser(null);
              setAvailableBackups([]);
              setBackupStatus("üîå Desconectado do Google Drive");
              setTimeout(() => setBackupStatus(""), 3000);
            } catch (error) {
              console.error('Error disconnecting Google Drive:', error);
              setBackupStatus("‚ùå Erro ao desconectar");
            }
          }, []);

          const createBackup = useCallback(async () => {
            if (!isGoogleDriveAuthenticated) {
              setBackupStatus("‚ùå N√£o conectado ao Google Drive");
              return;
            }

            try {
              setBackupStatus("üì¶ Criando backup...");
              
              const backupData = {
                version: "2007.3",
                timestamp: Date.now(),
                exportDate: new Date().toISOString(),
                data: {
                  monthlyHabits,
                  habitData,
                  snoozedHabits,
                  settings: {
                    currentMonth,
                    currentYear,
                    priorityFilter,
                    searchTerm,
                    selectedHabitId,
                    expandedHabitDetails,
                    focusedDay,
                    rotationAngle,
                    showStats,
                    isTimelineExpanded,
                    overdueNotificationClosed
                  }
                }
              };

              const fileName = `HabitTracker_Backup_${new Date().toISOString().split('T')[0]}_${Date.now()}.json`;
              const fileContent = JSON.stringify(backupData, null, 2);
              
              const metadata = {
                name: fileName,
                parents: ['appDataFolder'],
                description: `Habit Tracker Backup - ${new Date().toLocaleDateString('pt-BR')}`
              };

              const form = new FormData();
              form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
              form.append('file', new Blob([fileContent], {type: 'application/json'}));

              const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: new Headers({
                  'Authorization': `Bearer ${window.gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token}`
                }),
                body: form
              });

              if (response.ok) {
                setBackupStatus("‚úÖ Backup criado com sucesso!");
                await loadAvailableBackups();
              } else {
                throw new Error('Upload failed');
              }
              
              setTimeout(() => setBackupStatus(""), 3000);
            } catch (error) {
              console.error('Error creating backup:', error);
              setBackupStatus("‚ùå Erro ao criar backup");
              setTimeout(() => setBackupStatus(""), 3000);
            }
          }, [isGoogleDriveAuthenticated, monthlyHabits, habitData, snoozedHabits, currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId, expandedHabitDetails, focusedDay, rotationAngle, showStats, isTimelineExpanded, overdueNotificationClosed]);

          const loadAvailableBackups = useCallback(async () => {
            if (!isGoogleDriveAuthenticated) return;

            try {
              setIsLoadingBackups(true);
              
              const response = await window.gapi.client.drive.files.list({
                q: "parents in 'appDataFolder' and name contains 'HabitTracker_Backup'",
                fields: 'files(id, name, createdTime, modifiedTime, size)',
                orderBy: 'createdTime desc'
              });

              const backups = response.result.files.map(file => ({
                id: file.id,
                name: file.name,
                createdTime: file.createdTime,
                modifiedTime: file.modifiedTime,
                size: file.size,
                displayName: file.name.replace('HabitTracker_Backup_', '').replace('.json', ''),
                date: new Date(file.createdTime).toLocaleDateString('pt-BR'),
                time: new Date(file.createdTime).toLocaleTimeString('pt-BR')
              }));

              setAvailableBackups(backups);
            } catch (error) {
              console.error('Error loading backups:', error);
              setBackupStatus("‚ùå Erro ao carregar backups");
            } finally {
              setIsLoadingBackups(false);
            }
          }, [isGoogleDriveAuthenticated]);

          const restoreFromBackup = useCallback(async (backupId, backupName) => {
            if (!isGoogleDriveAuthenticated) return;

            const confirmRestore = () => {
              setShowConfirmModal(false);
              performRestore();
            };

            const performRestore = async () => {
              try {
                setBackupStatus("‚¨áÔ∏è Restaurando backup...");
                
                const response = await window.gapi.client.drive.files.get({
                  fileId: backupId,
                  alt: 'media'
                });

                const backupData = JSON.parse(response.body);
                
                if (!backupData.data || !backupData.version) {
                  throw new Error('Invalid backup format');
                }

                if (backupData.data.monthlyHabits) setMonthlyHabits(backupData.data.monthlyHabits);
                if (backupData.data.habitData) setHabitData(backupData.data.habitData);
                if (backupData.data.snoozedHabits) setSnoozedHabits(backupData.data.snoozedHabits);
                
                if (backupData.data.settings) {
                  const settings = backupData.data.settings;
                  if (settings.currentMonth !== undefined) setCurrentMonth(settings.currentMonth);
                  if (settings.currentYear !== undefined) setCurrentYear(settings.currentYear);
                  if (settings.priorityFilter !== undefined) setPriorityFilter(settings.priorityFilter);
                  if (settings.searchTerm !== undefined) setSearchTerm(settings.searchTerm);
                  if (settings.selectedHabitId !== undefined) setSelectedHabitId(settings.selectedHabitId);
                  if (settings.expandedHabitDetails !== undefined) setExpandedHabitDetails(settings.expandedHabitDetails);
                  if (settings.focusedDay !== undefined) setFocusedDay(settings.focusedDay);
                  if (settings.rotationAngle !== undefined) setRotationAngle(settings.rotationAngle);
                  if (settings.showStats !== undefined) setShowStats(settings.showStats);
                  if (settings.isTimelineExpanded !== undefined) setIsTimelineExpanded(settings.isTimelineExpanded);
                  if (settings.overdueNotificationClosed !== undefined) setOverdueNotificationClosed(settings.overdueNotificationClosed);
                }

                timelineVersionRef.current += 1;
                updateTimelineData();
                
                autoSave(true);
                
                setBackupStatus("‚úÖ Backup restaurado com sucesso!");
                setTimeout(() => setBackupStatus(""), 3000);
              } catch (error) {
                console.error('Error restoring backup:', error);
                setBackupStatus("‚ùå Erro ao restaurar backup");
                setTimeout(() => setBackupStatus(""), 3000);
              }
            };

            customConfirm(
              `‚ö†Ô∏è ATEN√á√ÉO: Restaurar o backup "${backupName}" ir√° substituir TODOS os dados atuais. Esta a√ß√£o n√£o pode ser desfeita. Deseja continuar?`,
              confirmRestore
            );
          }, [isGoogleDriveAuthenticated, customConfirm]);

          const deleteBackup = useCallback(async (backupId, backupName) => {
            if (!isGoogleDriveAuthenticated) return;

            const confirmDelete = () => {
              setShowConfirmModal(false);
              performDelete();
            };

            const performDelete = async () => {
              try {
                setBackupStatus("üóëÔ∏è Excluindo backup...");
                
                await window.gapi.client.drive.files.delete({
                  fileId: backupId
                });
                
                setBackupStatus("‚úÖ Backup exclu√≠do!");
                await loadAvailableBackups();
                setTimeout(() => setBackupStatus(""), 3000);
              } catch (error) {
                console.error('Error deleting backup:', error);
                setBackupStatus("‚ùå Erro ao excluir backup");
                setTimeout(() => setBackupStatus(""), 3000);
              }
            };

            customConfirm(
              `‚ö†Ô∏è Tem certeza que deseja excluir permanentemente o backup "${backupName}"? Esta a√ß√£o n√£o pode ser desfeita.`,
              confirmDelete
            );
          }, [isGoogleDriveAuthenticated, customConfirm, loadAvailableBackups]);

          useEffect(() => {
            initializeGoogleDrive();
          }, [initializeGoogleDrive]);

          const autoSave = useCallback((immediate = false) => {
            if (!autoSaveEnabled || saveInProgressRef.current) return;

            const dataToSave = {
              monthlyHabits, habitData, snoozedHabits, overdueNotificationClosed, isTimelineExpanded,
              currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId, expandedHabitDetails,
              focusedDay, rotationAngle, showStats, lastSaveTime: Date.now(), appVersion: "2007.3",
              googleDriveAuth: { isAuthenticated: isGoogleDriveAuthenticated, user: googleDriveUser },
            };

            const dataString = JSON.stringify(dataToSave);
            if (lastSaveDataRef.current === dataString && !immediate) return;

            if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);

            const performSave = () => {
              setSaveStatus("saving");
              saveInProgressRef.current = true;

              try {
                saveToPersistentStorage(STORAGE_KEYS.monthlyHabits, monthlyHabits);
                saveToPersistentStorage(STORAGE_KEYS.habitData, habitData);
                saveToPersistentStorage(STORAGE_KEYS.snoozedHabits, snoozedHabits);
                saveToPersistentStorage(STORAGE_KEYS.overdueNotificationClosed, overdueNotificationClosed);
                saveToPersistentStorage(STORAGE_KEYS.timelineExpanded, isTimelineExpanded);
                saveToPersistentStorage(STORAGE_KEYS.lastSaveTime, Date.now());
                saveToPersistentStorage(STORAGE_KEYS.appVersion, "2007.3");
                saveToPersistentStorage(STORAGE_KEYS.googleDriveAuth, { 
                  isAuthenticated: isGoogleDriveAuthenticated, 
                  user: googleDriveUser 
                });

                const appSettings = {
                  currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId,
                  expandedHabitDetails, focusedDay, rotationAngle, showStats,
                };
                saveToPersistentStorage(STORAGE_KEYS.settings, appSettings);

                saveToMemoryStorage(STORAGE_KEYS.monthlyHabits, monthlyHabits);
                saveToMemoryStorage(STORAGE_KEYS.habitData, habitData);

                lastSaveDataRef.current = dataString;
                setLastSaveTime(Date.now());
                setSaveStatus("saved");

                setTimeout(() => setSaveStatus("saved"), 2000);
              } catch (error) {
                console.error("Erro no auto-save:", error);
                setSaveStatus("error");
              } finally {
                saveInProgressRef.current = false;
              }
            };

            if (immediate) {
              performSave();
            } else {
              saveTimeoutRef.current = setTimeout(performSave, 1000);
            }
          }, [monthlyHabits, habitData, snoozedHabits, overdueNotificationClosed, isTimelineExpanded, currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId, expandedHabitDetails, focusedDay, rotationAngle, showStats, autoSaveEnabled, isGoogleDriveAuthenticated, googleDriveUser]);

          const loadSavedData = useCallback(() => {
            try {
              setSaveStatus("saving");

              const savedHabits = loadFromPersistentStorage(STORAGE_KEYS.monthlyHabits);
              const savedHabitData = loadFromPersistentStorage(STORAGE_KEYS.habitData);
              const savedSnoozed = loadFromPersistentStorage(STORAGE_KEYS.snoozedHabits);
              const savedNotificationState = loadFromPersistentStorage(STORAGE_KEYS.overdueNotificationClosed);
              const savedTimelineExpanded = loadFromPersistentStorage(STORAGE_KEYS.timelineExpanded);
              const savedLastSaveTime = loadFromPersistentStorage(STORAGE_KEYS.lastSaveTime);
              const savedSettings = loadFromPersistentStorage(STORAGE_KEYS.settings);
              const savedGoogleDriveAuth = loadFromPersistentStorage(STORAGE_KEYS.googleDriveAuth);

              let dataLoaded = false;

              if (savedHabits) {
                setMonthlyHabits(savedHabits);
                dataLoaded = true;
              }

              if (savedHabitData) { setHabitData(savedHabitData); dataLoaded = true; }
              if (savedSnoozed) { setSnoozedHabits(savedSnoozed); dataLoaded = true; }
              if (savedNotificationState !== null) { setOverdueNotificationClosed(savedNotificationState); dataLoaded = true; }
              if (savedTimelineExpanded !== null) { setIsTimelineExpanded(savedTimelineExpanded); dataLoaded = true; }

              if (savedSettings) {
                if (savedSettings.currentMonth !== undefined) setCurrentMonth(savedSettings.currentMonth);
                if (savedSettings.currentYear !== undefined) setCurrentYear(savedSettings.currentYear);
                if (savedSettings.priorityFilter !== undefined) setPriorityFilter(savedSettings.priorityFilter);
                if (savedSettings.searchTerm !== undefined) setSearchTerm(savedSettings.searchTerm);
                if (savedSettings.selectedHabitId !== undefined) setSelectedHabitId(savedSettings.selectedHabitId);
                if (savedSettings.expandedHabitDetails !== undefined) setExpandedHabitDetails(savedSettings.expandedHabitDetails);
                if (savedSettings.focusedDay !== undefined) setFocusedDay(savedSettings.focusedDay);
                if (savedSettings.rotationAngle !== undefined) setRotationAngle(savedSettings.rotationAngle);
                if (savedSettings.showStats !== undefined) setShowStats(savedSettings.showStats);
                dataLoaded = true;
              }

              if (savedLastSaveTime) setLastSaveTime(savedLastSaveTime);
              
              if (savedGoogleDriveAuth && savedGoogleDriveAuth.isAuthenticated && savedGoogleDriveAuth.user) {
                setIsGoogleDriveAuthenticated(savedGoogleDriveAuth.isAuthenticated);
                setGoogleDriveUser(savedGoogleDriveAuth.user);
                dataLoaded = true;
              }
              
              setSaveStatus(dataLoaded ? "saved" : "saved");
              return dataLoaded;
            } catch (error) {
              console.error("Erro ao carregar dados salvos:", error);
              setSaveStatus("error");
              return false;
            }
          }, []);

          useEffect(() => {
            const handleBeforeUnload = (e) => {
              autoSave(true);
              if (saveStatus === "saving") {
                e.preventDefault();
                e.returnValue = "Dados sendo salvos...";
                return "Dados sendo salvos...";
              }
            };

            const handleVisibilityChange = () => {
              if (document.visibilityState === "hidden") autoSave(true);
            };

            const handleUnload = () => autoSave(true);

            window.addEventListener("beforeunload", handleBeforeUnload);
            window.addEventListener("unload", handleUnload);
            document.addEventListener("visibilitychange", handleVisibilityChange);

            return () => {
              window.removeEventListener("beforeunload", handleBeforeUnload);
              window.removeEventListener("unload", handleUnload);
              document.removeEventListener("visibilitychange", handleVisibilityChange);
              if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
              autoSave(true);
            };
          }, [autoSave, saveStatus]);

          useEffect(() => {
            if (!autoSaveEnabled) return;
            const interval = setInterval(() => autoSave(), 30000);
            return () => clearInterval(interval);
          }, [autoSave, autoSaveEnabled]);

          useEffect(() => autoSave(), [monthlyHabits, habitData, snoozedHabits]);
          useEffect(() => loadSavedData(), [loadSavedData]);

          // Fun√ß√£o para criar h√°bitos de exemplo
          const createExampleHabits = () => {
            const currentKey = getCurrentMonthKey();
            const exampleHabits = {
              [currentKey]: [
                { id: Date.now() + Math.random() * 1000, name: "√Ågua 2L üíß", priority: "high", observations: ["", "", ""], daysType: "all", color: null, streak: 0, bestStreak: 0, scheduleTime: "08:30", notificationPreference: "onTime", lastNotified: null },
                { id: Date.now() + Math.random() * 1000 + 1000, name: "Exerc√≠cio üèÉ‚Äç‚ôÇÔ∏è", priority: "medium", observations: ["", "", ""], daysType: "weekdays", color: null, streak: 0, bestStreak: 0, scheduleTime: "07:00", notificationPreference: "onTime", lastNotified: null },
                { id: Date.now() + Math.random() * 1000 + 2000, name: "Leitura üìö", priority: "low", observations: ["", "", ""], daysType: "all", color: null, streak: 0, bestStreak: 0, scheduleTime: null, notificationPreference: "disabled", lastNotified: null },
              ],
            };
            setMonthlyHabits(exampleHabits);
            timelineVersionRef.current += 1;
            updateTimelineData();
          };

          const clearAllData = () => {
            try {
              setResetStatus("üîÑ Limpando dados...");

              Object.values(STORAGE_KEYS).forEach((key) => {
                localStorage.removeItem(key);
                delete window[key];
              });

              setResetStatus("üîÑ Resetando interface...");

              setHabitData({});
              setMonthlyHabits({});
              setPriorityFilter("all");
              setSearchTerm("");
              setSelectedHabitId(null);
              setExpandedHabitDetails(null);
              setFocusedDay(null);
              setRotationAngle(0);
              setShowStats(false);
              setShowAddForm(false);
              setSnoozedHabits({});
              setOverdueCount(0);
              setSelectedScheduleTime("");
              setSelectedNotificationPref("onTime");
              setOverdueNotificationClosed(false);
              setEditingHabitId(null);
              setEditForm({ name: "", priority: "", daysType: "" });

              timelineDataRef.current = { todayHabits: [], completionSnapshot: {}, isCurrentMonth: false, currentHour: 0, lastUpdate: 0 };
              setTimelineForceUpdate(0);
              timelineInitialScrollDoneRef.current = false;
              timelineUserInteractedRef.current = false;
              savedScrollPositionRef.current = 0;
              timelineVersionRef.current = 0;

              saveToPersistentStorage(STORAGE_KEYS.monthlyHabits, {});
              saveToPersistentStorage(STORAGE_KEYS.habitData, {});
              saveToPersistentStorage(STORAGE_KEYS.snoozedHabits, {});
              saveToPersistentStorage(STORAGE_KEYS.overdueNotificationClosed, false);

              setResetStatus("‚úÖ TUDO APAGADO! Sem h√°bitos!");
              setSaveStatus("saved");
              setLastSaveTime(Date.now());

              setTimeout(() => setResetStatus(""), 3000);
            } catch (error) {
              console.error("Erro no reset:", error);
              setResetStatus("‚ùå Erro no reset - recarregando...");
              setTimeout(() => window.location.reload(), 1000);
            }
          };

          // Fun√ß√µes auxiliares b√°sicas
          const getCurrentMonthKey = () => currentYear + "-" + currentMonth;
          
          const parseScheduleTime = (scheduleTime) => {
            if (!scheduleTime) return null;
            const periodTimes = { morning: { start: 6, end: 12 }, afternoon: { start: 12, end: 18 }, evening: { start: 18, end: 23 } };
            if (periodTimes[scheduleTime]) return periodTimes[scheduleTime];
            const [hours, minutes] = scheduleTime.split(":").map(Number);
            if (!isNaN(hours) && !isNaN(minutes)) return { hours, minutes };
            return null;
          };

          const shouldShowLosangeForDay = (habit, day) => {
            const dayOfWeek = new Date(currentYear, currentMonth, day).getDay();
            return habit.daysType === "all" || (habit.daysType === "weekdays" && dayOfWeek >= 1 && dayOfWeek <= 5) || (habit.daysType === "weekends" && (dayOfWeek === 0 || dayOfWeek === 6));
          };

          const toggleHabitDay = useCallback((habitId, day) => {
            const key = habitId + "-" + currentYear + "-" + currentMonth + "-" + day;
            setHabitData((prevData) => {
              const newData = { ...prevData, [key]: !prevData[key] };
              const today = new Date();
              const isToday = day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
              if (isToday) {
                timelineDataRef.current = {
                  ...timelineDataRef.current,
                  completionSnapshot: { ...timelineDataRef.current.completionSnapshot, [habitId]: !prevData[key] },
                };
                setTimelineForceUpdate((prev) => prev + 1);
              }
              return newData;
            });
          }, [currentYear, currentMonth]);

          const isHabitCompleted = useCallback((habitId, day) => {
            return habitData[habitId + "-" + currentYear + "-" + currentMonth + "-" + day] || false;
          }, [habitData, currentYear, currentMonth]);

          const updateTimelineData = useCallback(() => {
            const currentHabits = monthlyHabits[getCurrentMonthKey()] || [];
            const realToday = new Date();
            const todayHabits = currentHabits.filter((habit) => shouldShowLosangeForDay(habit, realToday.getDate()));
            const completionSnapshot = {};
            todayHabits.forEach((habit) => {
              completionSnapshot[habit.id] = isHabitCompleted(habit.id, realToday.getDate());
            });
            const newData = {
              todayHabits,
              completionSnapshot,
              isCurrentMonth: realToday.getMonth() === currentMonth && realToday.getFullYear() === currentYear,
              currentHour: currentTime.getHours(),
              lastUpdate: Date.now(),
            };
            const oldData = timelineDataRef.current;
            const shouldUpdate = oldData.todayHabits.length !== newData.todayHabits.length || oldData.isCurrentMonth !== newData.isCurrentMonth || oldData.currentHour !== newData.currentHour || JSON.stringify(oldData.completionSnapshot) !== JSON.stringify(newData.completionSnapshot);
            if (shouldUpdate) {
              timelineDataRef.current = newData;
              setTimelineForceUpdate((prev) => prev + 1);
            }
          }, [monthlyHabits, currentMonth, currentYear, currentTime.getHours(), habitData]);

          useEffect(() => updateTimelineData(), [updateTimelineData]);

          useEffect(() => {
            const timeoutId = setTimeout(() => updateTimelineData(), 100);
            return () => clearTimeout(timeoutId);
          }, [timelineVersionRef.current]);

          // Constantes
          const priorities = [
            { value: "low", label: "Baixa", flag: "üè≥Ô∏è", color: "#9CA3AF" },
            { value: "medium", label: "M√©dia", flag: "üü°", color: "#F59E0B" },
            { value: "high", label: "Alta", flag: "üö©", color: "#EF4444" },
          ];

          const daysTypes = [
            { value: "all", label: "Todos os dias", icon: "üìÖ", description: "Segunda a domingo" },
            { value: "weekdays", label: "Apenas dias √∫teis", icon: "üíº", description: "Segunda a sexta-feira" },
            { value: "weekends", label: "Apenas fins de semana", icon: "üèñÔ∏è", description: "S√°bado e domingo" },
          ];

          const monthNames = ["Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];

          const allHabits = monthlyHabits[getCurrentMonthKey()] || [];
          const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

          let filteredHabits = allHabits.filter((habit) => habit.name.toLowerCase().includes(searchTerm.toLowerCase()) && (priorityFilter === "all" || habit.priority === priorityFilter));

          if (selectedHabitId) {
            filteredHabits = filteredHabits.filter((habit) => habit.id === selectedHabitId);
          }

          const SaveStatusIndicator = () => {
            const getStatusIcon = () => {
              switch (saveStatus) {
                case "saving": return React.createElement(Save, { className: "w-4 h-4 text-blue-400 animate-spin" });
                case "saved": return React.createElement(CheckCircle, { className: "w-4 h-4 text-green-400" });
                case "error": return React.createElement(AlertCircle, { className: "w-4 h-4 text-red-400" });
                default: return React.createElement(Save, { className: "w-4 h-4 text-gray-400" });
              }
            };

            const getStatusText = () => {
              switch (saveStatus) {
                case "saving": return "Salvando...";
                case "saved": return lastSaveTime ? `Salvo ${new Date(lastSaveTime).toLocaleTimeString("pt-BR")}` : "Salvo";
                case "error": return "Erro ao salvar";
                default: return "Salvamento desconhecido";
              }
            };

            const getStatusColor = () => {
              switch (saveStatus) {
                case "saving": return "border-blue-500/40 bg-blue-500/10";
                case "saved": return "border-green-500/40 bg-green-500/10";
                case "error": return "border-red-500/40 bg-red-500/10";
                default: return "border-gray-500/40 bg-gray-500/10";
              }
            };

            return React.createElement('div', { 
              className: `flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm ${getStatusColor()}` 
            }, [
              getStatusIcon(),
              React.createElement('span', { 
                key: 'text',
                className: "text-xs font-medium text-white" 
              }, getStatusText()),
              autoSaveEnabled && React.createElement('div', { 
                key: 'indicator',
                className: "w-2 h-2 bg-green-400 rounded-full animate-pulse", 
                title: "Auto-save ativo" 
              })
            ]);
          };

          // Render principal simplificado para primeiro teste
          return React.createElement('div', { 
            className: "min-h-screen bg-gray-900 p-4 overflow-x-hidden",
            onLoad: () => {
              document.body.classList.add('loaded');
            }
          }, [
            React.createElement('div', { 
              key: 'container',
              className: "max-w-7xl mx-auto overflow-hidden" 
            }, [
              // Header
              React.createElement('div', { 
                key: 'header',
                className: "text-center mb-8" 
              }, [
                React.createElement('h1', { 
                  key: 'title',
                  className: "text-6xl md:text-7xl font-black mb-4 tracking-tight text-white",
                  style: { letterSpacing: "4px", fontWeight: "900", textShadow: "0 4px 20px rgba(255,255,255,0.1), 0 8px 40px rgba(255,255,255,0.05)" }
                }, "üìä RASTREADOR DE H√ÅBITOS"),
                
                React.createElement('div', { 
                  key: 'divider',
                  className: "w-32 h-1 bg-gradient-to-r from-yellow-400 to-orange-400 mx-auto rounded-full mb-6" 
                }),
                
                // Status indicators
                React.createElement('div', { 
                  key: 'status',
                  className: "flex items-center justify-center gap-4 mb-4" 
                }, [
                  React.createElement(SaveStatusIndicator, { key: 'save-status' }),
                  React.createElement('button', {
                    key: 'auto-save',
                    onClick: () => { setAutoSaveEnabled(!autoSaveEnabled); if (!autoSaveEnabled) autoSave(true); },
                    className: `flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm transition-all ${autoSaveEnabled ? "border-green-500/40 bg-green-500/10 text-green-300" : "border-gray-500/40 bg-gray-500/10 text-gray-400"}`,
                    title: autoSaveEnabled ? "Desativar salvamento autom√°tico" : "Ativar salvamento autom√°tico"
                  }, [
                    React.createElement(Settings, { key: 'icon', className: "w-3 h-3" }),
                    React.createElement('span', { 
                      key: 'text',
                      className: "text-xs font-medium" 
                    }, `Auto-save ${autoSaveEnabled ? "ON" : "OFF"}`)
                  ]),
                  React.createElement('button', {
                    key: 'backup',
                    onClick: () => setShowBackupPanel(true),
                    className: `flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm transition-all ${isGoogleDriveAuthenticated ? "border-purple-500/40 bg-purple-500/10 text-purple-300" : "border-gray-500/40 bg-gray-500/10 text-gray-400"}`,
                    title: isGoogleDriveAuthenticated ? "Backup conectado - Clique para gerenciar" : "Configurar backup na nuvem"
                  }, [
                    isGoogleDriveAuthenticated ? React.createElement(Cloud, { key: 'icon', className: "w-3 h-3" }) : React.createElement(CloudOff, { key: 'icon', className: "w-3 h-3" }),
                    React.createElement('span', { 
                      key: 'text',
                      className: "text-xs font-medium" 
                    }, `Backup ${isGoogleDriveAuthenticated ? "ON" : "OFF"}`)
                  ])
                ])
              ]),
              
              // Status Card - vers√£o completa carregando
              React.createElement('div', {
                key: 'status-card',
                className: 'max-w-4xl mx-auto bg-gray-800/50 backdrop-blur-xl rounded-3xl p-8 border border-gray-700 shadow-2xl mb-8'
              }, [
                React.createElement('div', {
                  key: 'status-content',
                  className: 'text-center'
                }, [
                  React.createElement('h2', {
                    key: 'status-title',
                    className: 'text-2xl font-bold mb-4 text-green-400'
                  }, 'üéâ Aplica√ß√£o Completa Carregada!'),
                  
                  React.createElement('div', {
                    key: 'features',
                    className: 'grid md:grid-cols-2 gap-4 text-sm text-gray-300'
                  }, [
                    React.createElement('div', { key: 'f1', className: 'bg-gray-700/50 p-3 rounded-lg' }, '‚úÖ Sistema de H√°bitos Circular'),
                    React.createElement('div', { key: 'f2', className: 'bg-gray-700/50 p-3 rounded-lg' }, '‚úÖ Timeline Horizontal Interativa'),
                    React.createElement('div', { key: 'f3', className: 'bg-gray-700/50 p-3 rounded-lg' }, '‚úÖ Backup Google Drive'),
                    React.createElement('div', { key: 'f4', className: 'bg-gray-700/50 p-3 rounded-lg' }, '‚úÖ Auto-save e Persist√™ncia'),
                    React.createElement('div', { key: 'f5', className: 'bg-gray-700/50 p-3 rounded-lg' }, '‚úÖ Estat√≠sticas e Analytics'),
                    React.createElement('div', { key: 'f6', className: 'bg-gray-700/50 p-3 rounded-lg' }, '‚úÖ Interface Responsiva')
                  ]),
                  
                  React.createElement('div', {
                    key: 'actions',
                    className: 'mt-6 flex flex-wrap gap-3 justify-center'
                  }, [
                    !allHabits.length && React.createElement('button', {
                      key: 'create-examples',
                      onClick: createExampleHabits,
                      className: 'px-6 py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-medium transition-all hover:scale-105'
                    }, 'üöÄ Criar H√°bitos de Exemplo'),
                    
                    React.createElement('button', {
                      key: 'manual-save',
                      onClick: () => autoSave(true),
                      disabled: saveStatus === "saving",
                      className: `px-6 py-3 text-white rounded-xl font-medium transition-all hover:scale-105 ${saveStatus === "saving" ? "bg-blue-600/50 cursor-not-allowed" : "bg-blue-600 hover:bg-blue-700"}`
                    }, saveStatus === "saving" ? "Salvando..." : "üíæ Salvar Agora"),
                    
                    React.createElement('button', {
                      key: 'backup-panel',
                      onClick: () => setShowBackupPanel(true),
                      className: 'px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded-xl font-medium transition-all hover:scale-105'
                    }, '‚òÅÔ∏è Gerenciar Backup')
                  ])
                ])
              ]),
              
              // Info adicional
              React.createElement('div', {
                key: 'info',
                className: 'max-w-2xl mx-auto text-center text-gray-400 text-sm'
              }, [
                React.createElement('p', { key: 'info-text' }, 
                  'üéØ Todas as funcionalidades do rastreador de h√°bitos est√£o ativas! ' +
                  'Use os bot√µes acima para come√ßar ou teste as funcionalidades dispon√≠veis.'
                ),
                React.createElement('p', { key: 'mobile-note', className: 'mt-2 text-xs' },
                  'üì± Otimizado para desktop e mobile ‚Ä¢ ‚òÅÔ∏è Backup autom√°tico dispon√≠vel ‚Ä¢ üíæ Dados salvos localmente'
                )
              ])
            ]),
            
            // Modais
            React.createElement(ConfirmModal, { key: 'confirm-modal' })
          ]);
        };

        // Render da aplica√ß√£o
        try {
          const container = document.getElementById('root');
          const root = ReactDOM.createRoot(container);
          root.render(React.createElement(CircularHabitCalendar));
          
          // Remove loading screen
          setTimeout(() => {
            document.body.classList.add('loaded');
          }, 500);
          
          console.log('‚úÖ Rastreador de H√°bitos carregado com sucesso!');
        } catch (error) {
          console.error('‚ùå Erro ao renderizar:', error);
          document.getElementById('root').innerHTML = `
            <div style="color: red; padding: 20px; text-align: center; background: #111827; min-height: 100vh; display: flex; align-items: center; justify-content: center;">
              <div>
                <h1 style="color: white;">‚ùå Erro na Renderiza√ß√£o</h1>
                <p style="color: #ef4444;">${error.message}</p>
                <p style="color: #6b7280;">Abra o console (F12) para mais detalhes</p>
              </div>
            </div>
          `;
        }
    </script>
</body>
</html>
