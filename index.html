import React, { useState, useEffect, useCallback, useRef, useMemo } from "react";
import {
  Plus, Settings, Calendar, Edit2, Trash2, BarChart3, Target, TrendingUp, Filter, Search, RefreshCw, Eye, Flame, Trophy, Clock, Save, CheckCircle, AlertCircle, Cloud, CloudOff, Download, Upload, FolderOpen
} from "lucide-react";

const CircularHabitCalendar = () => {
  const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
  const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
  const [monthlyHabits, setMonthlyHabits] = useState({});
  const [habitData, setHabitData] = useState({});
  const [newHabit, setNewHabit] = useState("");
  const [selectedPriority, setSelectedPriority] = useState("medium");
  const [selectedDaysType, setSelectedDaysType] = useState("all");
  const [showAddForm, setShowAddForm] = useState(false);
  const [hoveredDay, setHoveredDay] = useState(null);
  const [hoveredHabit, setHoveredHabit] = useState(null);
  const [priorityFilter, setPriorityFilter] = useState("all");
  const [searchTerm, setSearchTerm] = useState("");
  const [showStats, setShowStats] = useState(false);
  const [focusedDay, setFocusedDay] = useState(null);
  const [rotationAngle, setRotationAngle] = useState(0);
  const [showStreaks] = useState(true);
  const [animations] = useState(true);
  const [compactMode] = useState(true);
  const [selectedHabitId, setSelectedHabitId] = useState(null);
  const [resetStatus, setResetStatus] = useState("");
  const [expandedHabitDetails, setExpandedHabitDetails] = useState(null);
  const [selectedScheduleTime, setSelectedScheduleTime] = useState("");
  const [selectedNotificationPref, setSelectedNotificationPref] = useState("onTime");
  const [editingHabitId, setEditingHabitId] = useState(null);
  const [editForm, setEditForm] = useState({ name: "", priority: "", daysType: "" });
  const [currentTime, setCurrentTime] = useState(new Date());
  const [overdueCount, setOverdueCount] = useState(0);
  const [snoozedHabits, setSnoozedHabits] = useState({});
  const [overdueNotificationClosed, setOverdueNotificationClosed] = useState(false);
  const [saveStatus, setSaveStatus] = useState("saved");
  const [lastSaveTime, setLastSaveTime] = useState(null);
  const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [confirmConfig, setConfirmConfig] = useState({ message: "", onConfirm: null });

  // Google Drive Backup States
  const [isGoogleDriveAuthenticated, setIsGoogleDriveAuthenticated] = useState(false);
  const [googleDriveUser, setGoogleDriveUser] = useState(null);
  const [backupStatus, setBackupStatus] = useState("");
  const [availableBackups, setAvailableBackups] = useState([]);
  const [showBackupPanel, setShowBackupPanel] = useState(false);
  const [isLoadingBackups, setIsLoadingBackups] = useState(false);
  const [googleDriveInitialized, setGoogleDriveInitialized] = useState(false);

  const timelineScrollRef = useRef(null);
  const timelineInitialScrollDoneRef = useRef(false);
  const timelineUserInteractedRef = useRef(false);
  const [isTimelineExpanded, setIsTimelineExpanded] = useState(() => {
    const saved = loadFromPersistentStorage("habitTracker_timelineExpanded");
    return saved !== null ? saved : false;
  });

  const savedScrollPositionRef = useRef(0);
  const timelineVersionRef = useRef(0);
  const timelineDataRef = useRef({
    todayHabits: [],
    completionSnapshot: {},
    isCurrentMonth: false,
    currentHour: 0,
    lastUpdate: 0,
  });

  const [timelineForceUpdate, setTimelineForceUpdate] = useState(0);
  const saveTimeoutRef = useRef(null);
  const lastSaveDataRef = useRef(null);
  const saveInProgressRef = useRef(false);

  const STORAGE_KEYS = {
    monthlyHabits: "habitTracker_monthlyHabits",
    habitData: "habitTracker_habitData",
    settings: "habitTracker_settings",
    snoozedHabits: "habitTracker_snoozedHabits",
    overdueNotificationClosed: "habitTracker_overdueNotificationClosed",
    timelineExpanded: "habitTracker_timelineExpanded",
    lastSaveTime: "habitTracker_lastSaveTime",
    appVersion: "habitTracker_appVersion",
    googleDriveAuth: "habitTracker_googleDriveAuth",
  };

  // Fontes removidas devido a CSP - usando fontes do sistema

  // Modal de confirma√ß√£o customizado (substitui window.confirm)
  const customConfirm = (message, onConfirm) => {
    setConfirmConfig({ message, onConfirm });
    setShowConfirmModal(true);
  };

  const ConfirmModal = () => {
    if (!showConfirmModal) return null;
    
    return (
      <div className="fixed inset-0 bg-black/60 backdrop-blur-md flex items-center justify-center z-[100]">
        <div className="bg-gray-800 backdrop-blur-md rounded-2xl p-6 border border-gray-600 shadow-xl max-w-md w-full mx-4">
          <h3 className="text-lg font-bold mb-4 text-center text-white">‚ö†Ô∏è Confirma√ß√£o</h3>
          <p className="text-gray-300 text-sm mb-6 text-center leading-relaxed">{confirmConfig.message}</p>
          <div className="flex gap-3">
            <button
              onClick={() => {
                setShowConfirmModal(false);
                if (confirmConfig.onConfirm) confirmConfig.onConfirm();
              }}
              className="flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-red-600 hover:bg-red-700 text-white hover:scale-105"
            >
              Sim, Confirmar
            </button>
            <button
              onClick={() => setShowConfirmModal(false)}
              className="flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-gray-600 hover:bg-gray-700 text-white"
            >
              Cancelar
            </button>
          </div>
        </div>
      </div>
    );
  };

  function saveToMemoryStorage(key, data) {
    try {
      window[key] = JSON.stringify(data);
    } catch (error) {
      console.error("Error saving to memory storage:", error);
    }
  }

  function loadFromMemoryStorage(key) {
    try {
      const item = window[key];
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error("Error loading from memory storage:", error);
      return null;
    }
  }

  function saveToPersistentStorage(key, data) {
    try {
      localStorage.setItem(key, JSON.stringify(data));
      return true;
    } catch (error) {
      console.error("Error saving to persistent storage:", error);
      setSaveStatus("error");
      return false;
    }
  }

  function loadFromPersistentStorage(key) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error("Error loading from persistent storage:", error);
      return null;
    }
  }

  // Google Drive Integration Functions
  const initializeGoogleDrive = useCallback(async () => {
    if (googleDriveInitialized) return;
    
    try {
      // Load Google API script
      if (!window.gapi) {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://apis.google.com/js/api.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      // Initialize Google API
      await new Promise((resolve) => {
        window.gapi.load('client:auth2', resolve);
      });

      await window.gapi.client.init({
        apiKey: 'AIzaSyBKmJYs4_P4HrxOEWvQ2QbK-H-PKlBuqGo', // Public API key for Google Drive
        clientId: '372813889413-f0jhqd2jl8hvj8tl9sqpjhh1iob7v6e5.apps.googleusercontent.com', // Example client ID
        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
        scope: 'https://www.googleapis.com/auth/drive.file'
      });

      setGoogleDriveInitialized(true);
      
      // Check if user is already signed in
      const authInstance = window.gapi.auth2.getAuthInstance();
      if (authInstance.isSignedIn.get()) {
        const user = authInstance.currentUser.get();
        setIsGoogleDriveAuthenticated(true);
        setGoogleDriveUser({
          name: user.getBasicProfile().getName(),
          email: user.getBasicProfile().getEmail(),
          picture: user.getBasicProfile().getImageUrl()
        });
      }
    } catch (error) {
      console.error('Error initializing Google Drive:', error);
      setBackupStatus("‚ùå Erro ao inicializar Google Drive");
    }
  }, [googleDriveInitialized]);

  const authenticateGoogleDrive = useCallback(async () => {
    try {
      setBackupStatus("üîÑ Conectando ao Google Drive...");
      
      if (!googleDriveInitialized) {
        await initializeGoogleDrive();
      }

      const authInstance = window.gapi.auth2.getAuthInstance();
      const user = await authInstance.signIn();
      
      setIsGoogleDriveAuthenticated(true);
      setGoogleDriveUser({
        name: user.getBasicProfile().getName(),
        email: user.getBasicProfile().getEmail(),
        picture: user.getBasicProfile().getImageUrl()
      });
      
      setBackupStatus("‚úÖ Conectado ao Google Drive!");
      setTimeout(() => setBackupStatus(""), 3000);
      
      // Load available backups
      await loadAvailableBackups();
    } catch (error) {
      console.error('Error authenticating Google Drive:', error);
      setBackupStatus("‚ùå Erro na autentica√ß√£o");
      setTimeout(() => setBackupStatus(""), 3000);
    }
  }, [googleDriveInitialized, initializeGoogleDrive]);

  const disconnectGoogleDrive = useCallback(async () => {
    try {
      const authInstance = window.gapi.auth2.getAuthInstance();
      await authInstance.signOut();
      
      setIsGoogleDriveAuthenticated(false);
      setGoogleDriveUser(null);
      setAvailableBackups([]);
      setBackupStatus("üîå Desconectado do Google Drive");
      setTimeout(() => setBackupStatus(""), 3000);
    } catch (error) {
      console.error('Error disconnecting Google Drive:', error);
      setBackupStatus("‚ùå Erro ao desconectar");
    }
  }, []);

  const createBackup = useCallback(async () => {
    if (!isGoogleDriveAuthenticated) {
      setBackupStatus("‚ùå N√£o conectado ao Google Drive");
      return;
    }

    try {
      setBackupStatus("üì¶ Criando backup...");
      
      // Prepare backup data
      const backupData = {
        version: "2007.3",
        timestamp: Date.now(),
        exportDate: new Date().toISOString(),
        data: {
          monthlyHabits,
          habitData,
          snoozedHabits,
          settings: {
            currentMonth,
            currentYear,
            priorityFilter,
            searchTerm,
            selectedHabitId,
            expandedHabitDetails,
            focusedDay,
            rotationAngle,
            showStats,
            isTimelineExpanded,
            overdueNotificationClosed
          }
        }
      };

      const fileName = `HabitTracker_Backup_${new Date().toISOString().split('T')[0]}_${Date.now()}.json`;
      const fileContent = JSON.stringify(backupData, null, 2);
      
      // Create file metadata
      const metadata = {
        name: fileName,
        parents: ['appDataFolder'], // Store in app data folder
        description: `Habit Tracker Backup - ${new Date().toLocaleDateString('pt-BR')}`
      };

      // Upload file to Google Drive
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
      form.append('file', new Blob([fileContent], {type: 'application/json'}));

      const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
        method: 'POST',
        headers: new Headers({
          'Authorization': `Bearer ${window.gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token}`
        }),
        body: form
      });

      if (response.ok) {
        setBackupStatus("‚úÖ Backup criado com sucesso!");
        await loadAvailableBackups(); // Refresh backup list
      } else {
        throw new Error('Upload failed');
      }
      
      setTimeout(() => setBackupStatus(""), 3000);
    } catch (error) {
      console.error('Error creating backup:', error);
      setBackupStatus("‚ùå Erro ao criar backup");
      setTimeout(() => setBackupStatus(""), 3000);
    }
  }, [isGoogleDriveAuthenticated, monthlyHabits, habitData, snoozedHabits, currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId, expandedHabitDetails, focusedDay, rotationAngle, showStats, isTimelineExpanded, overdueNotificationClosed]);

  const loadAvailableBackups = useCallback(async () => {
    if (!isGoogleDriveAuthenticated) return;

    try {
      setIsLoadingBackups(true);
      
      const response = await window.gapi.client.drive.files.list({
        q: "parents in 'appDataFolder' and name contains 'HabitTracker_Backup'",
        fields: 'files(id, name, createdTime, modifiedTime, size)',
        orderBy: 'createdTime desc'
      });

      const backups = response.result.files.map(file => ({
        id: file.id,
        name: file.name,
        createdTime: file.createdTime,
        modifiedTime: file.modifiedTime,
        size: file.size,
        displayName: file.name.replace('HabitTracker_Backup_', '').replace('.json', ''),
        date: new Date(file.createdTime).toLocaleDateString('pt-BR'),
        time: new Date(file.createdTime).toLocaleTimeString('pt-BR')
      }));

      setAvailableBackups(backups);
    } catch (error) {
      console.error('Error loading backups:', error);
      setBackupStatus("‚ùå Erro ao carregar backups");
    } finally {
      setIsLoadingBackups(false);
    }
  }, [isGoogleDriveAuthenticated]);

  const restoreFromBackup = useCallback(async (backupId, backupName) => {
    if (!isGoogleDriveAuthenticated) return;

    const confirmRestore = () => {
      setShowConfirmModal(false);
      performRestore();
    };

    const performRestore = async () => {
      try {
        setBackupStatus("‚¨áÔ∏è Restaurando backup...");
        
        // Download file from Google Drive
        const response = await window.gapi.client.drive.files.get({
          fileId: backupId,
          alt: 'media'
        });

        const backupData = JSON.parse(response.body);
        
        // Validate backup data
        if (!backupData.data || !backupData.version) {
          throw new Error('Invalid backup format');
        }

        // Restore data
        if (backupData.data.monthlyHabits) setMonthlyHabits(backupData.data.monthlyHabits);
        if (backupData.data.habitData) setHabitData(backupData.data.habitData);
        if (backupData.data.snoozedHabits) setSnoozedHabits(backupData.data.snoozedHabits);
        
        // Restore settings
        if (backupData.data.settings) {
          const settings = backupData.data.settings;
          if (settings.currentMonth !== undefined) setCurrentMonth(settings.currentMonth);
          if (settings.currentYear !== undefined) setCurrentYear(settings.currentYear);
          if (settings.priorityFilter !== undefined) setPriorityFilter(settings.priorityFilter);
          if (settings.searchTerm !== undefined) setSearchTerm(settings.searchTerm);
          if (settings.selectedHabitId !== undefined) setSelectedHabitId(settings.selectedHabitId);
          if (settings.expandedHabitDetails !== undefined) setExpandedHabitDetails(settings.expandedHabitDetails);
          if (settings.focusedDay !== undefined) setFocusedDay(settings.focusedDay);
          if (settings.rotationAngle !== undefined) setRotationAngle(settings.rotationAngle);
          if (settings.showStats !== undefined) setShowStats(settings.showStats);
          if (settings.isTimelineExpanded !== undefined) setIsTimelineExpanded(settings.isTimelineExpanded);
          if (settings.overdueNotificationClosed !== undefined) setOverdueNotificationClosed(settings.overdueNotificationClosed);
        }

        // Update timeline
        timelineVersionRef.current += 1;
        updateTimelineData();
        
        // Save restored data locally
        autoSave(true);
        
        setBackupStatus("‚úÖ Backup restaurado com sucesso!");
        setTimeout(() => setBackupStatus(""), 3000);
      } catch (error) {
        console.error('Error restoring backup:', error);
        setBackupStatus("‚ùå Erro ao restaurar backup");
        setTimeout(() => setBackupStatus(""), 3000);
      }
    };

    customConfirm(
      `‚ö†Ô∏è ATEN√á√ÉO: Restaurar o backup "${backupName}" ir√° substituir TODOS os dados atuais. Esta a√ß√£o n√£o pode ser desfeita. Deseja continuar?`,
      confirmRestore
    );
  }, [isGoogleDriveAuthenticated, customConfirm]);

  const deleteBackup = useCallback(async (backupId, backupName) => {
    if (!isGoogleDriveAuthenticated) return;

    const confirmDelete = () => {
      setShowConfirmModal(false);
      performDelete();
    };

    const performDelete = async () => {
      try {
        setBackupStatus("üóëÔ∏è Excluindo backup...");
        
        await window.gapi.client.drive.files.delete({
          fileId: backupId
        });
        
        setBackupStatus("‚úÖ Backup exclu√≠do!");
        await loadAvailableBackups(); // Refresh list
        setTimeout(() => setBackupStatus(""), 3000);
      } catch (error) {
        console.error('Error deleting backup:', error);
        setBackupStatus("‚ùå Erro ao excluir backup");
        setTimeout(() => setBackupStatus(""), 3000);
      }
    };

    customConfirm(
      `‚ö†Ô∏è Tem certeza que deseja excluir permanentemente o backup "${backupName}"? Esta a√ß√£o n√£o pode ser desfeita.`,
      confirmDelete
    );
  }, [isGoogleDriveAuthenticated, customConfirm, loadAvailableBackups]);

  // Initialize Google Drive on component mount
  useEffect(() => {
    initializeGoogleDrive();
  }, [initializeGoogleDrive]);

  const autoSave = useCallback((immediate = false) => {
    if (!autoSaveEnabled || saveInProgressRef.current) return;

    const dataToSave = {
      monthlyHabits, habitData, snoozedHabits, overdueNotificationClosed, isTimelineExpanded,
      currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId, expandedHabitDetails,
      focusedDay, rotationAngle, showStats, lastSaveTime: Date.now(), appVersion: "2007.3",
      googleDriveAuth: { isAuthenticated: isGoogleDriveAuthenticated, user: googleDriveUser },
    };

    const dataString = JSON.stringify(dataToSave);
    if (lastSaveDataRef.current === dataString && !immediate) return;

    if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);

    const performSave = () => {
      setSaveStatus("saving");
      saveInProgressRef.current = true;

      try {
        saveToPersistentStorage(STORAGE_KEYS.monthlyHabits, monthlyHabits);
        saveToPersistentStorage(STORAGE_KEYS.habitData, habitData);
        saveToPersistentStorage(STORAGE_KEYS.snoozedHabits, snoozedHabits);
        saveToPersistentStorage(STORAGE_KEYS.overdueNotificationClosed, overdueNotificationClosed);
        saveToPersistentStorage(STORAGE_KEYS.timelineExpanded, isTimelineExpanded);
        saveToPersistentStorage(STORAGE_KEYS.lastSaveTime, Date.now());
        saveToPersistentStorage(STORAGE_KEYS.appVersion, "2007.3");
        saveToPersistentStorage(STORAGE_KEYS.googleDriveAuth, { 
          isAuthenticated: isGoogleDriveAuthenticated, 
          user: googleDriveUser 
        });

        const appSettings = {
          currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId,
          expandedHabitDetails, focusedDay, rotationAngle, showStats,
        };
        saveToPersistentStorage(STORAGE_KEYS.settings, appSettings);

        saveToMemoryStorage(STORAGE_KEYS.monthlyHabits, monthlyHabits);
        saveToMemoryStorage(STORAGE_KEYS.habitData, habitData);

        lastSaveDataRef.current = dataString;
        setLastSaveTime(Date.now());
        setSaveStatus("saved");

        setTimeout(() => setSaveStatus("saved"), 2000);
      } catch (error) {
        console.error("Erro no auto-save:", error);
        setSaveStatus("error");
      } finally {
        saveInProgressRef.current = false;
      }
    };

    if (immediate) {
      performSave();
    } else {
      saveTimeoutRef.current = setTimeout(performSave, 1000);
    }
  }, [monthlyHabits, habitData, snoozedHabits, overdueNotificationClosed, isTimelineExpanded, currentMonth, currentYear, priorityFilter, searchTerm, selectedHabitId, expandedHabitDetails, focusedDay, rotationAngle, showStats, autoSaveEnabled, isGoogleDriveAuthenticated, googleDriveUser]);

  const loadSavedData = useCallback(() => {
    try {
      setSaveStatus("saving");

      const savedHabits = loadFromPersistentStorage(STORAGE_KEYS.monthlyHabits);
      const savedHabitData = loadFromPersistentStorage(STORAGE_KEYS.habitData);
      const savedSnoozed = loadFromPersistentStorage(STORAGE_KEYS.snoozedHabits);
      const savedNotificationState = loadFromPersistentStorage(STORAGE_KEYS.overdueNotificationClosed);
      const savedTimelineExpanded = loadFromPersistentStorage(STORAGE_KEYS.timelineExpanded);
      const savedLastSaveTime = loadFromPersistentStorage(STORAGE_KEYS.lastSaveTime);
      const savedSettings = loadFromPersistentStorage(STORAGE_KEYS.settings);
      const savedGoogleDriveAuth = loadFromPersistentStorage(STORAGE_KEYS.googleDriveAuth);

      let dataLoaded = false;

      if (savedHabits) {
        setMonthlyHabits(savedHabits);
        dataLoaded = true;
      }
      // Removido cria√ß√£o autom√°tica de h√°bitos padr√£o - deixar vazio se n√£o houver dados

      if (savedHabitData) { setHabitData(savedHabitData); dataLoaded = true; }
      if (savedSnoozed) { setSnoozedHabits(savedSnoozed); dataLoaded = true; }
      if (savedNotificationState !== null) { setOverdueNotificationClosed(savedNotificationState); dataLoaded = true; }
      if (savedTimelineExpanded !== null) { setIsTimelineExpanded(savedTimelineExpanded); dataLoaded = true; }

      if (savedSettings) {
        if (savedSettings.currentMonth !== undefined) setCurrentMonth(savedSettings.currentMonth);
        if (savedSettings.currentYear !== undefined) setCurrentYear(savedSettings.currentYear);
        if (savedSettings.priorityFilter !== undefined) setPriorityFilter(savedSettings.priorityFilter);
        if (savedSettings.searchTerm !== undefined) setSearchTerm(savedSettings.searchTerm);
        if (savedSettings.selectedHabitId !== undefined) setSelectedHabitId(savedSettings.selectedHabitId);
        if (savedSettings.expandedHabitDetails !== undefined) setExpandedHabitDetails(savedSettings.expandedHabitDetails);
        if (savedSettings.focusedDay !== undefined) setFocusedDay(savedSettings.focusedDay);
        if (savedSettings.rotationAngle !== undefined) setRotationAngle(savedSettings.rotationAngle);
        if (savedSettings.showStats !== undefined) setShowStats(savedSettings.showStats);
        dataLoaded = true;
      }

      if (savedLastSaveTime) setLastSaveTime(savedLastSaveTime);
      
      if (savedGoogleDriveAuth && savedGoogleDriveAuth.isAuthenticated && savedGoogleDriveAuth.user) {
        setIsGoogleDriveAuthenticated(savedGoogleDriveAuth.isAuthenticated);
        setGoogleDriveUser(savedGoogleDriveAuth.user);
        dataLoaded = true;
      }
      
      setSaveStatus(dataLoaded ? "saved" : "saved");
      return dataLoaded;
    } catch (error) {
      console.error("Erro ao carregar dados salvos:", error);
      setSaveStatus("error");
      return false;
    }
  }, []);

  useEffect(() => {
    const handleBeforeUnload = (e) => {
      autoSave(true);
      if (saveStatus === "saving") {
        e.preventDefault();
        e.returnValue = "Dados sendo salvos...";
        return "Dados sendo salvos...";
      }
    };

    const handleVisibilityChange = () => {
      if (document.visibilityState === "hidden") autoSave(true);
    };

    const handleUnload = () => autoSave(true);

    window.addEventListener("beforeunload", handleBeforeUnload);
    window.addEventListener("unload", handleUnload);
    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
      window.removeEventListener("unload", handleUnload);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
      autoSave(true);
    };
  }, [autoSave, saveStatus]);

  useEffect(() => {
    if (!autoSaveEnabled) return;
    const interval = setInterval(() => autoSave(), 30000);
    return () => clearInterval(interval);
  }, [autoSave, autoSaveEnabled]);

  useEffect(() => autoSave(), [monthlyHabits, habitData, snoozedHabits]);
  useEffect(() => loadSavedData(), [loadSavedData]);

  // Fun√ß√£o para criar h√°bitos de exemplo
  const createExampleHabits = () => {
    const currentKey = getCurrentMonthKey();
    const exampleHabits = {
      [currentKey]: [
        { id: Date.now() + Math.random() * 1000, name: "√Ågua 2L üíß", priority: "high", observations: ["", "", ""], daysType: "all", color: null, streak: 0, bestStreak: 0, scheduleTime: "08:30", notificationPreference: "onTime", lastNotified: null },
        { id: Date.now() + Math.random() * 1000 + 1000, name: "Exerc√≠cio üèÉ‚Äç‚ôÇÔ∏è", priority: "medium", observations: ["", "", ""], daysType: "weekdays", color: null, streak: 0, bestStreak: 0, scheduleTime: "07:00", notificationPreference: "onTime", lastNotified: null },
        { id: Date.now() + Math.random() * 1000 + 2000, name: "Leitura üìö", priority: "low", observations: ["", "", ""], daysType: "all", color: null, streak: 0, bestStreak: 0, scheduleTime: null, notificationPreference: "disabled", lastNotified: null },
      ],
    };
    setMonthlyHabits(exampleHabits);
    timelineVersionRef.current += 1;
    updateTimelineData();
  };

  const clearAllData = () => {
    try {
      setResetStatus("üîÑ Limpando dados...");

      // Limpar localStorage completamente
      Object.values(STORAGE_KEYS).forEach((key) => {
        localStorage.removeItem(key);
        delete window[key];
      });

      setResetStatus("üîÑ Resetando interface...");

      // RESETAR TUDO PARA VAZIO (n√£o criar h√°bitos padr√£o)
      setHabitData({});
      setMonthlyHabits({}); // VAZIO TOTAL
      setPriorityFilter("all");
      setSearchTerm("");
      setSelectedHabitId(null);
      setExpandedHabitDetails(null);
      setFocusedDay(null);
      setRotationAngle(0);
      setShowStats(false);
      setShowAddForm(false);
      setSnoozedHabits({});
      setOverdueCount(0);
      setSelectedScheduleTime("");
      setSelectedNotificationPref("onTime");
      setOverdueNotificationClosed(false);
      setEditingHabitId(null);
      setEditForm({ name: "", priority: "", daysType: "" });

      // Reset timeline data
      timelineDataRef.current = { todayHabits: [], completionSnapshot: {}, isCurrentMonth: false, currentHour: 0, lastUpdate: 0 };
      setTimelineForceUpdate(0);
      timelineInitialScrollDoneRef.current = false;
      timelineUserInteractedRef.current = false;
      savedScrollPositionRef.current = 0;
      timelineVersionRef.current = 0;

      // Salvar estado vazio
      saveToPersistentStorage(STORAGE_KEYS.monthlyHabits, {});
      saveToPersistentStorage(STORAGE_KEYS.habitData, {});
      saveToPersistentStorage(STORAGE_KEYS.snoozedHabits, {});
      saveToPersistentStorage(STORAGE_KEYS.overdueNotificationClosed, false);

      setResetStatus("‚úÖ TUDO APAGADO! Sem h√°bitos!");
      setSaveStatus("saved");
      setLastSaveTime(Date.now());

      setTimeout(() => setResetStatus(""), 3000);
    } catch (error) {
      console.error("Erro no reset:", error);
      setResetStatus("‚ùå Erro no reset - recarregando...");
      setTimeout(() => window.location.reload(), 1000);
    }
  };

  const renderTextWithLinks = (text) => {
    if (!text) return "";
    const urlRegex = /(https?:\/\/[^\s]+|www\.[^\s]+)/g;
    const parts = text.split(urlRegex);
    return parts.map((part, index) => {
      if (urlRegex.test(part)) {
        const href = part.startsWith("www.") ? `https://${part}` : part;
        return (
          <a key={index} href={href} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:text-blue-300 underline transition-colors">
            {part}
          </a>
        );
      }
      return part;
    });
  };

  const updateHabitObservation = (habitId, observationIndex, newValue) => {
    const monthKey = getCurrentMonthKey();
    const newHabits = {
      ...monthlyHabits,
      [monthKey]: (monthlyHabits[monthKey] || []).map((habit) =>
        habit.id === habitId ? {
          ...habit,
          observations: habit.observations.map((obs, idx) => idx === observationIndex ? newValue : obs),
        } : habit
      ),
    };
    setMonthlyHabits(newHabits);
  };

  const parseScheduleTime = (scheduleTime) => {
    if (!scheduleTime) return null;
    const periodTimes = { morning: { start: 6, end: 12 }, afternoon: { start: 12, end: 18 }, evening: { start: 18, end: 23 } };
    if (periodTimes[scheduleTime]) return periodTimes[scheduleTime];
    const [hours, minutes] = scheduleTime.split(":").map(Number);
    if (!isNaN(hours) && !isNaN(minutes)) return { hours, minutes };
    return null;
  };

  const getCurrentMonthKey = () => currentYear + "-" + currentMonth;

  const getHabitTimeStatus = (habit, day) => {
    if (!habit || habit.priority === "low" || !habit.scheduleTime) return "no-schedule";
    const today = new Date();
    const isToday = day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
    if (!isToday) return "future";
    const isCompleted = isHabitCompleted(habit.id, day);
    if (isCompleted) return "completed";
    const habitKey = `${habit.id}-${today.toDateString()}`;
    const snoozedUntil = snoozedHabits[habitKey];
    if (snoozedUntil && new Date(snoozedUntil) > currentTime) return "snoozed";
    const scheduleInfo = parseScheduleTime(habit.scheduleTime);
    if (!scheduleInfo) return "no-schedule";
    const now = currentTime;
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    if (scheduleInfo.start !== undefined) {
      if (currentHour < scheduleInfo.start) return "future";
      if (currentHour >= scheduleInfo.end) return "overdue";
      if (currentHour >= scheduleInfo.end - 1) return "due-soon";
      return "due-now";
    } else if (scheduleInfo.hours !== undefined && scheduleInfo.minutes !== undefined) {
      const scheduledMinutes = scheduleInfo.hours * 60 + scheduleInfo.minutes;
      const currentMinutes = currentHour * 60 + currentMinute;
      const diffMinutes = currentMinutes - scheduledMinutes;
      if (diffMinutes < -60) return "future";
      if (diffMinutes >= -15 && diffMinutes <= 15) return "due-now";
      if (diffMinutes > 15) return "overdue";
      if (diffMinutes >= -60) return "due-soon";
      return "future";
    }
    return "no-schedule";
  };

  const getTimeStatusColor = (status) => {
    switch (status) {
      case "completed": return "#10B981";
      case "due-now": return "#3B82F6";
      case "due-soon": return "#F59E0B";
      case "overdue": return "#EF4444";
      case "snoozed": return "#8B5CF6";
      case "future": return "#6B7280";
      default: return null;
    }
  };

  const snoozeHabit = (habitId, minutes) => {
    const snoozeUntil = new Date(currentTime.getTime() + minutes * 60000);
    const habitKey = `${habitId}-${new Date().toDateString()}`;
    const newSnoozedHabits = { ...snoozedHabits, [habitKey]: snoozeUntil.getTime() };
    setSnoozedHabits(newSnoozedHabits);
  };

  const shouldShowLosangeForDay = (habit, day) => {
    const dayOfWeek = new Date(currentYear, currentMonth, day).getDay();
    return habit.daysType === "all" || (habit.daysType === "weekdays" && dayOfWeek >= 1 && dayOfWeek <= 5) || (habit.daysType === "weekends" && (dayOfWeek === 0 || dayOfWeek === 6));
  };

  const updateTimelineData = useCallback(() => {
    const currentHabits = monthlyHabits[getCurrentMonthKey()] || [];
    const realToday = new Date();
    const todayHabits = currentHabits.filter((habit) => shouldShowLosangeForDay(habit, realToday.getDate()));
    const completionSnapshot = {};
    todayHabits.forEach((habit) => {
      completionSnapshot[habit.id] = isHabitCompleted(habit.id, realToday.getDate());
    });
    const newData = {
      todayHabits,
      completionSnapshot,
      isCurrentMonth: realToday.getMonth() === currentMonth && realToday.getFullYear() === currentYear,
      currentHour: currentTime.getHours(),
      lastUpdate: Date.now(),
    };
    const oldData = timelineDataRef.current;
    const shouldUpdate = oldData.todayHabits.length !== newData.todayHabits.length || oldData.isCurrentMonth !== newData.isCurrentMonth || oldData.currentHour !== newData.currentHour || JSON.stringify(oldData.completionSnapshot) !== JSON.stringify(newData.completionSnapshot);
    if (shouldUpdate) {
      timelineDataRef.current = newData;
      setTimelineForceUpdate((prev) => prev + 1);
    }
  }, [monthlyHabits, currentMonth, currentYear, currentTime.getHours(), habitData]);

  useEffect(() => updateTimelineData(), [updateTimelineData]);

  useEffect(() => {
    const timeoutId = setTimeout(() => updateTimelineData(), 100);
    return () => clearTimeout(timeoutId);
  }, [timelineVersionRef.current]);

  const toggleHabitDay = useCallback((habitId, day) => {
    const key = habitId + "-" + currentYear + "-" + currentMonth + "-" + day;
    setHabitData((prevData) => {
      const newData = { ...prevData, [key]: !prevData[key] };
      const today = new Date();
      const isToday = day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
      if (isToday) {
        timelineDataRef.current = {
          ...timelineDataRef.current,
          completionSnapshot: { ...timelineDataRef.current.completionSnapshot, [habitId]: !prevData[key] },
        };
        setTimelineForceUpdate((prev) => prev + 1);
      }
      return newData;
    });
  }, [currentYear, currentMonth]);

  const isHabitCompleted = useCallback((habitId, day) => {
    return habitData[habitId + "-" + currentYear + "-" + currentMonth + "-" + day] || false;
  }, [habitData, currentYear, currentMonth]);

  useEffect(() => {
    if (selectedPriority === "low") {
      setSelectedScheduleTime("");
      setSelectedNotificationPref("disabled");
    } else if (selectedNotificationPref === "disabled" && selectedPriority !== "low") {
      setSelectedNotificationPref("onTime");
    }
  }, [selectedPriority, selectedNotificationPref]);

  useEffect(() => {
    const updateTime = () => {
      const newTime = new Date();
      setCurrentTime(newTime);
      const today = newTime;
      let overdue = 0;
      const currentHabits = monthlyHabits[getCurrentMonthKey()] || [];
      currentHabits.forEach((habit) => {
        if (habit.priority !== "low" && habit.scheduleTime) {
          const status = getHabitTimeStatus(habit, today.getDate());
          if (status === "overdue") overdue++;
        }
      });
      setOverdueCount(overdue);
      if (overdue === 0 && overdueNotificationClosed) setOverdueNotificationClosed(false);
    };
    updateTime();
    const interval = setInterval(updateTime, 60000);
    return () => clearInterval(interval);
  }, [monthlyHabits, currentMonth, currentYear, snoozedHabits, habitData, overdueNotificationClosed]);

  const autoColors = [
    { base: "#FF0000", light: "#FF6B6B", dark: "#CC0000" },
    { base: "#00AA00", light: "#66DD66", dark: "#008800" },
    { base: "#0066FF", light: "#66AAFF", dark: "#0044CC" },
    { base: "#FFAA00", light: "#FFCC66", dark: "#DD8800" },
    { base: "#AA00AA", light: "#DD66DD", dark: "#880088" },
    { base: "#00AAAA", light: "#66DDDD", dark: "#008888" },
    { base: "#FF6600", light: "#FF9966", dark: "#CC4400" },
    { base: "#6600FF", light: "#9966FF", dark: "#4400CC" },
  ];

  const priorities = [
    { value: "low", label: "Baixa", flag: "üè≥Ô∏è", color: "#9CA3AF" },
    { value: "medium", label: "M√©dia", flag: "üü°", color: "#F59E0B" },
    { value: "high", label: "Alta", flag: "üö©", color: "#EF4444" },
  ];

  const daysTypes = [
    { value: "all", label: "Todos os dias", icon: "üìÖ", description: "Segunda a domingo" },
    { value: "weekdays", label: "Apenas dias √∫teis", icon: "üíº", description: "Segunda a sexta-feira" },
    { value: "weekends", label: "Apenas fins de semana", icon: "üèñÔ∏è", description: "S√°bado e domingo" },
  ];

  const monthNames = ["Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];

  const allHabits = monthlyHabits[getCurrentMonthKey()] || [];
  const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

  let filteredHabits = allHabits.filter((habit) => habit.name.toLowerCase().includes(searchTerm.toLowerCase()) && (priorityFilter === "all" || habit.priority === priorityFilter));

  if (selectedHabitId) {
    filteredHabits = filteredHabits.filter((habit) => habit.id === selectedHabitId);
  }

  const getDailyProgress = (day) => {
    const applicableHabits = filteredHabits.filter((habit) => shouldShowLosangeForDay(habit, day));
    if (applicableHabits.length === 0) return 0;
    const completed = applicableHabits.filter((habit) => isHabitCompleted(habit.id, day)).length;
    return (completed / applicableHabits.length) * 100;
  };

  const getCompletionPercentage = (habitId) => {
    const habit = allHabits.find((h) => h.id === habitId);
    if (!habit) return 0;
    let completed = 0, applicable = 0;
    for (let day = 1; day <= daysInMonth; day++) {
      if (shouldShowLosangeForDay(habit, day)) {
        applicable++;
        if (isHabitCompleted(habitId, day)) completed++;
      }
    }
    return applicable > 0 ? Math.round((completed / applicable) * 100) : 0;
  };

  const getMonthlyStats = () => {
    let totalPossible = 0, totalCompleted = 0;
    filteredHabits.forEach((habit) => {
      for (let day = 1; day <= daysInMonth; day++) {
        if (shouldShowLosangeForDay(habit, day)) {
          totalPossible++;
          if (isHabitCompleted(habit.id, day)) totalCompleted++;
        }
      }
    });
    return {
      overall: totalPossible > 0 ? Math.round((totalCompleted / totalPossible) * 100) : 0,
      completed: totalCompleted,
      total: totalPossible,
    };
  };

  const addNewHabit = () => {
    if (newHabit.trim()) {
      const monthKey = getCurrentMonthKey();
      const newHabits = {
        ...monthlyHabits,
        [monthKey]: [
          ...(monthlyHabits[monthKey] || []),
          {
            id: Date.now(),
            name: newHabit.trim(),
            priority: selectedPriority,
            daysType: selectedDaysType,
            observations: ["", "", ""],
            streak: 0,
            bestStreak: 0,
            scheduleTime: selectedPriority === "low" ? null : selectedScheduleTime || null,
            notificationPreference: selectedPriority === "low" ? "disabled" : selectedNotificationPref,
            lastNotified: null,
          },
        ],
      };

      setMonthlyHabits(newHabits);
      timelineVersionRef.current += 1;
      updateTimelineData();

      setSelectedHabitId(null);
      setPriorityFilter("all");
      setSearchTerm("");
      setEditingHabitId(null);
      setEditForm({ name: "", priority: "", daysType: "" });

      setNewHabit("");
      setSelectedPriority("medium");
      setSelectedDaysType("all");
      setSelectedScheduleTime("");
      setSelectedNotificationPref("onTime");
      setShowAddForm(false);
    }
  };

  const deleteHabit = (habitId) => {
    const monthKey = getCurrentMonthKey();
    const newHabits = {
      ...monthlyHabits,
      [monthKey]: (monthlyHabits[monthKey] || []).filter((h) => h.id !== habitId),
    };
    setMonthlyHabits(newHabits);
    timelineVersionRef.current += 1;
    updateTimelineData();
  };

  const startEditingHabit = (habit) => {
    setEditingHabitId(habit.id);
    setEditForm({ name: habit.name, priority: habit.priority, daysType: habit.daysType });
  };

  const saveHabitEdit = () => {
    if (!editForm.name.trim()) return;
    const monthKey = getCurrentMonthKey();
    const newHabits = {
      ...monthlyHabits,
      [monthKey]: (monthlyHabits[monthKey] || []).map((habit) =>
        habit.id === editingHabitId ? {
          ...habit,
          name: editForm.name.trim(),
          priority: editForm.priority,
          daysType: editForm.daysType,
          scheduleTime: editForm.priority === "low" ? null : habit.scheduleTime,
          notificationPreference: editForm.priority === "low" ? "disabled" : habit.notificationPreference,
        } : habit
      ),
    };
    setMonthlyHabits(newHabits);
    timelineVersionRef.current += 1;
    updateTimelineData();
    setEditingHabitId(null);
    setEditForm({ name: "", priority: "", daysType: "" });
  };

  const cancelHabitEdit = () => {
    setEditingHabitId(null);
    setEditForm({ name: "", priority: "", daysType: "" });
  };

  const calculateStreak = useCallback((habitId) => {
    const today = new Date();
    const habit = allHabits.find((h) => h.id === habitId);
    if (!habit) return { current: 0, best: 0 };
    let currentStreak = 0, bestStreak = 0, tempStreak = 0;
    for (let i = 0; i < 365; i++) {
      const checkDate = new Date(today);
      checkDate.setDate(today.getDate() - i);
      const [day, month, year] = [checkDate.getDate(), checkDate.getMonth(), checkDate.getFullYear()];
      if (shouldShowLosangeForDay(habit, day)) {
        const key = habitId + "-" + year + "-" + month + "-" + day;
        if (habitData[key]) {
          tempStreak++;
          if (i === 0) currentStreak = tempStreak;
        } else {
          if (tempStreak > bestStreak) bestStreak = tempStreak;
          tempStreak = 0;
          if (i === 0) currentStreak = 0;
        }
      }
    }
    if (tempStreak > bestStreak) bestStreak = tempStreak;
    return { current: currentStreak, best: bestStreak };
  }, [habitData, allHabits]);

  const handleDayClick = (clickedDay) => {
    if (focusedDay === clickedDay) {
      setFocusedDay(null);
      setRotationAngle(0);
    } else {
      const anglePerDay = 270 / daysInMonth;
      const totalAngleUsed = (clickedDay - 1) * anglePerDay;
      let clickedDayAngle;
      if (totalAngleUsed < 90) clickedDayAngle = 270 + totalAngleUsed;
      else if (totalAngleUsed < 180) clickedDayAngle = totalAngleUsed - 90;
      else clickedDayAngle = 90 + (totalAngleUsed - 180);
      setFocusedDay(clickedDay);
      setRotationAngle(270 - clickedDayAngle);
    }
  };

  const handleCalendarClick = (e) => {
    if (focusedDay !== null) {
      const svg = e.currentTarget;
      const rect = svg.getBoundingClientRect();
      const svgRect = svg.viewBox.baseVal;
      const x = (e.clientX - rect.left) * (svgRect.width / rect.width);
      const y = (e.clientY - rect.top) * (svgRect.height / rect.height);
      const { svgSize } = generateCircularCalendar();
      const distance = Math.sqrt(Math.pow(x - svgSize / 2, 2) + Math.pow(y - svgSize / 2, 2));
      if (distance > svgSize / 2 - 50) {
        setFocusedDay(null);
        setRotationAngle(0);
      }
    }
  };

  const TimelineHorizontal = React.memo(() => {
    const timelineData = timelineDataRef.current;
    const [localHoveredHabit, setLocalHoveredHabit] = useState(null);
    const [hasAutoScrolled, setHasAutoScrolled] = useState(false);
    const [userHasInteracted, setUserHasInteracted] = useState(false);
    const lastScrollPosition = useRef(0);

    const timeSlots = useMemo(() => {
      const slots = [];
      for (let hour = 0; hour <= 23; hour++) {
        slots.push({ hour, minute: 0, display: `${hour.toString().padStart(2, "0")}:00` });
        if (hour < 23) {
          slots.push({ hour, minute: 30, display: `${hour.toString().padStart(2, "0")}:30` });
        }
      }
      return slots;
    }, []);

    const toggleTimeline = useCallback(() => {
      const newState = !isTimelineExpanded;
      setIsTimelineExpanded(newState);
      if (!newState) {
        setHasAutoScrolled(false);
        setUserHasInteracted(false);
        lastScrollPosition.current = 0;
      }
    }, []);

    const scrollToCurrentTime = useCallback(() => {
      if (!timelineScrollRef.current || !timelineData.isCurrentMonth) return;
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      let targetSlotIndex = -1;
      for (let i = 0; i < timeSlots.length; i++) {
        const slot = timeSlots[i];
        if (slot.hour === currentHour) {
          if (slot.minute === 0 && currentMinute < 30) {
            targetSlotIndex = i;
            break;
          } else if (slot.minute === 30 && currentMinute >= 30) {
            targetSlotIndex = i;
            break;
          }
        }
      }
      if (targetSlotIndex === -1) {
        targetSlotIndex = timeSlots.findIndex((slot) => slot.hour === currentHour);
      }
      if (targetSlotIndex >= 0) {
        const slotWidth = 68;
        const containerPadding = 16;
        const targetPosition = Math.max(0, containerPadding + targetSlotIndex * slotWidth - 200);
        timelineScrollRef.current.scrollTo({ left: targetPosition, behavior: hasAutoScrolled ? "smooth" : "auto" });
        lastScrollPosition.current = targetPosition;
        setHasAutoScrolled(true);
      }
    }, [timeSlots, timelineData.isCurrentMonth, hasAutoScrolled]);

    useEffect(() => {
      if (isTimelineExpanded && !hasAutoScrolled && timelineData.isCurrentMonth) {
        const timer = setTimeout(() => scrollToCurrentTime(), 150);
        return () => clearTimeout(timer);
      }
    }, [isTimelineExpanded, hasAutoScrolled, scrollToCurrentTime, timelineData.isCurrentMonth]);

    const preserveScrollPosition = useCallback(() => {
      if (timelineScrollRef.current && userHasInteracted) {
        lastScrollPosition.current = timelineScrollRef.current.scrollLeft;
      }
    }, [userHasInteracted]);

    const restoreScrollPosition = useCallback(() => {
      if (timelineScrollRef.current && userHasInteracted && lastScrollPosition.current > 0) {
        timelineScrollRef.current.scrollLeft = lastScrollPosition.current;
      }
    }, [userHasInteracted]);

    useEffect(() => {
      if (!timelineScrollRef.current) return;
      const markUserInteraction = () => {
        if (!userHasInteracted) setUserHasInteracted(true);
        preserveScrollPosition();
      };
      const element = timelineScrollRef.current;
      const events = ["scroll", "wheel", "touchstart", "mousedown"];
      events.forEach((event) => {
        element.addEventListener(event, markUserInteraction, { passive: true });
      });
      return () => {
        if (element) {
          events.forEach((event) => {
            element.removeEventListener(event, markUserInteraction);
          });
        }
      };
    }, [preserveScrollPosition, userHasInteracted]);

    useEffect(() => {
      if (isTimelineExpanded && userHasInteracted) {
        const timer = setTimeout(() => restoreScrollPosition(), 50);
        return () => clearTimeout(timer);
      }
    }, [restoreScrollPosition, isTimelineExpanded, userHasInteracted]);

    const scrollTimeline = useCallback((direction) => {
      if (!timelineScrollRef.current) return;
      setUserHasInteracted(true);
      const scrollAmount = 200;
      const currentScroll = timelineScrollRef.current.scrollLeft;
      const newPosition = direction === "left" ? Math.max(0, currentScroll - scrollAmount) : currentScroll + scrollAmount;
      timelineScrollRef.current.scrollTo({ left: newPosition, behavior: "smooth" });
      lastScrollPosition.current = newPosition;
    }, []);

    const scrollToTime = useCallback((targetHour) => {
      if (!timelineScrollRef.current) return;
      setUserHasInteracted(true);
      const targetSlotIndex = timeSlots.findIndex((slot) => slot.hour === targetHour && slot.minute === 0);
      if (targetSlotIndex >= 0) {
        const slotWidth = 68;
        const containerPadding = 16;
        const targetPosition = Math.max(0, containerPadding + targetSlotIndex * slotWidth - 100);
        timelineScrollRef.current.scrollTo({ left: targetPosition, behavior: "smooth" });
        lastScrollPosition.current = targetPosition;
      }
    }, [timeSlots]);

    const scrollToNow = useCallback(() => {
      setUserHasInteracted(true);
      scrollToCurrentTime();
    }, [scrollToCurrentTime]);

    const habitsByTime = useMemo(() => {
      const byTime = {};
      timelineData.todayHabits.forEach((habit) => {
        if (!habit.scheduleTime || habit.priority === "low") return;
        const scheduleInfo = parseScheduleTime(habit.scheduleTime);
        if (!scheduleInfo) return;
        let targetHour, targetMinute;
        if (scheduleInfo.start !== undefined) {
          targetHour = scheduleInfo.start;
          targetMinute = 0;
        } else if (scheduleInfo.hours !== undefined) {
          targetHour = scheduleInfo.hours;
          targetMinute = scheduleInfo.minutes;
          if (targetMinute >= 45) {
            targetHour = (targetHour + 1) % 24;
            targetMinute = 0;
          } else if (targetMinute >= 15) {
            targetMinute = 30;
          } else {
            targetMinute = 0;
          }
        }
        if (targetHour !== undefined && targetMinute !== undefined) {
          const slotKey = `${targetHour}-${targetMinute}`;
          if (!byTime[slotKey]) byTime[slotKey] = [];
          byTime[slotKey].push(habit);
        }
      });
      return byTime;
    }, [timelineData.todayHabits]);

    const getHabitStatus = useCallback((habit) => {
      const realToday = new Date();
      const status = getHabitTimeStatus(habit, realToday.getDate());
      const isCompleted = timelineData.completionSnapshot[habit.id];
      return isCompleted ? "completed" : status;
    }, [timelineData.completionSnapshot]);

    const getStatusStyling = (status) => {
      switch (status) {
        case "completed": return { bg: "bg-green-500/20 border-green-500/40", icon: "‚úì", text: "text-green-300" };
        case "due-now": return { bg: "bg-blue-500/30 border-blue-500/60 animate-pulse", icon: "‚ñ∂Ô∏è", text: "text-blue-200" };
        case "overdue": return { bg: "bg-red-500/20 border-red-500/40", icon: "‚ö†Ô∏è", text: "text-red-300" };
        case "due-soon": return { bg: "bg-yellow-500/20 border-yellow-500/40 animate-pulse", icon: "üîî", text: "text-yellow-300" };
        case "snoozed": return { bg: "bg-purple-500/20 border-purple-500/40", icon: "üò¥", text: "text-purple-300" };
        default: return { bg: "bg-gray-600/20 border-gray-600/30 border-dashed", icon: "‚è≥", text: "text-gray-400" };
      }
    };

    const handleHabitToggle = useCallback((habitId, day) => {
      preserveScrollPosition();
      const key = habitId + "-" + currentYear + "-" + currentMonth + "-" + day;
      setHabitData((prevData) => {
        const newData = { ...prevData, [key]: !prevData[key] };
        const updatedSnapshot = { ...timelineDataRef.current.completionSnapshot };
        updatedSnapshot[habitId] = !prevData[key];
        timelineDataRef.current = { ...timelineDataRef.current, completionSnapshot: updatedSnapshot };
        return newData;
      });
      setTimelineForceUpdate((prev) => prev + 1);
    }, [preserveScrollPosition, currentYear, currentMonth]);

    const flexibleHabits = timelineData.todayHabits.filter((habit) => habit.priority === "low" || !habit.scheduleTime);

    return (
      <div className="bg-gradient-to-br from-gray-800/60 to-gray-900/80 backdrop-blur-xl rounded-3xl border border-gray-700/50 shadow-2xl overflow-hidden" onClick={(e) => e.stopPropagation()}>
        <div className="relative bg-gradient-to-r from-blue-600/20 via-purple-600/20 to-cyan-600/20 p-4 border-b border-gray-700/50 cursor-pointer hover:from-blue-600/30 hover:via-purple-600/30 hover:to-cyan-600/30 transition-all duration-300" onClick={toggleTimeline}>
          <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 via-purple-500/10 to-cyan-500/10 animate-pulse"></div>
          <div className="relative z-10">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="bg-blue-500/20 p-2 rounded-lg border border-blue-500/30">
                  <Clock className="w-5 h-5 text-blue-400" />
                </div>
                <div>
                  <h3 className="text-lg font-bold text-white flex items-center gap-2">
                    Timeline do Dia
                    <div className={`transition-transform duration-200 ${isTimelineExpanded ? "rotate-180" : "rotate-0"}`}>
                      <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" className="text-blue-400">
                        <path d="M8 12L3 7h10l-5 5z" />
                      </svg>
                    </div>
                  </h3>
                  <p className="text-blue-200 text-xs">
                    {new Date().toLocaleDateString("pt-BR", { weekday: "long", day: "numeric", month: "long" })}
                  </p>
                </div>
              </div>

              <div className="flex items-center gap-2">
                {timelineData.isCurrentMonth && (
                  <div className="bg-gray-900/50 backdrop-blur-sm px-3 py-1 rounded-lg border border-gray-600/50">
                    <div className="text-lg font-mono font-bold text-white">
                      {currentTime.toLocaleTimeString("pt-BR", { hour: "2-digit", minute: "2-digit" })}
                    </div>
                  </div>
                )}

                <div className="flex items-center gap-4 text-xs bg-gray-800/30 backdrop-blur-sm rounded-full px-4 py-2 border border-gray-700/50">
                  {(() => {
                    const stats = {
                      overdue: timelineData.todayHabits.filter((h) => getHabitStatus(h) === "overdue").length,
                      upcoming: timelineData.todayHabits.filter((h) => ["due-soon", "due-now"].includes(getHabitStatus(h))).length,
                      completed: timelineData.todayHabits.filter((h) => timelineData.completionSnapshot[h.id]).length,
                    };

                    return (
                      <>
                        {stats.overdue > 0 && (
                          <span className="text-red-400 font-medium flex items-center gap-1">
                            <span className="w-2 h-2 bg-red-400 rounded-full"></span>
                            <span>{stats.overdue}</span>
                          </span>
                        )}
                        {stats.upcoming > 0 && (
                          <span className="text-yellow-400 font-medium flex items-center gap-1">
                            <span className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></span>
                            <span>{stats.upcoming}</span>
                          </span>
                        )}
                        <span className="text-green-400 font-medium flex items-center gap-1">
                          <span className="w-2 h-2 bg-green-400 rounded-full"></span>
                          <span>{stats.completed}</span>
                        </span>
                        <span className="text-blue-400 font-medium flex items-center gap-1">
                          <span className="w-2 h-2 bg-blue-400 rounded-full"></span>
                          <span>{timelineData.todayHabits.length}</span>
                        </span>
                      </>
                    );
                  })()}
                </div>
              </div>
            </div>
          </div>
        </div>

        <div className={`transition-all duration-500 ease-in-out ${isTimelineExpanded ? "max-h-[800px] opacity-100" : "max-h-0 opacity-0"} overflow-hidden`}>
          {timelineData.isCurrentMonth ? (
            <div className="p-4 w-full">
              <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
                <div className="flex items-center gap-4 flex-wrap">
                  <div className="flex items-center gap-1 bg-gray-800/50 rounded-lg p-1">
                    <button onClick={(e) => { e.stopPropagation(); scrollToTime(6); }} className="px-2 py-1 text-xs bg-gray-700/50 hover:bg-gray-600/50 rounded text-gray-300 hover:text-white transition-colors" title="Ir para Manh√£ (6h)">üåÖ</button>
                    <button onClick={(e) => { e.stopPropagation(); scrollToTime(12); }} className="px-2 py-1 text-xs bg-gray-700/50 hover:bg-gray-600/50 rounded text-gray-300 hover:text-white transition-colors" title="Ir para Tarde (12h)">‚òÄÔ∏è</button>
                    <button onClick={(e) => { e.stopPropagation(); scrollToTime(18); }} className="px-2 py-1 text-xs bg-gray-700/50 hover:bg-gray-600/50 rounded text-gray-300 hover:text-white transition-colors" title="Ir para Noite (18h)">üåô</button>
                    <button onClick={(e) => { e.stopPropagation(); scrollToNow(); }} className="px-2 py-1 text-xs bg-blue-600/50 hover:bg-blue-500/50 rounded text-blue-200 hover:text-white transition-colors" title="Ir para Agora">‚è∞</button>
                  </div>

                  <div className="bg-gray-800/30 backdrop-blur-sm rounded-lg px-3 py-2 border border-gray-700/50">
                    <h4 className="text-xs font-semibold text-blue-400 mb-1.5 flex items-center gap-1">
                      <Clock className="w-3 h-3" />Status dos H√°bitos
                    </h4>
                    <div className="grid grid-cols-2 lg:grid-cols-4 gap-2 text-xs text-gray-300">
                      <div className="flex items-center gap-1">
                        <span className="w-2 h-2 bg-blue-500 rounded-full animate-pulse flex-shrink-0"></span>
                        <span className="text-blue-300">Agora</span>
                      </div>
                      <div className="flex items-center gap-1">
                        <span className="w-2 h-2 bg-orange-500 rounded-full flex-shrink-0"></span>
                        <span className="text-orange-300">Pr√≥ximo</span>
                      </div>
                      <div className="flex items-center gap-1">
                        <span className="w-2 h-2 bg-red-500 rounded-full flex-shrink-0"></span>
                        <span className="text-red-300">Atrasado</span>
                      </div>
                      <div className="flex items-center gap-1">
                        <span className="w-2 h-2 bg-green-500 rounded-full flex-shrink-0"></span>
                        <span className="text-green-300">Completo</span>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  <button onClick={(e) => { e.stopPropagation(); scrollTimeline("left"); }} className="p-2 bg-gray-700/50 hover:bg-gray-600/50 rounded-lg transition-colors text-gray-300 hover:text-white" title="Rolar para tr√°s">‚Üê</button>
                  <button onClick={(e) => { e.stopPropagation(); scrollTimeline("right"); }} className="p-2 bg-gray-700/50 hover:bg-gray-600/50 rounded-lg transition-colors text-gray-300 hover:text-white" title="Rolar para frente">‚Üí</button>
                </div>
              </div>

              <div className="relative w-full overflow-hidden">
                <div className="overflow-x-auto overflow-y-hidden rounded-2xl p-4" ref={timelineScrollRef} onScroll={preserveScrollPosition} style={{ background: "rgba(75, 85, 99, 0.1)", maxWidth: "100%", width: "100%", WebkitOverflowScrolling: "touch", msOverflowStyle: "none", scrollbarWidth: "thin" }}>
                  <div className="flex items-start relative px-2" style={{ width: `${timeSlots.length * 68}px`, minHeight: "200px", gap: "1px" }}>
                    {(() => {
                      const now = new Date();
                      const currentHour = now.getHours();
                      const currentMinute = now.getMinutes();
                      let currentSlotIndex = -1;
                      for (let i = 0; i < timeSlots.length; i++) {
                        const slot = timeSlots[i];
                        if (slot.minute === 0 && slot.hour === currentHour && currentMinute < 30) {
                          currentSlotIndex = i;
                          break;
                        } else if (slot.minute === 30 && slot.hour === currentHour && currentMinute >= 30) {
                          currentSlotIndex = i;
                          break;
                        }
                      }
                      if (currentSlotIndex >= 0) {
                        const leftPosition = currentSlotIndex * 68 + 34;
                        return (
                          <div className="absolute top-2 bg-blue-500 text-white text-xs px-2 py-1 rounded-full font-bold z-20 whitespace-nowrap transform -translate-x-1/2 animate-pulse" style={{ left: `${leftPosition}px` }}>
                            AGORA: {now.toLocaleTimeString("pt-BR", { hour: "2-digit", minute: "2-digit" })}
                          </div>
                        );
                      }
                      return null;
                    })()}

                    {timeSlots.map((slot) => {
                      const isCurrentSlot = slot.hour === timelineData.currentHour && ((slot.minute === 0 && currentTime.getMinutes() < 30) || (slot.minute === 30 && currentTime.getMinutes() >= 30));
                      const slotHabits = habitsByTime[`${slot.hour}-${slot.minute}`] || [];
                      const isMainHour = slot.minute === 0;

                      return (
                        <div key={`${slot.hour}-${slot.minute}`} className="flex flex-col items-center flex-shrink-0" style={{ width: "68px" }}>
                          <div className="flex flex-col items-center mb-4">
                            <div className={`w-0.5 mb-2 transition-all duration-300 ${isCurrentSlot ? "bg-blue-400 shadow-blue-400/50 shadow-lg scale-110 h-10" : isMainHour ? "bg-gray-500 h-8" : "bg-gray-600 h-6"}`} />
                            <div className={`text-xs font-medium transition-all duration-300 whitespace-nowrap ${isCurrentSlot ? "text-blue-300 font-bold scale-110" : isMainHour ? "text-gray-300" : "text-gray-500"}`}>{slot.display}</div>
                            {slotHabits.length > 0 && (
                              <div className="flex gap-1 mt-1">
                                {Array.from({ length: Math.min(slotHabits.length, 3) }).map((_, i) => (
                                  <div key={i} className={`w-1 h-1 rounded-full ${isCurrentSlot ? "bg-blue-400" : "bg-gray-500"}`} />
                                ))}
                                {slotHabits.length > 3 && <span className="text-xs text-gray-500">+{slotHabits.length - 3}</span>}
                              </div>
                            )}
                          </div>

                          <div className="space-y-2 w-full">
                            {slotHabits.map((habit) => {
                              const status = getHabitStatus(habit);
                              const styling = getStatusStyling(status);
                              const isCompleted = timelineData.completionSnapshot[habit.id];
                              const isHovered = localHoveredHabit === habit.id;

                              return (
                                <div key={habit.id} className="relative">
                                  <div className={`backdrop-blur-sm rounded-lg border p-2 transition-all duration-300 cursor-pointer transform hover:scale-105 hover:z-20 ${styling.bg} ${isHovered ? "scale-110 shadow-lg" : ""} text-xs w-full max-w-full overflow-hidden`} onMouseEnter={() => setLocalHoveredHabit(habit.id)} onMouseLeave={() => setLocalHoveredHabit(null)} onClick={(e) => { e.stopPropagation(); handleHabitToggle(habit.id, new Date().getDate()); }}>
                                    <div className="flex items-center gap-1 mb-1">
                                      <span className="text-xs flex-shrink-0">{styling.icon}</span>
                                      <span className={`font-medium text-xs truncate flex-1 ${styling.text}`}>{habit.name}</span>
                                      <span className="text-xs flex-shrink-0">{priorities.find((p) => p.value === habit.priority)?.flag}</span>
                                    </div>

                                    <div className="flex items-center justify-between text-xs">
                                      <span className={`${styling.text} text-xs truncate max-w-full`}>
                                        ‚óè {(() => {
                                          const scheduleInfo = parseScheduleTime(habit.scheduleTime);
                                          if (scheduleInfo?.hours !== undefined) {
                                            return `${scheduleInfo.hours.toString().padStart(2, "0")}:${scheduleInfo.minutes.toString().padStart(2, "0")}`;
                                          }
                                          const periods = { morning: "Manh√£", afternoon: "Tarde", evening: "Noite" };
                                          return periods[habit.scheduleTime] || habit.scheduleTime;
                                        })()}
                                      </span>
                                      {isCompleted && <span className="text-green-400 font-bold text-xs">‚úì</span>}
                                    </div>

                                    {isHovered && (
                                      <div className="mt-2 pt-2 border-t border-current/20 space-y-1">
                                        <div className="flex gap-1 flex-wrap">
                                          {!isCompleted && (
                                            <button onClick={(e) => { e.stopPropagation(); handleHabitToggle(habit.id, new Date().getDate()); }} className="bg-green-500/20 hover:bg-green-500/30 px-2 py-1 rounded text-xs text-green-300 transition-colors">‚úì Concluir</button>
                                          )}
                                          {status === "overdue" && !isCompleted && (
                                            <>
                                              <button onClick={(e) => { e.stopPropagation(); snoozeHabit(habit.id, 15); }} className="bg-purple-500/20 hover:bg-purple-500/30 px-1 py-1 rounded text-xs text-purple-300 transition-colors">üò¥ 15m</button>
                                              <button onClick={(e) => { e.stopPropagation(); snoozeHabit(habit.id, 30); }} className="bg-purple-500/20 hover:bg-purple-500/30 px-1 py-1 rounded text-xs text-purple-300 transition-colors">üò¥ 30m</button>
                                            </>
                                          )}
                                        </div>
                                      </div>
                                    )}
                                  </div>
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>

              {flexibleHabits.length > 0 && (
                <div className="mt-6 space-y-3 w-full max-w-full overflow-hidden">
                  <div className="flex items-center gap-2 mb-3">
                    <Settings className="w-4 h-4 text-gray-400" />
                    <h4 className="text-sm font-bold text-white">Atividades Flex√≠veis</h4>
                    <span className="text-xs text-gray-400">({flexibleHabits.length})</span>
                  </div>

                  <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 w-full max-w-full overflow-hidden">
                    {flexibleHabits.map((habit) => {
                      const isCompleted = timelineData.completionSnapshot[habit.id];
                      return (
                        <button key={habit.id} onClick={(e) => { e.stopPropagation(); handleHabitToggle(habit.id, new Date().getDate()); }} className={`p-2 rounded-lg border transition-all duration-200 hover:scale-105 w-full max-w-full overflow-hidden ${isCompleted ? "bg-green-500/20 border-green-500/40 text-green-300" : "bg-gray-600/20 border-gray-600/40 text-gray-300 hover:border-green-500/40"}`}>
                          <div className="flex items-center gap-2 w-full max-w-full overflow-hidden">
                            <span className="text-xs flex-shrink-0">{isCompleted ? "‚úì" : "‚óã"}</span>
                            <span className="text-xs font-medium truncate flex-1">{habit.name}</span>
                            <span className="text-xs flex-shrink-0">{priorities.find((p) => p.value === habit.priority)?.flag}</span>
                          </div>
                        </button>
                      );
                    })}
                  </div>
                </div>
              )}

              <div className="mt-2 text-center w-full max-w-full overflow-hidden">
                <div className="inline-flex items-center gap-2 text-xs text-gray-400 bg-gray-800/30 px-3 py-1 rounded-full max-w-full flex-wrap">
                  <span className="truncate flex-shrink-0">üëÜ Scroll horizontal para ver 24h completas</span>
                  <span className="flex-shrink-0">‚Ä¢</span>
                  <span className="font-mono truncate flex-shrink-0">{currentTime.toLocaleTimeString("pt-BR", { hour: "2-digit", minute: "2-digit" })}</span>
                </div>
              </div>

              {timelineData.todayHabits.length === 0 && (
                <div className="text-center py-8 w-full max-w-full overflow-hidden">
                  <Clock className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                  <h4 className="text-lg font-bold text-gray-300 mb-2">Nenhum h√°bito para hoje</h4>
                  <p className="text-gray-500 text-sm">Adicione alguns h√°bitos para come√ßar sua jornada!</p>
                </div>
              )}
            </div>
          ) : (
            <div className="p-4 text-center">
              <div className="bg-gray-700/30 rounded-xl p-6 border border-gray-600">
                <Calendar className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                <h4 className="text-lg font-bold text-gray-300 mb-2">Timeline n√£o dispon√≠vel</h4>
                <p className="text-gray-400 text-sm">
                  A timeline s√≥ est√° dispon√≠vel para o m√™s atual ({new Date().toLocaleDateString("pt-BR", { month: "long", year: "numeric" })})
                </p>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }, [timelineForceUpdate]);

  TimelineHorizontal.displayName = "TimelineHorizontal";

  const BackupPanel = () => {
    if (!showBackupPanel) return null;

    return (
      <div className="fixed inset-0 bg-black/60 backdrop-blur-md flex items-center justify-center z-[100] p-4">
        <div className="bg-gray-800 backdrop-blur-md rounded-2xl border border-gray-600 shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden">
          <div className="bg-gradient-to-r from-blue-600/20 via-purple-600/20 to-cyan-600/20 p-4 border-b border-gray-700/50">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="bg-blue-500/20 p-2 rounded-lg border border-blue-500/30">
                  <Cloud className="w-5 h-5 text-blue-400" />
                </div>
                <div>
                  <h3 className="text-lg font-bold text-white">Google Drive Backup</h3>
                  <p className="text-blue-200 text-xs">
                    {isGoogleDriveAuthenticated ? `Conectado como ${googleDriveUser?.name}` : "N√£o conectado"}
                  </p>
                </div>
              </div>
              <button
                onClick={() => setShowBackupPanel(false)}
                className="p-2 text-gray-400 hover:text-white hover:bg-gray-700/50 rounded-lg transition-colors"
              >
                ‚úï
              </button>
            </div>
          </div>

          <div className="p-6 overflow-y-auto max-h-[calc(90vh-120px)]">
            {!isGoogleDriveAuthenticated ? (
              <div className="text-center space-y-4">
                <div className="bg-gray-700/50 rounded-xl p-6 border border-gray-600">
                  <CloudOff className="w-16 h-16 text-gray-400 mx-auto mb-4" />
                  <h4 className="text-lg font-bold text-white mb-2">Conectar ao Google Drive</h4>
                  <p className="text-gray-300 text-sm mb-4">
                    Conecte sua conta do Google Drive para fazer backup dos seus h√°bitos na nuvem.
                    Seus dados ficar√£o seguros e sincronizados entre dispositivos.
                  </p>
                  <button
                    onClick={authenticateGoogleDrive}
                    className="flex items-center justify-center gap-2 mx-auto px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-all font-medium hover:scale-105"
                  >
                    <Cloud className="w-4 h-4" />
                    Conectar Google Drive
                  </button>
                </div>

                <div className="bg-gray-700/30 rounded-xl p-4 border border-gray-600">
                  <h5 className="text-sm font-bold text-gray-300 mb-2">üîí Privacidade e Seguran√ßa</h5>
                  <ul className="text-xs text-gray-400 space-y-1">
                    <li>‚Ä¢ Seus dados s√£o armazenados apenas na sua conta pessoal do Google Drive</li>
                    <li>‚Ä¢ Os backups ficam em uma pasta privada da aplica√ß√£o</li>
                    <li>‚Ä¢ Voc√™ pode desconectar e excluir os backups a qualquer momento</li>
                    <li>‚Ä¢ N√£o temos acesso aos seus dados pessoais</li>
                  </ul>
                </div>
              </div>
            ) : (
              <div className="space-y-6">
                {/* User Info and Controls */}
                <div className="bg-gray-700/50 rounded-xl p-4 border border-gray-600">
                  <div className="flex items-center justify-between mb-4">
                    <div className="flex items-center gap-3">
                      {googleDriveUser?.picture && (
                        <img 
                          src={googleDriveUser.picture} 
                          alt="Profile" 
                          className="w-10 h-10 rounded-full border-2 border-green-500"
                        />
                      )}
                      <div>
                        <div className="text-white font-medium">{googleDriveUser?.name}</div>
                        <div className="text-green-400 text-xs">‚úÖ Conectado</div>
                      </div>
                    </div>
                    <button
                      onClick={disconnectGoogleDrive}
                      className="px-3 py-1 text-xs bg-red-600/20 hover:bg-red-600/30 text-red-300 rounded-lg transition-colors border border-red-500/30"
                    >
                      Desconectar
                    </button>
                  </div>

                  <div className="grid grid-cols-2 gap-3">
                    <button
                      onClick={createBackup}
                      className="flex items-center justify-center gap-2 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-all font-medium hover:scale-105"
                    >
                      <Upload className="w-4 h-4" />
                      Criar Backup
                    </button>
                    <button
                      onClick={loadAvailableBackups}
                      disabled={isLoadingBackups}
                      className="flex items-center justify-center gap-2 py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white rounded-lg transition-all font-medium hover:scale-105"
                    >
                      <RefreshCw className={`w-4 h-4 ${isLoadingBackups ? 'animate-spin' : ''}`} />
                      Atualizar Lista
                    </button>
                  </div>
                </div>

                {/* Backup Status */}
                {backupStatus && (
                  <div className="bg-gray-700/50 rounded-xl p-3 border border-gray-600 text-center">
                    <div className="text-sm font-medium text-white">{backupStatus}</div>
                  </div>
                )}

                {/* Available Backups */}
                <div className="bg-gray-700/50 rounded-xl border border-gray-600">
                  <div className="p-4 border-b border-gray-600">
                    <div className="flex items-center justify-between">
                      <h4 className="text-lg font-bold text-white flex items-center gap-2">
                        <FolderOpen className="w-5 h-5 text-blue-400" />
                        Backups Dispon√≠veis
                      </h4>
                      <span className="text-xs text-gray-400">
                        {availableBackups.length} backup{availableBackups.length !== 1 ? 's' : ''}
                      </span>
                    </div>
                  </div>

                  <div className="max-h-80 overflow-y-auto">
                    {isLoadingBackups ? (
                      <div className="p-8 text-center">
                        <RefreshCw className="w-8 h-8 text-gray-400 mx-auto mb-2 animate-spin" />
                        <div className="text-gray-400">Carregando backups...</div>
                      </div>
                    ) : availableBackups.length === 0 ? (
                      <div className="p-8 text-center">
                        <Cloud className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                        <h4 className="text-lg font-bold text-gray-300 mb-2">Nenhum backup encontrado</h4>
                        <p className="text-gray-500 text-sm">Crie seu primeiro backup para come√ßar</p>
                      </div>
                    ) : (
                      <div className="divide-y divide-gray-600">
                        {availableBackups.map((backup) => (
                          <div key={backup.id} className="p-4 hover:bg-gray-700/30 transition-colors">
                            <div className="flex items-center justify-between">
                              <div className="flex-1">
                                <div className="text-white font-medium text-sm mb-1">
                                  üì¶ Backup de {backup.date}
                                </div>
                                <div className="text-gray-400 text-xs space-y-1">
                                  <div>üïí {backup.time}</div>
                                  {backup.size && (
                                    <div>üìè {Math.round(backup.size / 1024)} KB</div>
                                  )}
                                </div>
                              </div>
                              <div className="flex items-center gap-2">
                                <button
                                  onClick={() => restoreFromBackup(backup.id, backup.displayName)}
                                  className="px-3 py-1 bg-blue-600/20 hover:bg-blue-600/30 text-blue-300 rounded text-xs transition-colors border border-blue-500/30"
                                  title="Restaurar este backup"
                                >
                                  <Download className="w-3 h-3" />
                                </button>
                                <button
                                  onClick={() => deleteBackup(backup.id, backup.displayName)}
                                  className="px-3 py-1 bg-red-600/20 hover:bg-red-600/30 text-red-300 rounded text-xs transition-colors border border-red-500/30"
                                  title="Excluir este backup"
                                >
                                  <Trash2 className="w-3 h-3" />
                                </button>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>

                <div className="bg-gray-700/30 rounded-xl p-4 border border-gray-600">
                  <h5 className="text-sm font-bold text-gray-300 mb-2">üí° Dicas de Backup</h5>
                  <ul className="text-xs text-gray-400 space-y-1">
                    <li>‚Ä¢ Crie backups regulares para n√£o perder seu progresso</li>
                    <li>‚Ä¢ Os backups incluem todos os h√°bitos, dados e configura√ß√µes</li>
                    <li>‚Ä¢ Restaurar um backup substitui todos os dados atuais</li>
                    <li>‚Ä¢ Voc√™ pode ter m√∫ltiplos backups e escolher qual restaurar</li>
                  </ul>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const generateCircularCalendar = () => {
    const habitCount = filteredHabits.length;
    const innerRadius = compactMode ? 72 : 96;

    const baseRingWidth = (() => {
      if (habitCount === 0) return 0;
      if (compactMode) {
        if (habitCount === 1) return 30;
        if (habitCount <= 5) return Math.max(22, 36 - habitCount * 2);
        if (habitCount <= 10) return Math.max(18, 30 - habitCount * 1.5);
        return Math.max(14, 24 - habitCount * 0.8);
      }
      if (habitCount === 1) return 42;
      if (habitCount <= 5) return Math.max(30, 48 - habitCount * 2);
      if (habitCount <= 10) return Math.max(24, 42 - habitCount * 1.5);
      if (habitCount <= 15) return Math.max(22, 36 - habitCount * 1);
      if (habitCount <= 20) return Math.max(19, 30 - habitCount * 0.8);
      return Math.max(17, 26 - habitCount * 0.6);
    })();

    const getRingWidth = (habitIndex) => {
      if (habitCount === 1) return compactMode ? 42 : 56;
      if (compactMode) {
        if (habitCount > 15) return Math.max(14, baseRingWidth - habitIndex * 0.4);
        if (habitCount > 10) return Math.max(17, baseRingWidth - habitIndex * 1);
        return Math.max(18, baseRingWidth - habitIndex * 1.4);
      }
      if (habitCount > 15) return Math.max(17, baseRingWidth - habitIndex * 0.6);
      if (habitCount > 10) return Math.max(19, baseRingWidth - habitIndex * 1.2);
      if (habitCount <= 4) return Math.max(26, baseRingWidth - habitIndex * 2.4);
      return Math.max(22, baseRingWidth - habitIndex * 1.8);
    };

    const dayCircleRadius = compactMode ? Math.max(14, 12 + Math.floor(habitCount / 4)) : Math.max(19, 17 + Math.floor(habitCount / 4));

    const getScaledCellSize = (habitIndex) => {
      const base = compactMode ? habitCount > 20 ? 14.4 : habitCount > 15 ? 16.8 : habitCount > 10 ? 20.4 : 16.8 : habitCount > 20 ? 20.4 : habitCount > 15 ? 22.8 : habitCount > 10 ? 26.4 : 22.8;
      if (habitCount === 1) return compactMode ? 22.8 : 28.8;
      if (habitIndex === 0) return habitCount > 20 ? compactMode ? 16.8 : 22.8 : habitCount > 15 ? compactMode ? 20.4 : 26.4 : habitCount > 10 ? compactMode ? 22.8 : 28.8 : base * 1.2;
      if (habitIndex >= 4) return compactMode ? 12 : 16.8;
      const maxSize = base * 1.2, minSize = compactMode ? 12 : 16.8;
      return Math.round(maxSize - (maxSize - minSize) * Math.pow(habitIndex / 4, habitCount > 15 ? 2 : 1.5));
    };

    let currentRadius = innerRadius;
    const ringPositions = [];
    if (habitCount > 0) {
      for (let i = filteredHabits.length - 1; i >= 0; i--) {
        const ringWidth = getRingWidth(i);
        currentRadius += ringWidth;
        const adjustedRadius = habitCount === 1 ? currentRadius * 1.25 : currentRadius;
        ringPositions[i] = adjustedRadius - ringWidth / 2;
      }
    }

    const daySpacing = compactMode ? habitCount > 6 ? 18 : 12 : habitCount > 6 ? 30 : 18;
    let dayRadius = currentRadius + dayCircleRadius + (habitCount === 0 ? 48 : daySpacing);

    if (habitCount === 1) dayRadius = dayRadius * 1.25;

    const svgSize = compactMode ? Math.max(600, dayRadius * 2 + 96) : Math.max(720, dayRadius * 2 + 120);
    const centerX = svgSize / 2, centerY = svgSize / 2;
    const anglePerDay = 270 / daysInMonth;

    const getDayAngle = (day) => {
      const totalAngleUsed = (day - 1) * anglePerDay;
      return totalAngleUsed < 90 ? 270 + totalAngleUsed : totalAngleUsed < 180 ? totalAngleUsed - 90 : 90 + (totalAngleUsed - 180);
    };

    const fixedElements = [], rotatingElements = [];

    fixedElements.push(
      <g key="center" style={{ cursor: "pointer" }} onClick={() => setShowAddForm(!showAddForm)}>
        <defs>
          <radialGradient id="centerGradient" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stopColor={showAddForm ? "rgba(34, 197, 94, 0.3)" : "rgba(0,0,0,0.9)"} />
            <stop offset="100%" stopColor={showAddForm ? "rgba(34, 197, 94, 0.1)" : "rgba(0,0,0,0.7)"} />
          </radialGradient>
        </defs>
        <circle cx={centerX} cy={centerY} r={innerRadius - 10} fill="url(#centerGradient)" stroke={showAddForm ? "#22C55E" : "rgba(255,255,255,0.3)"} strokeWidth="3" className={animations ? "transition-all duration-300" : ""} filter="drop-shadow(0 4px 8px rgba(0,0,0,0.3))" />
        <line x1={centerX - 15} y1={centerY} x2={centerX + 15} y2={centerY} stroke={showAddForm ? "#22C55E" : "#ffffff"} strokeWidth="3" strokeLinecap="round" className={animations ? "transition-colors duration-200" : ""} />
        <line x1={centerX} y1={centerY - 15} x2={centerX} y2={centerY + 15} stroke={showAddForm ? "#22C55E" : "#ffffff"} strokeWidth="3" strokeLinecap="round" className={animations ? "transition-colors duration-200" : ""} />
        <text x={centerX} y={centerY + 34} textAnchor="middle" className="font-bold" fill={showAddForm ? "#22C55E" : "#ffffff"} style={{ fontSize: "12px" }}>{showAddForm ? "Fechar" : "Adicionar"}</text>
      </g>
    );

    const labelAngle = 270 - anglePerDay * 1.2;
    const labelRadian = (labelAngle * Math.PI) / 180;
    const labelX = centerX + dayRadius * Math.cos(labelRadian);
    const labelY = centerY + dayRadius * Math.sin(labelRadian);

    fixedElements.push(
      <g key="day-label">
        <defs>
          <radialGradient id="dayLabelGradient" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stopColor="rgba(59, 130, 246, 0.2)" />
            <stop offset="100%" stopColor="rgba(59, 130, 246, 0.05)" />
          </radialGradient>
        </defs>
        <circle cx={labelX} cy={labelY} r={dayCircleRadius} fill="url(#dayLabelGradient)" stroke="#3B82F6" strokeWidth="2" strokeDasharray="3,3" filter="drop-shadow(0 2px 4px rgba(59, 130, 246, 0.3))" />
        <text x={labelX} y={labelY + 3} textAnchor="middle" className="font-bold fill-blue-400" style={{ fontSize: `${Math.max(12, dayCircleRadius * 0.6)}px` }}>DIA</text>
      </g>
    );

    const nonHoveredHabits = filteredHabits.filter((_, index) => hoveredHabit !== filteredHabits[index].id);
    const hoveredHabitData = filteredHabits.find((habit) => habit.id === hoveredHabit);

    nonHoveredHabits.forEach((habit) => {
      const habitIndex = filteredHabits.findIndex((h) => h.id === habit.id);
      const radius = ringPositions[habitIndex];
      const segmentY = centerY + radius * Math.sin((270 * Math.PI) / 180);

      const isSelected = selectedHabitId === habit.id;
      const baseFontSize = isSelected ? 16 : 12;
      const flagSize = isSelected ? 20 : 16;
      const textLength = habit.name.length;
      const streaks = calculateStreak(habit.id);
      const hasStreakInfo = showStreaks && (streaks.current > 0 || streaks.best > 3);

      const baseWidth = Math.max(200, textLength * (baseFontSize * 0.6));
      const streakWidth = hasStreakInfo ? 40 : 0;
      const labelWidth = Math.min(350, baseWidth + streakWidth + 80);
      const labelHeight = Math.max(19, baseFontSize + 10);

      const safeDistance = compactMode ? habitCount > 6 ? 36 : 30 : habitCount > 6 ? 48 : 36;
      const labelX = centerX - labelWidth - safeDistance;
      const circleX = labelX + labelWidth - 24;
      const textEndX = circleX - 36;

      fixedElements.push(
        <g key={`habit-label-${habit.id}`} onMouseEnter={() => setHoveredHabit(habit.id)} onMouseLeave={() => setHoveredHabit(null)} onClick={() => setSelectedHabitId(selectedHabitId === habit.id ? null : habit.id)} style={{ transform: isSelected ? "scale(1.1)" : "scale(1)", transition: animations ? "all 0.3s ease" : "none", transformOrigin: `${labelX + labelWidth / 2}px ${segmentY}px`, cursor: "pointer" }}>
          <defs>
            <linearGradient id={`gradient-${habit.id}`} x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stopColor={isSelected ? "rgba(59, 130, 246, 0.95)" : "rgba(0,0,0,0.95)"} />
              <stop offset="100%" stopColor={isSelected ? "rgba(59, 130, 246, 0.85)" : "rgba(0,0,0,0.85)"} />
            </linearGradient>
          </defs>
          <rect x={labelX} y={segmentY - labelHeight / 2} width={labelWidth} height={labelHeight} rx={14} fill={`url(#gradient-${habit.id})`} stroke={isSelected ? "#3B82F6" : autoColors[habitIndex % autoColors.length].base} strokeWidth={isSelected ? "3" : "2"} filter={isSelected ? "drop-shadow(0 0 12px rgba(59, 130, 246, 0.4))" : "drop-shadow(2px 2px 4px rgba(0,0,0,0.3))"} />
          <text x={labelX + 18} y={segmentY + 2} textAnchor="middle" className="text-sm" style={{ fontSize: `${flagSize}px` }}>{priorities.find((p) => p.value === habit.priority).flag}</text>
          <text x={textEndX} y={segmentY + 2} textAnchor="end" className="font-semibold" style={{ fontSize: `${baseFontSize}px`, fill: "#ffffff" }}>{habit.name}</text>
          {showStreaks && streaks.current > 0 && <text x={textEndX + 40} y={segmentY + 2} textAnchor="end" style={{ fontSize: isSelected ? "12px" : "10px", fill: "#10B981", fontWeight: isSelected ? "bold" : "normal" }}>üî•{streaks.current}</text>}
          <circle cx={circleX} cy={segmentY} r={10} fill={autoColors[habitIndex % autoColors.length].base} stroke={isSelected ? "#3B82F6" : "#fff"} strokeWidth={isSelected ? "3" : "2"} />
          <text x={circleX} y={segmentY + 4} textAnchor="middle" className="text-xs font-bold" style={{ fill: "#ffffff", fontSize: isSelected ? "12px" : "10px" }}>{habitIndex + 1}</text>
        </g>
      );
      fixedElements.push(<circle key={`ring-bg-${habit.id}`} cx={centerX} cy={centerY} r={radius} fill="none" stroke={isSelected ? "rgba(59, 130, 246, 0.3)" : "rgba(255,255,255,0.1)"} strokeWidth={isSelected ? "2" : "1"} />);
    });

    if (hoveredHabitData) {
      const habitIndex = filteredHabits.findIndex((h) => h.id === hoveredHabitData.id);
      const radius = ringPositions[habitIndex];
      const segmentY = centerY + radius * Math.sin((270 * Math.PI) / 180);

      const isSelected = selectedHabitId === hoveredHabitData.id;
      const baseFontSize = isSelected ? 20 : 18;
      const flagSize = isSelected ? 28 : 24;
      const textLength = hoveredHabitData.name.length;
      const streaks = calculateStreak(hoveredHabitData.id);
      const hasStreakInfo = showStreaks && (streaks.current > 0 || streaks.best > 3);

      const baseWidth = Math.max(200, textLength * (baseFontSize * 0.6));
      const streakWidth = hasStreakInfo ? 40 : 0;
      const labelWidth = Math.min(350, baseWidth + streakWidth + 80);
      const labelHeight = Math.max(19, baseFontSize + 10);

      const safeDistance = compactMode ? habitCount > 6 ? 36 : 30 : habitCount > 6 ? 48 : 36;
      const labelX = centerX - labelWidth - safeDistance;
      const circleX = labelX + labelWidth - 24;
      const textEndX = circleX - 36;

      fixedElements.push(
        <g key={`habit-label-hovered-${hoveredHabitData.id}`} onMouseEnter={() => setHoveredHabit(hoveredHabitData.id)} onMouseLeave={() => setHoveredHabit(null)} onClick={() => setSelectedHabitId(selectedHabitId === hoveredHabitData.id ? null : hoveredHabitData.id)} style={{ transform: "scale(1.15)", transition: animations ? "all 0.3s ease" : "none", transformOrigin: `${labelX + labelWidth / 2}px ${segmentY}px`, zIndex: 1000, cursor: "pointer" }}>
          <defs>
            <linearGradient id={`gradient-hovered-${hoveredHabitData.id}`} x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stopColor={isSelected ? "rgba(59, 130, 246, 0.98)" : "rgba(0,0,0,0.98)"} />
              <stop offset="100%" stopColor={isSelected ? "rgba(59, 130, 246, 0.92)" : "rgba(0,0,0,0.92)"} />
            </linearGradient>
          </defs>
          <rect x={labelX} y={segmentY - labelHeight / 2} width={labelWidth} height={labelHeight} rx={14} fill={`url(#gradient-hovered-${hoveredHabitData.id})`} stroke={isSelected ? "#3B82F6" : autoColors[habitIndex % autoColors.length].base} strokeWidth="3" filter={isSelected ? "drop-shadow(0 0 15px rgba(59, 130, 246, 0.6))" : "drop-shadow(4px 4px 12px rgba(0,0,0,0.5))"} />
          <text x={labelX + 18} y={segmentY + 2} textAnchor="middle" className="text-sm" style={{ fontSize: `${flagSize}px` }}>{priorities.find((p) => p.value === hoveredHabitData.priority).flag}</text>
          <text x={textEndX} y={segmentY + 2} textAnchor="end" className="font-semibold" style={{ fontSize: `${baseFontSize}px`, fill: "#ffffff" }}>{hoveredHabitData.name}</text>
          {showStreaks && streaks.current > 0 && <text x={textEndX + 40} y={segmentY + 2} textAnchor="end" style={{ fontSize: "12px", fill: "#10B981", fontWeight: "bold" }}>üî•{streaks.current}</text>}
          <circle cx={circleX} cy={segmentY} r={10} fill={autoColors[habitIndex % autoColors.length].base} stroke={isSelected ? "#3B82F6" : "#3B82F6"} strokeWidth="4" />
          <text x={circleX} y={segmentY + 4} textAnchor="middle" className="text-xs font-bold" style={{ fill: "#ffffff", fontSize: "15px" }}>{habitIndex + 1}</text>
        </g>
      );
    }

    for (let day = 1; day <= daysInMonth; day++) {
      const angle = getDayAngle(day), radian = (angle * Math.PI) / 180;
      const x = centerX + dayRadius * Math.cos(radian), y = centerY + dayRadius * Math.sin(radian);
      const today = new Date(), isToday = day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
      const dayProgress = getDailyProgress(day), date = new Date(currentYear, currentMonth, day), dayOfWeek = date.getDay();
      const dayNames = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"], dayName = dayNames[dayOfWeek];
      const weekendColor = dayOfWeek === 0 || dayOfWeek === 6 ? "#EF4444" : "#6B7280";
      const weekendTextColor = dayOfWeek === 0 || dayOfWeek === 6 ? "#FEE2E2" : "#D1D5DB";
      const isBlurred = focusedDay !== null && focusedDay !== day;

      rotatingElements.push(
        <g key={`day-${day}`} style={{ cursor: isBlurred ? "not-allowed" : "pointer", opacity: isBlurred ? 0.3 : 1, transition: animations ? "all 0.6s ease" : "none", filter: isBlurred ? "blur(1px)" : "none" }} onClick={(e) => { e.stopPropagation(); if (focusedDay === null || focusedDay === day) handleDayClick(day); }}>
          <defs>
            <radialGradient id={`dayGradient-${day}`} cx="50%" cy="50%" r="50%">
              <stop offset="0%" stopColor={isToday ? "#374151" : "rgba(31, 41, 55, 0.9)"} />
              <stop offset="100%" stopColor={isToday ? "#1F2937" : "rgba(31, 41, 55, 0.7)"} />
            </radialGradient>
          </defs>
          <circle cx={x} cy={y} r={dayCircleRadius} fill={`url(#dayGradient-${day})`} stroke={isToday ? "#F59E0B" : weekendColor} strokeWidth={isToday ? "3" : "2"} filter="drop-shadow(0 2px 4px rgba(0,0,0,0.2))" />
          {dayProgress > 0 && <circle cx={x} cy={y} r={dayCircleRadius - 3} fill="none" stroke="#10B981" strokeWidth="3" strokeDasharray={`${2 * Math.PI * (dayCircleRadius - 3)}`} strokeDashoffset={`${2 * Math.PI * (dayCircleRadius - 3) * (1 - dayProgress / 100)}`} strokeLinecap="round" transform={`rotate(-90 ${x} ${y})`} />}
          <g transform={`rotate(${-rotationAngle} ${x} ${y})`}>
            <text x={x} y={y - 2} textAnchor="middle" className={`font-bold ${isToday ? "fill-white" : "fill-gray-200"}`} style={{ fontSize: `${Math.max(14, dayCircleRadius * 0.7)}px`, fill: hoveredDay === day ? "#F59E0B" : isToday ? "#ffffff" : "#D1D5DB" }}>{day}</text>
            <text x={x} y={y + 12} textAnchor="middle" className="font-medium" fill={hoveredDay === day ? "#F59E0B" : isToday ? "#F59E0B" : weekendTextColor} style={{ fontSize: `${Math.max(10, dayCircleRadius * 0.4)}px` }}>{dayName}</text>
          </g>
        </g>
      );
    }

    filteredHabits.forEach((habit, habitIndex) => {
      const radius = ringPositions[habitIndex];
      for (let day = 1; day <= daysInMonth; day++) {
        if (!shouldShowLosangeForDay(habit, day)) continue;
        const angle = getDayAngle(day), radian = (angle * Math.PI) / 180;
        const x = centerX + radius * Math.cos(radian), y = centerY + radius * Math.sin(radian);
        const isCompleted = isHabitCompleted(habit.id, day), cellSize = getScaledCellSize(habitIndex), halfSize = cellSize / 2;
        const isBlurred = focusedDay !== null && focusedDay !== day, isClickDisabled = focusedDay !== null && focusedDay !== day;
        const points = [
          { x: x + halfSize, y: y },
          { x: x, y: y - halfSize },
          { x: x - halfSize, y: y },
          { x: x, y: y + halfSize },
        ];
        const pathData = `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y} L ${points[2].x} ${points[2].y} L ${points[3].x} ${points[3].y} Z`;

        const timeStatus = getHabitTimeStatus(habit, day);
        const timeColor = getTimeStatusColor(timeStatus);

        const baseFill = isCompleted ? autoColors[habitIndex % autoColors.length].base : "rgba(255,255,255,0.15)";
        const baseStroke = autoColors[habitIndex % autoColors.length].base;
        const finalStroke = timeColor && habit.priority !== "low" ? timeColor : baseStroke;

        const hasTimeIndicator = timeColor && habit.priority !== "low";
        const strokeWidth = hasTimeIndicator ? timeStatus === "due-now" ? "4" : timeStatus === "overdue" ? "3" : "2" : isCompleted ? "2" : "1";
        const extraClasses = timeStatus === "due-now" ? "animate-pulse" : "";

        rotatingElements.push(
          <path key={`${habit.id}-${day}`} d={pathData} fill={baseFill} stroke={finalStroke} strokeWidth={strokeWidth} className={`${!isClickDisabled ? "cursor-pointer" : ""} ${extraClasses}`} style={{ opacity: isBlurred ? 0.2 : isCompleted ? 1 : 0.7, transition: "opacity 0.2s ease", cursor: isClickDisabled ? "not-allowed" : "pointer", filter: isCompleted ? "drop-shadow(0 1px 2px rgba(0,0,0,0.2))" : "none" }} onClick={(e) => { e.stopPropagation(); if (!isClickDisabled) toggleHabitDay(habit.id, day); }} onMouseEnter={() => { if (!isClickDisabled) { setHoveredDay(day); setHoveredHabit(habit.id); } }} onMouseLeave={() => { if (!isClickDisabled) { setHoveredDay(null); setHoveredHabit(null); } }} />
        );

        if (hasTimeIndicator && timeStatus !== "no-schedule" && timeStatus !== "future") {
          rotatingElements.push(<circle key={`${habit.id}-${day}-indicator`} cx={x} cy={y} r="3" fill={timeColor} className={timeStatus === "due-now" ? "animate-pulse" : ""} style={{ filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.3))", pointerEvents: "none" }} />);
        }
      }
    });

    return { fixedElements, rotatingElements, svgSize };
  };

  const stats = getMonthlyStats();
  const { fixedElements, rotatingElements, svgSize } = generateCircularCalendar();

  const SaveStatusIndicator = () => {
    const getStatusIcon = () => {
      switch (saveStatus) {
        case "saving": return <Save className="w-4 h-4 text-blue-400 animate-spin" />;
        case "saved": return <CheckCircle className="w-4 h-4 text-green-400" />;
        case "error": return <AlertCircle className="w-4 h-4 text-red-400" />;
        default: return <Save className="w-4 h-4 text-gray-400" />;
      }
    };

    const getStatusText = () => {
      switch (saveStatus) {
        case "saving": return "Salvando...";
        case "saved": return lastSaveTime ? `Salvo ${new Date(lastSaveTime).toLocaleTimeString("pt-BR")}` : "Salvo";
        case "error": return "Erro ao salvar";
        default: return "Salvamento desconhecido";
      }
    };

    const getStatusColor = () => {
      switch (saveStatus) {
        case "saving": return "border-blue-500/40 bg-blue-500/10";
        case "saved": return "border-green-500/40 bg-green-500/10";
        case "error": return "border-red-500/40 bg-red-500/10";
        default: return "border-gray-500/40 bg-gray-500/10";
      }
    };

    return (
      <div className={`flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm ${getStatusColor()}`}>
        {getStatusIcon()}
        <span className="text-xs font-medium text-white">{getStatusText()}</span>
        {autoSaveEnabled && <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse" title="Auto-save ativo" />}
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-900 p-4 overflow-x-hidden">
      <div className="max-w-7xl mx-auto overflow-hidden">
        <div className="text-center mb-8">
          <h1 className="text-6xl md:text-7xl font-black mb-4 tracking-tight text-white" style={{ letterSpacing: "4px", fontWeight: "900", textShadow: "0 4px 20px rgba(255,255,255,0.1), 0 8px 40px rgba(255,255,255,0.05)" }}>
            üìä RASTREADOR DE H√ÅBITOS
          </h1>
          <div className="w-32 h-1 bg-gradient-to-r from-yellow-400 to-orange-400 mx-auto rounded-full mb-6"></div>

          <div className="flex items-center justify-center gap-4 mb-4">
            <SaveStatusIndicator />
            <button onClick={() => { setAutoSaveEnabled(!autoSaveEnabled); if (!autoSaveEnabled) autoSave(true); }} className={`flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm transition-all ${autoSaveEnabled ? "border-green-500/40 bg-green-500/10 text-green-300" : "border-gray-500/40 bg-gray-500/10 text-gray-400"}`} title={autoSaveEnabled ? "Desativar salvamento autom√°tico" : "Ativar salvamento autom√°tico"}>
              <Settings className="w-3 h-3" />
              <span className="text-xs font-medium">Auto-save {autoSaveEnabled ? "ON" : "OFF"}</span>
            </button>
            <button onClick={() => setShowBackupPanel(true)} className={`flex items-center gap-2 px-3 py-1 rounded-full border backdrop-blur-sm transition-all ${isGoogleDriveAuthenticated ? "border-purple-500/40 bg-purple-500/10 text-purple-300" : "border-gray-500/40 bg-gray-500/10 text-gray-400"}`} title={isGoogleDriveAuthenticated ? "Backup conectado - Clique para gerenciar" : "Configurar backup na nuvem"}>
              {isGoogleDriveAuthenticated ? <Cloud className="w-3 h-3" /> : <CloudOff className="w-3 h-3" />}
              <span className="text-xs font-medium">Backup {isGoogleDriveAuthenticated ? "ON" : "OFF"}</span>
            </button>
          </div>

          <div className="flex items-center justify-center gap-6 mb-6">
            <button onClick={() => {
              let [newMonth, newYear] = [currentMonth - 1, currentYear];
              if (newMonth < 0) { newMonth = 11; newYear--; }
              setCurrentMonth(newMonth); setCurrentYear(newYear); setFocusedDay(null); setRotationAngle(0);
              timelineVersionRef.current += 1; savedScrollPositionRef.current = 0; timelineInitialScrollDoneRef.current = false; timelineUserInteractedRef.current = false; updateTimelineData();
              setEditingHabitId(null); setEditForm({ name: "", priority: "", daysType: "" }); setExpandedHabitDetails(null);
            }} className="px-4 py-3 bg-gray-800 hover:bg-gray-700 backdrop-blur-sm rounded-xl transition-all duration-200 text-white font-medium border border-gray-600 hover:border-gray-500 hover:scale-105">‚Üê</button>
            <div className="px-8 py-3 bg-gray-800 backdrop-blur-sm rounded-xl border border-gray-600">
              <span className="text-xl font-bold text-white" style={{ textTransform: "uppercase" }}>{monthNames[currentMonth]} {currentYear}</span>
            </div>
            <button onClick={() => {
              let [newMonth, newYear] = [currentMonth + 1, currentYear];
              if (newMonth > 11) { newMonth = 0; newYear++; }
              setCurrentMonth(newMonth); setCurrentYear(newYear); setFocusedDay(null); setRotationAngle(0);
              timelineVersionRef.current += 1; savedScrollPositionRef.current = 0; timelineInitialScrollDoneRef.current = false; timelineUserInteractedRef.current = false; updateTimelineData();
              setEditingHabitId(null); setEditForm({ name: "", priority: "", daysType: "" }); setExpandedHabitDetails(null);
            }} className="px-4 py-3 bg-gray-800 hover:bg-gray-700 backdrop-blur-sm rounded-xl transition-all duration-200 text-white font-medium border border-gray-600 hover:border-gray-500 hover:scale-105">‚Üí</button>
          </div>
        </div>

        <div className="grid xl:grid-cols-5 lg:grid-cols-3 gap-6 w-full max-w-full overflow-hidden">
          <div className="xl:col-span-5 lg:col-span-3 mb-4">
            <div className="flex items-center justify-center gap-4 flex-wrap">
              {overdueCount > 0 && !overdueNotificationClosed && (
                <div className="bg-gradient-to-r from-red-500/15 to-orange-500/15 border border-red-500/40 rounded-xl px-4 py-2 backdrop-blur-sm">
                  <div className="flex items-center gap-3">
                    <div className="relative bg-red-500 rounded-lg p-1.5">
                      <Clock className="w-3 h-3 text-white" />
                      <div className="absolute -top-1 -right-1 bg-orange-400 text-white text-xs font-bold rounded-full w-3 h-3 flex items-center justify-center text-[10px]">{overdueCount}</div>
                    </div>
                    <div className="flex-1">
                      <div className="font-semibold text-red-200 text-sm">{overdueCount} h√°bito{overdueCount > 1 ? "s" : ""} em atraso</div>
                      <div className="text-xs text-red-300/80">Confira sua timeline para colocar em dia</div>
                    </div>
                    <button onClick={() => setOverdueNotificationClosed(true)} className="text-red-300 hover:text-red-100 hover:bg-red-500/20 p-1 rounded transition-colors" title="Fechar aviso">‚úï</button>
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="xl:col-span-5 lg:col-span-3 mb-6 w-full overflow-hidden">
            <TimelineHorizontal />
          </div>
        </div>

        <div className="grid xl:grid-cols-5 lg:grid-cols-3 gap-6 w-full max-w-full overflow-hidden">
          <div className="xl:col-span-3 lg:col-span-2">
            <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-8 border border-gray-700 shadow-2xl relative">
              {showAddForm && (
                <div className="absolute inset-0 bg-black/60 backdrop-blur-md rounded-3xl flex items-center justify-center z-50">
                  <div className="bg-gray-800 backdrop-blur-md rounded-2xl p-6 border border-gray-600 shadow-xl max-w-md w-full mx-4">
                    <h3 className="text-lg font-bold mb-4 text-center flex items-center justify-center gap-2 text-white">
                      <Plus className="w-5 h-5 text-green-400" />Novo H√°bito
                    </h3>
                    <div className="space-y-4">
                      <input type="text" value={newHabit} onChange={(e) => setNewHabit(e.target.value)} onKeyPress={(e) => { if (e.key === "Enter") addNewHabit(); }} placeholder="Nome do h√°bito (ex: √Ågua üíß, Exerc√≠cio üèÉ‚Äç‚ôÇÔ∏è)..." maxLength={50} className="w-full px-4 py-3 rounded-xl border focus:outline-none focus:ring-2 transition-all bg-gray-700 border-gray-600 text-white placeholder-gray-400 focus:ring-green-500 focus:border-green-500" autoFocus />

                      <div>
                        <label className="block text-sm font-medium text-gray-300 mb-2">Prioridade</label>
                        <div className="flex gap-2">
                          {priorities.map((priority) => (
                            <button key={priority.value} onClick={() => setSelectedPriority(priority.value)} className={`flex-1 py-2 px-3 rounded-lg border transition-all ${selectedPriority === priority.value ? "bg-gray-600 border-gray-500 text-white" : "bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600"}`}>
                              <span className="text-sm">{priority.flag}</span>
                              <div className="text-xs">{priority.label}</div>
                            </button>
                          ))}
                        </div>
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-300 mb-2">Frequ√™ncia</label>
                        <div className="space-y-2">
                          {daysTypes.map((daysType) => (
                            <button key={daysType.value} onClick={() => setSelectedDaysType(daysType.value)} className={`w-full py-2 px-3 rounded-lg border transition-all text-left ${selectedDaysType === daysType.value ? "bg-gray-600 border-gray-500 text-white" : "bg-gray-700 border-gray-600 text-gray-300 hover:bg-gray-600"}`}>
                              <div className="flex items-center gap-2">
                                <span>{daysType.icon}</span>
                                <div>
                                  <div className="font-medium text-sm">{daysType.label}</div>
                                  <div className="text-xs opacity-75">{daysType.description}</div>
                                </div>
                              </div>
                            </button>
                          ))}
                        </div>
                      </div>

                      {selectedPriority !== "low" && (
                        <div>
                          <label className="block text-sm font-medium text-gray-300 mb-2">Hor√°rio (Opcional) <span className="text-xs text-gray-400 ml-2">‚ö° Dispon√≠vel para prioridades m√©dia e alta</span></label>
                          <div className="space-y-2">
                            <select value={selectedScheduleTime} onChange={(e) => setSelectedScheduleTime(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                              <option value="">Sem hor√°rio fixo</option>
                              <option value="morning">üåÖ Manh√£ (6h - 12h)</option>
                              <option value="afternoon">‚òÄÔ∏è Tarde (12h - 18h)</option>
                              <option value="evening">üåô Noite (18h - 23h)</option>
                              {Array.from({ length: 48 }, (_, i) => {
                                const hour = Math.floor(i / 2) + 6;
                                const minute = (i % 2) * 30;
                                if (hour >= 24) return null;
                                const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                                return <option key={timeString} value={timeString}>{timeString}</option>;
                              })}
                            </select>

                            {selectedScheduleTime && (
                              <div>
                                <label className="block text-sm font-medium text-gray-300 mb-2">Lembrete</label>
                                <select value={selectedNotificationPref} onChange={(e) => setSelectedNotificationPref(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                                  <option value="disabled">Sem lembrete</option>
                                  <option value="onTime">Na hora exata</option>
                                  <option value="15minBefore">15 min antes</option>
                                </select>
                              </div>
                            )}
                          </div>
                        </div>
                      )}

                      {selectedPriority === "low" && (
                        <div className="bg-gray-700/50 border border-gray-600 rounded-lg p-3">
                          <div className="flex items-center gap-2 text-gray-300 text-sm">
                            <span>üí°</span>
                            <span>H√°bitos de baixa prioridade s√£o flex√≠veis - sem hor√°rios ou lembretes</span>
                          </div>
                        </div>
                      )}

                      <div className="flex gap-3">
                        <button onClick={addNewHabit} className="flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-green-600 hover:bg-green-700 text-white hover:scale-105">Adicionar</button>
                        <button onClick={() => { setShowAddForm(false); setNewHabit(""); setSelectedPriority("medium"); setSelectedDaysType("all"); setSelectedScheduleTime(""); setSelectedNotificationPref("onTime"); }} className="flex-1 py-3 rounded-xl font-medium transition-all shadow-sm bg-gray-600 hover:bg-gray-700 text-white">Cancelar</button>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              <div className="flex justify-center">
                <svg width={svgSize} height={svgSize} viewBox={`0 0 ${svgSize} ${svgSize}`} className="max-w-full h-auto" onClick={handleCalendarClick}>
                  {fixedElements}
                  <g style={{ transform: `rotate(${rotationAngle}deg)`, transition: animations ? "transform 0.6s ease" : "none", transformOrigin: "center" }}>
                    {rotatingElements}
                  </g>
                </svg>
              </div>
            </div>
          </div>

          <div className="xl:col-span-2 lg:col-span-1 space-y-6">
            <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
              <h3 className="text-lg font-bold text-white mb-4 flex items-center gap-2">
                <Filter className="w-5 h-5 text-yellow-400" />Filtros e Configura√ß√µes
              </h3>
              <div className="space-y-4">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
                  <input type="text" placeholder="Buscar h√°bitos..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full pl-10 pr-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500" />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-300 mb-2">Filtrar por prioridade</label>
                  <select value={priorityFilter} onChange={(e) => setPriorityFilter(e.target.value)} className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="all">Todas as prioridades</option>
                    {priorities.map((priority) => (
                      <option key={priority.value} value={priority.value}>{priority.flag} {priority.label}</option>
                    ))}
                  </select>
                </div>

                {(searchTerm || priorityFilter !== "all" || selectedHabitId) && (
                  <button onClick={() => { setSearchTerm(""); setPriorityFilter("all"); setSelectedHabitId(null); setEditingHabitId(null); setEditForm({ name: "", priority: "", daysType: "" }); }} className="w-full flex items-center justify-center gap-2 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded-lg transition-all duration-200 font-medium text-sm">
                    <RefreshCw className="w-4 h-4" />Limpar Todos os Filtros
                  </button>
                )}

                {selectedHabitId && (
                  <div className="bg-blue-600/20 border border-blue-500/50 rounded-lg p-3">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <Target className="w-4 h-4 text-blue-400" />
                        <span className="text-blue-300 text-sm font-medium">H√°bito em foco</span>
                      </div>
                      <button onClick={() => setSelectedHabitId(null)} className="text-blue-400 hover:text-blue-300 transition-colors">‚úï</button>
                    </div>
                    <div className="text-blue-200 text-xs mt-1">{allHabits.find((h) => h.id === selectedHabitId)?.name}</div>
                  </div>
                )}
              </div>
            </div>

            <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
              <div className="flex items-center gap-2 mb-4">
                <TrendingUp className="w-6 h-6 text-blue-400" />
                <h3 className="text-xl font-bold text-white">Meus H√°bitos - {monthNames[currentMonth]} {currentYear}</h3>
                <div className="ml-auto flex items-center gap-2 bg-purple-600/20 px-3 py-1 rounded-full border border-purple-500/30">
                  <Target className="w-4 h-4 text-purple-400" />
                  <span className="text-purple-300 font-medium text-sm">{filteredHabits.length} h√°bitos</span>
                </div>
              </div>
              {filteredHabits.length === 0 ? (
                <div className="text-center py-8">
                  <div className="text-4xl mb-4">üìÖ</div>
                  <p className="text-gray-300 mb-4">{allHabits.length === 0 ? "Nenhum h√°bito configurado para este m√™s" : "Nenhum h√°bito encontrado com os filtros atuais"}</p>
                  <p className="text-gray-400 text-sm mb-4">{allHabits.length === 0 ? "Clique no centro do calend√°rio para adicionar seu primeiro h√°bito" : "Tente ajustar os filtros ou limpar a busca"}</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {filteredHabits.map((habit, index) => {
                    const percentage = getCompletionPercentage(habit.id);
                    const streaks = calculateStreak(habit.id);
                    const isDetailsExpanded = expandedHabitDetails === habit.id;
                    const isEditing = editingHabitId === habit.id;

                    return (
                      <div key={habit.id}>
                        <div className="p-4 bg-gray-700/50 backdrop-blur-sm rounded-xl border border-gray-600 hover:bg-gray-700/70 transition-all duration-200">
                          {isEditing ? (
                            <div className="space-y-3">
                              <div>
                                <label className="block text-xs font-medium text-gray-300 mb-1">Nome do H√°bito</label>
                                <input type="text" value={editForm.name} onChange={(e) => setEditForm({ ...editForm, name: e.target.value })} onKeyDown={(e) => { if (e.key === "Enter" && editForm.name.trim()) saveHabitEdit(); if (e.key === "Escape") cancelHabitEdit(); }} className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm" maxLength={50} autoFocus />
                              </div>

                              <div className="grid grid-cols-2 gap-3">
                                <div>
                                  <label className="block text-xs font-medium text-gray-300 mb-1">Prioridade</label>
                                  <select value={editForm.priority} onChange={(e) => setEditForm({ ...editForm, priority: e.target.value })} className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                                    {priorities.map((priority) => (
                                      <option key={priority.value} value={priority.value}>{priority.flag} {priority.label}</option>
                                    ))}
                                  </select>
                                </div>

                                <div>
                                  <label className="block text-xs font-medium text-gray-300 mb-1">Frequ√™ncia</label>
                                  <select value={editForm.daysType} onChange={(e) => setEditForm({ ...editForm, daysType: e.target.value })} className="w-full px-3 py-2 bg-gray-600 border border-gray-500 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                                    {daysTypes.map((daysType) => (
                                      <option key={daysType.value} value={daysType.value}>{daysType.icon} {daysType.label}</option>
                                    ))}
                                  </select>
                                </div>
                              </div>

                              {editForm.priority === "low" && (
                                <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-2">
                                  <div className="flex items-center gap-2 text-yellow-300 text-xs">
                                    <span>‚ö†Ô∏è</span>
                                    <span>H√°bitos de baixa prioridade perdem hor√°rios e lembretes configurados</span>
                                  </div>
                                </div>
                              )}

                              <div className="flex gap-2 pt-2">
                                <button onClick={saveHabitEdit} disabled={!editForm.name.trim()} className="flex-1 py-2 px-3 bg-green-600 hover:bg-green-700 disabled:bg-gray-500 disabled:cursor-not-allowed text-white rounded-lg transition-colors text-sm font-medium">‚úì Salvar</button>
                                <button onClick={cancelHabitEdit} className="flex-1 py-2 px-3 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition-colors text-sm font-medium">‚úï Cancelar</button>
                              </div>
                            </div>
                          ) : (
                            <>
                              <div className="flex items-center justify-between mb-2">
                                <div className="flex items-center gap-3 flex-1">
                                  <div className="flex-1">
                                    <div className="flex items-center gap-2 mb-1">
                                      <span className="text-white font-medium cursor-pointer hover:text-blue-300 hover:underline transition-all duration-200" onClick={() => setExpandedHabitDetails(isDetailsExpanded ? null : habit.id)} title="Clique para ver detalhes">{habit.name}</span>
                                      {showStreaks && streaks.current > 0 && (
                                        <div className="flex items-center gap-1 bg-orange-500/20 px-2 py-1 rounded-full">
                                          <Flame className="w-3 h-3 text-orange-400" />
                                          <span className="text-xs text-orange-400 font-bold">{streaks.current}</span>
                                        </div>
                                      )}
                                      {showStreaks && streaks.best > 3 && (
                                        <div className="flex items-center gap-1 bg-yellow-500/20 px-2 py-1 rounded-full">
                                          <Trophy className="w-3 h-3 text-yellow-400" />
                                          <span className="text-xs text-yellow-400 font-bold">{streaks.best}</span>
                                        </div>
                                      )}
                                    </div>
                                    <div className="text-xs text-gray-400 flex items-center gap-2">
                                      <span>Anel {index + 1}</span>
                                      <span>‚Ä¢</span>
                                      <span>{daysTypes.find((dt) => dt.value === habit.daysType)?.label || "Todos os dias"}</span>
                                      <span>‚Ä¢</span>
                                      <span>{priorities.find((p) => p.value === habit.priority)?.flag} {priorities.find((p) => p.value === habit.priority)?.label}</span>
                                    </div>
                                  </div>
                                </div>
                                <div className="flex items-center gap-2">
                                  <span className="text-sm font-bold text-white">{percentage}%</span>
                                  <button onClick={() => startEditingHabit(habit)} className="p-1 text-gray-400 hover:text-blue-400 transition-colors rounded hover:bg-blue-500/20" title="Editar h√°bito">
                                    <Edit2 className="w-4 h-4" />
                                  </button>
                                  <button onClick={() => setExpandedHabitDetails(isDetailsExpanded ? null : habit.id)} className={`p-1 transition-colors rounded ${isDetailsExpanded ? "text-blue-400 bg-blue-500/20" : "text-gray-400 hover:text-blue-400 hover:bg-blue-500/20"}`} title={isDetailsExpanded ? "Fechar detalhes" : "Ver detalhes"}>
                                    <Eye className="w-4 h-4" />
                                  </button>
                                  <button onClick={() => deleteHabit(habit.id)} className="p-1 text-gray-400 hover:text-red-400 transition-colors rounded hover:bg-red-500/20" title="Excluir h√°bito">
                                    <Trash2 className="w-4 h-4" />
                                  </button>
                                </div>
                              </div>
                              <div className="w-full bg-gray-700 rounded-full h-2">
                                <div className="h-2 rounded-full transition-all duration-500" style={{ width: `${percentage}%`, backgroundColor: autoColors[index % autoColors.length].base }} />
                              </div>
                            </>
                          )}
                        </div>

                        {isDetailsExpanded && (
                          <div className="mt-2 bg-gray-800/70 backdrop-blur-sm rounded-xl border border-gray-600 p-3">
                            <h5 className="text-xs font-medium text-blue-400 mb-2 flex items-center gap-2">
                              <Eye className="w-3 h-3" />Detalhes - {habit.name}
                            </h5>

                            <div className="space-y-4">
                              <div className="grid grid-cols-4 gap-2">
                                <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                  <div className="text-xs text-gray-400 mb-1">Prioridade</div>
                                  <div className="text-white text-xs font-medium">{priorities.find((p) => p.value === habit.priority)?.flag}</div>
                                </div>
                                <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                  <div className="text-xs text-gray-400 mb-1">Frequ√™ncia</div>
                                  <div className="text-white text-xs font-medium">{daysTypes.find((dt) => dt.value === habit.daysType)?.icon}</div>
                                </div>
                                {(() => {
                                  let completed = 0, applicable = 0;
                                  for (let day = 1; day <= daysInMonth; day++) {
                                    if (shouldShowLosangeForDay(habit, day)) {
                                      applicable++;
                                      if (isHabitCompleted(habit.id, day)) completed++;
                                    }
                                  }
                                  return (
                                    <>
                                      <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                        <div className="text-xs text-gray-400 mb-1">Conclu√≠dos</div>
                                        <div className="text-green-400 text-xs font-bold">{completed}</div>
                                      </div>
                                      <div className="bg-gray-900/40 rounded-lg p-2 border border-gray-700 text-center">
                                        <div className="text-xs text-gray-400 mb-1">Aplic√°veis</div>
                                        <div className="text-blue-400 text-xs font-bold">{applicable}</div>
                                      </div>
                                    </>
                                  );
                                })()}
                              </div>

                              {habit.scheduleTime && habit.priority !== "low" && (
                                <div className="bg-blue-500/20 rounded-lg p-2 border border-blue-500/30">
                                  <div className="flex items-center justify-between text-xs">
                                    <div className="flex items-center gap-2">
                                      <Clock className="w-3 h-3 text-blue-400" />
                                      <span className="text-blue-400 font-medium">Programa√ß√£o</span>
                                    </div>
                                    <div className="text-blue-300 font-medium">
                                      {(() => {
                                        const scheduleInfo = parseScheduleTime(habit.scheduleTime);
                                        if (scheduleInfo) {
                                          if (scheduleInfo.start !== undefined) {
                                            const periods = { morning: "üåÖ Manh√£", afternoon: "‚òÄÔ∏è Tarde", evening: "üåô Noite" };
                                            return periods[habit.scheduleTime] || habit.scheduleTime;
                                          } else {
                                            return `üïê ${scheduleInfo.hours.toString().padStart(2, "0")}:${scheduleInfo.minutes.toString().padStart(2, "0")}`;
                                          }
                                        }
                                        return habit.scheduleTime;
                                      })()}
                                    </div>
                                  </div>

                                  {(() => {
                                    const today = new Date();
                                    const isToday = today.getDate() === new Date().getDate() && today.getMonth() === currentMonth && today.getFullYear() === currentYear;
                                    if (isToday && shouldShowLosangeForDay(habit, today.getDate())) {
                                      const status = getHabitTimeStatus(habit, today.getDate());
                                      const statusLabels = { completed: "‚úÖ Conclu√≠do", "due-now": "üîµ √â agora!", "due-soon": "üü° Em breve", overdue: "üî¥ Atrasado", snoozed: "üò¥ Adiado" };
                                      if (status !== "no-schedule" && status !== "future") {
                                        return <div className="mt-1 text-center text-xs font-medium text-blue-200">{statusLabels[status] || status}</div>;
                                      }
                                    }
                                    return null;
                                  })()}
                                </div>
                              )}

                              {!habit.scheduleTime && habit.priority !== "low" && (
                                <div className="bg-gray-600/20 rounded-lg p-2 border border-gray-600/30 text-center">
                                  <div className="text-gray-400 text-xs">
                                    <Clock className="w-4 h-4 mx-auto mb-1 opacity-50" />Atividade flex√≠vel - sem hor√°rio fixo
                                  </div>
                                </div>
                              )}

                              {habit.priority === "low" && (
                                <div className="bg-gray-600/20 rounded-lg p-2 border border-gray-600/30 text-center">
                                  <div className="text-gray-400 text-xs">üè≥Ô∏è H√°bito flex√≠vel - baixa prioridade</div>
                                </div>
                              )}

                              <div className="border-t border-gray-600 pt-2">
                                <h6 className="text-xs font-medium text-cyan-400 mb-2 flex items-center gap-1">
                                  <Edit2 className="w-3 h-3" />Observa√ß√µes e Links
                                </h6>
                                <div className="space-y-2">
                                  {habit.observations.map((observation, obsIndex) => (
                                    <div key={obsIndex} className="bg-gray-900/40 rounded p-2 border border-gray-700">
                                      <div className="flex items-center justify-between mb-1">
                                        <label className="text-[10px] font-medium text-gray-400">Obs. {obsIndex + 1}</label>
                                        <span className="text-[10px] text-gray-500">{observation.length}/200</span>
                                      </div>
                                      <input type="text" value={observation} onChange={(e) => updateHabitObservation(habit.id, obsIndex, e.target.value)} placeholder={obsIndex === 0 ? "Ex: https://link.com" : obsIndex === 1 ? "Nota pessoal" : "Link adicional"} className="w-full px-2 py-1 text-xs rounded border bg-gray-800 border-gray-600 text-white placeholder-gray-500 focus:outline-none focus:ring-1 focus:ring-cyan-500" maxLength={200} />
                                      {observation && observation.trim() && (
                                        <div className="mt-1 p-1.5 bg-gray-700/50 rounded border-l-2 border-cyan-500">
                                          <div className="text-[10px] text-gray-300">{renderTextWithLinks(observation)}</div>
                                        </div>
                                      )}
                                    </div>
                                  ))}
                                </div>
                                <div className="mt-2 text-[10px] text-gray-500">üí° Links com https:// ou www. ficam clic√°veis automaticamente</div>
                              </div>
                            </div>

                            <div className="mt-2 text-xs text-gray-500 flex items-center justify-end border-t border-gray-600 pt-2">
                              <button onClick={() => setExpandedHabitDetails(null)} className="text-gray-400 hover:text-white transition-colors px-2 py-1 rounded hover:bg-gray-700 text-xs">Fechar</button>
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
              <h3 className="text-lg font-bold text-white mb-3 flex items-center gap-2">
                <Settings className="w-5 h-5 text-purple-400" />Como usar
              </h3>
              <div className="text-sm text-gray-300 space-y-2">
                {[
                  { color: "text-green-400", text: "Clique no centro para adicionar novos h√°bitos" },
                  { color: "text-purple-400", text: "Clique nos losangos para marcar dias conclu√≠dos" },
                  { color: "text-cyan-400", text: "Clique em um dia para girar o calend√°rio e foc√°-lo" },
                  { color: "text-blue-400", text: "Use filtros para focar em h√°bitos espec√≠ficos" },
                  { color: "text-orange-400", text: "üî• = sequ√™ncia atual, üèÜ = melhor sequ√™ncia" },
                  { color: "text-pink-400", text: "Configure prioridades e frequ√™ncias dos h√°bitos" },
                  { color: "text-yellow-400", text: "‚è∞ H√°bitos m√©dia/alta prioridade podem ter hor√°rios" },
                  { color: "text-indigo-400", text: "üìÖ Use a Timeline para ver agenda do dia atual" },
                  { color: "text-emerald-400", text: "‚úèÔ∏è Clique no √≠cone de edi√ß√£o para modificar h√°bitos" },
                  { color: "text-teal-400", text: "üëÜ Clique no nome do h√°bito para ver detalhes completos" },
                  { color: "text-rose-400", text: "üíæ Dados salvos automaticamente a cada mudan√ßa" },
                  { color: "text-violet-400", text: "‚òÅÔ∏è Configure backup no Google Drive para sincroniza√ß√£o" },
                ].map(({ color, text }, i) => (
                  <div key={i} className="flex items-start gap-2">
                    <span className={`${color} mt-1`}>‚Ä¢</span>
                    <span>{text}</span>
                  </div>
                ))}
              </div>
            </div>

            <div className="bg-gray-800/50 backdrop-blur-xl rounded-3xl p-6 border border-gray-700 shadow-2xl">
              <h3 className="text-lg font-bold text-white mb-3 flex items-center gap-2">
                <Target className="w-5 h-5 text-green-400" />A√ß√µes R√°pidas
              </h3>
              <div className="space-y-3">
                <button onClick={() => autoSave(true)} disabled={saveStatus === "saving"} className={`w-full flex items-center justify-center gap-2 py-3 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105 ${saveStatus === "saving" ? "bg-blue-600/50 cursor-not-allowed" : "bg-blue-600 hover:bg-blue-700"}`}>
                  {saveStatus === "saving" ? <Save className="w-4 h-4 animate-spin" /> : <Save className="w-4 h-4" />}
                  {saveStatus === "saving" ? "Salvando..." : "Salvar Agora"}
                </button>

                <button 
                  onClick={() => setShowBackupPanel(true)} 
                  className="w-full flex items-center justify-center gap-2 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105"
                >
                  <Cloud className="w-4 h-4" />
                  {isGoogleDriveAuthenticated ? "Gerenciar Backups" : "Configurar Backup"}
                  {isGoogleDriveAuthenticated && (
                    <div className="bg-green-400 text-green-900 text-xs px-2 py-0.5 rounded-full font-bold">ON</div>
                  )}
                </button>

                {/* Bot√£o para criar h√°bitos de exemplo quando n√£o h√° h√°bitos */}
                {allHabits.length === 0 && (
                  <button onClick={createExampleHabits} className="w-full flex items-center justify-center gap-2 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105">
                    <Plus className="w-4 h-4" />
                    Criar H√°bitos de Exemplo
                  </button>
                )}

                {filteredHabits.length > 0 && (
                  <>
                    <button onClick={() => setShowStats(!showStats)} className={`w-full flex items-center justify-center gap-2 py-3 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105 ${showStats ? "bg-orange-700 hover:bg-orange-800" : "bg-orange-600 hover:bg-orange-700"}`}>
                      <BarChart3 className="w-4 h-4" />
                      {showStats ? "Ocultar" : "Mostrar"} Estat√≠sticas
                      <div className={`ml-1 transition-transform duration-200 ${showStats ? "rotate-180" : "rotate-0"}`}>‚ñº</div>
                    </button>

                    <div className={`overflow-hidden transition-all duration-300 ${showStats ? "max-h-[2000px] opacity-100" : "max-h-0 opacity-0"}`}>
                      <div className="bg-gray-700/30 backdrop-blur-sm rounded-xl border border-gray-600 p-4 mt-2">
                        <h4 className="text-lg font-bold text-orange-400 mb-4 flex items-center gap-2">
                          <BarChart3 className="w-5 h-5" />Estat√≠sticas Detalhadas
                        </h4>

                        <div className="space-y-4">
                          <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-600">
                            <h5 className="font-semibold text-white mb-3 flex items-center gap-2">
                              <Clock className="w-4 h-4 text-cyan-400" />An√°lise Semanal
                            </h5>
                            <div className="grid grid-cols-7 gap-2 text-xs">
                              {["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"].map((day, dayIndex) => {
                                let totalForDay = 0, countForDay = 0;
                                for (let date = 1; date <= daysInMonth; date++) {
                                  if (new Date(currentYear, currentMonth, date).getDay() === dayIndex) {
                                    totalForDay += getDailyProgress(date);
                                    countForDay++;
                                  }
                                }
                                const averageForDay = countForDay > 0 ? Math.round(totalForDay / countForDay) : 0;
                                const isWeekend = dayIndex === 0 || dayIndex === 6;
                                return (
                                  <div key={day} className={`rounded-lg p-2 text-center transition-colors hover:bg-gray-700/70 ${isWeekend ? "bg-red-500/10 border border-red-500/30" : "bg-gray-700/50"}`}>
                                    <div className={`mb-1 font-medium ${isWeekend ? "text-red-300" : "text-gray-300"}`}>{day}</div>
                                    <div className="text-white font-bold text-sm">{averageForDay}%</div>
                                    <div className="w-full bg-gray-600 rounded-full h-1 mt-1">
                                      <div className="h-1 rounded-full transition-all duration-500" style={{ width: `${averageForDay}%`, backgroundColor: averageForDay >= 80 ? "#10B981" : averageForDay >= 60 ? "#F59E0B" : "#EF4444" }} />
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                            <div className="mt-3 text-xs text-gray-400 text-center">üí° Fins de semana destacados em vermelho</div>
                          </div>

                          <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-600">
                            <h5 className="font-semibold text-white mb-3 flex items-center gap-2">
                              <TrendingUp className="w-4 h-4 text-green-400" />Performance por H√°bito
                            </h5>
                            <div className="space-y-2">
                              {filteredHabits.map((habit, index) => {
                                const percentage = getCompletionPercentage(habit.id);
                                const streaks = calculateStreak(habit.id);
                                return (
                                  <div key={habit.id} className="bg-gray-700/50 rounded-lg p-3 hover:bg-gray-700/70 transition-colors">
                                    <div className="flex items-center justify-between mb-2">
                                      <span className="text-white text-sm font-medium">{habit.name}</span>
                                      <span className="text-white text-sm font-bold">{percentage}%</span>
                                    </div>
                                    <div className="w-full bg-gray-600 rounded-full h-2 mb-2">
                                      <div className="h-2 rounded-full transition-all duration-500" style={{ width: `${percentage}%`, backgroundColor: autoColors[index % autoColors.length].base }} />
                                    </div>
                                    <div className="flex items-center justify-between text-xs text-gray-400">
                                      <span>{priorities.find((p) => p.value === habit.priority)?.flag} {priorities.find((p) => p.value === habit.priority)?.label}</span>
                                      <div className="flex items-center gap-2">
                                        {streaks.current > 0 && (
                                          <span className="flex items-center gap-1 bg-orange-500/20 px-2 py-1 rounded-full">
                                            <Flame className="w-3 h-3 text-orange-400" />
                                            <span className="text-orange-400 font-bold">{streaks.current}</span>
                                          </span>
                                        )}
                                        {streaks.best > 3 && (
                                          <span className="flex items-center gap-1 bg-yellow-500/20 px-2 py-1 rounded-full">
                                            <Trophy className="w-3 h-3 text-yellow-400" />
                                            <span className="text-yellow-400 font-bold">{streaks.best}</span>
                                          </span>
                                        )}
                                      </div>
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                          </div>

                          <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-600">
                            <h5 className="font-semibold text-white mb-3 flex items-center gap-2">
                              <Calendar className="w-4 h-4 text-blue-400" />Resumo do M√™s
                            </h5>
                            <div className="grid grid-cols-2 gap-3 text-sm">
                              {[
                                { label: "Progresso", value: `${stats.overall}%`, color: "text-blue-400", icon: "üìä" },
                                { label: "Conclu√≠das/Total", value: `${stats.completed}/${stats.total}`, color: "text-green-400", icon: "‚úÖ" },
                                { label: "Taxa de Sucesso", value: `${stats.overall}%`, color: "text-purple-400", icon: "üéØ" },
                                { label: "H√°bitos Ativos", value: filteredHabits.length, color: "text-orange-400", icon: "‚ö°" },
                              ].map(({ label, value, color, icon }, i) => (
                                <div key={i} className="bg-gray-700/50 rounded-lg p-3 hover:bg-gray-700/70 transition-colors">
                                  <div className="flex items-center gap-2 mb-1">
                                    <span>{icon}</span>
                                    <span className="text-gray-300 text-xs">{label}</span>
                                  </div>
                                  <div className={`text-lg font-bold ${color}`}>{value}</div>
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </>
                )}

                {/* Bot√£o de reset - sempre vis√≠vel */}
                <button onClick={() => customConfirm("‚ö†Ô∏è ATEN√á√ÉO: Esta a√ß√£o ir√° APAGAR PERMANENTEMENTE todos os h√°bitos, progresso, observa√ß√µes e configura√ß√µes. TUDO ser√° perdido e n√£o pode ser recuperado. Tem ABSOLUTA certeza?", clearAllData)} className="w-full flex items-center justify-center gap-2 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-all duration-200 font-medium hover:scale-105 border-2 border-red-500" disabled={resetStatus !== ""}>
                  <Trash2 className="w-4 h-4" />
                  {resetStatus || "üóëÔ∏è APAGAR TUDO PERMANENTEMENTE"}
                </button>

                {resetStatus && (
                  <div className={`text-center text-sm font-medium ${resetStatus.includes("‚úÖ") ? "text-green-400" : resetStatus.includes("‚ùå") ? "text-red-400" : "text-yellow-400"}`}>
                    {resetStatus}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
      <BackupPanel />
      <ConfirmModal />
    </div>
  );
};

export default CircularHabitCalendar;
